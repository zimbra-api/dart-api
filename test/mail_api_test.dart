import 'dart:convert';

import 'package:faker/faker.dart';
import 'package:http/http.dart' as http;
import 'package:http/testing.dart';
import 'package:test/test.dart';
import 'package:zimbra_api/src/common/enum/address_part.dart';
import 'package:zimbra_api/src/common/enum/address_type.dart';
import 'package:zimbra_api/src/common/enum/alarm_action.dart';
import 'package:zimbra_api/src/common/enum/alarm_related.dart';
import 'package:zimbra_api/src/common/enum/auto_complete_match_type.dart';
import 'package:zimbra_api/src/common/enum/browse_by.dart';
import 'package:zimbra_api/src/common/enum/comparison_comparator.dart';
import 'package:zimbra_api/src/common/enum/connection_type.dart';
import 'package:zimbra_api/src/common/enum/conv_action.dart';
import 'package:zimbra_api/src/common/enum/count_comparison.dart';
import 'package:zimbra_api/src/common/enum/date_comparison.dart';
import 'package:zimbra_api/src/common/enum/filter_condition.dart';
import 'package:zimbra_api/src/common/enum/filter_flag_name.dart';
import 'package:zimbra_api/src/common/enum/folder_action.dart';
import 'package:zimbra_api/src/common/enum/free_busy_status.dart';
import 'package:zimbra_api/src/common/enum/frequency.dart';
import 'package:zimbra_api/src/common/enum/grant_grantee_type.dart';
import 'package:zimbra_api/src/common/enum/grantee_type.dart';
import 'package:zimbra_api/src/common/enum/importance.dart';
import 'package:zimbra_api/src/common/enum/interest_type.dart';
import 'package:zimbra_api/src/common/enum/invite_class.dart';
import 'package:zimbra_api/src/common/enum/invite_status.dart';
import 'package:zimbra_api/src/common/enum/invite_type.dart';
import 'package:zimbra_api/src/common/enum/item_action.dart';
import 'package:zimbra_api/src/common/enum/logging_level.dart';
import 'package:zimbra_api/src/common/enum/mail_item_type.dart';
import 'package:zimbra_api/src/common/enum/match_type.dart';
import 'package:zimbra_api/src/common/enum/member_type.dart';
import 'package:zimbra_api/src/common/enum/msg_action.dart';
import 'package:zimbra_api/src/common/enum/number_comparison.dart';
import 'package:zimbra_api/src/common/enum/participation_status.dart';
import 'package:zimbra_api/src/common/enum/policy_type.dart';
import 'package:zimbra_api/src/common/enum/recover_account_operation.dart';
import 'package:zimbra_api/src/common/enum/recovery_account_operation.dart';
import 'package:zimbra_api/src/common/enum/relational_comparator.dart';
import 'package:zimbra_api/src/common/enum/reply_type.dart';
import 'package:zimbra_api/src/common/enum/search_sort_by.dart';
import 'package:zimbra_api/src/common/enum/string_comparison.dart';
import 'package:zimbra_api/src/common/enum/tag_action.dart';
import 'package:zimbra_api/src/common/enum/transparency.dart';
import 'package:zimbra_api/src/common/enum/value_comparison.dart';
import 'package:zimbra_api/src/common/enum/view_type.dart';
import 'package:zimbra_api/src/common/enum/week_day.dart';
import 'package:zimbra_api/src/common/enum/where_setting.dart';
import 'package:zimbra_api/src/common/type/id.dart';
import 'package:zimbra_api/src/common/type/section_attr.dart';
import 'package:zimbra_api/src/mail/message/announce_organizer_change_response.dart';
import 'package:zimbra_api/src/mail/message/begin_tracking_imap_response.dart';
import 'package:zimbra_api/src/mail/message/bounce_msg_response.dart';
import 'package:zimbra_api/src/mail/message/cancel_appointment_response.dart';
import 'package:zimbra_api/src/mail/message/cancel_task_response.dart';
import 'package:zimbra_api/src/mail/message/complete_task_instance_response.dart';
import 'package:zimbra_api/src/mail/message/counter_appointment_response.dart';
import 'package:zimbra_api/src/mail/message/decline_counter_appointment_response.dart';
import 'package:zimbra_api/src/mail/message/delete_data_source_response.dart';
import 'package:zimbra_api/src/mail/message/empty_dumpster_response.dart';
import 'package:zimbra_api/src/mail/message/enable_shared_reminder_response.dart';
import 'package:zimbra_api/src/mail/message/forward_appointment_invite_response.dart';
import 'package:zimbra_api/src/mail/message/forward_appointment_response.dart';
import 'package:zimbra_api/src/mail/message/ical_reply_response.dart';
import 'package:zimbra_api/src/mail/message/import_data_response.dart';
import 'package:zimbra_api/src/mail/message/invalidate_reminder_device_response.dart';
import 'package:zimbra_api/src/mail/message/modify_data_source_response.dart';
import 'package:zimbra_api/src/mail/message/modify_filter_rules_response.dart';
import 'package:zimbra_api/src/mail/message/modify_mailbox_metadata_response.dart';
import 'package:zimbra_api/src/mail/message/modify_outgoing_filter_rules_response.dart';
import 'package:zimbra_api/src/mail/message/purge_revision_response.dart';
import 'package:zimbra_api/src/mail/message/ranking_action_response.dart';
import 'package:zimbra_api/src/mail/message/reset_recent_message_count_response.dart';
import 'package:zimbra_api/src/mail/message/restore_contacts_response.dart';
import 'package:zimbra_api/src/mail/message/save_imap_subscriptions_response.dart';
import 'package:zimbra_api/src/mail/message/search_action_response.dart';
import 'package:zimbra_api/src/mail/message/search_request.dart';
import 'package:zimbra_api/src/mail/message/send_delivery_report_response.dart';
import 'package:zimbra_api/src/mail/message/send_share_notification_response.dart';
import 'package:zimbra_api/src/mail/message/send_verification_code_response.dart';
import 'package:zimbra_api/src/mail/message/set_mailbox_metadata_response.dart';
import 'package:zimbra_api/src/mail/message/set_recovery_account_response.dart';
import 'package:zimbra_api/src/mail/type/action_selector.dart';
import 'package:zimbra_api/src/mail/type/add_msg_spec.dart';
import 'package:zimbra_api/src/mail/type/add_recurrence_info.dart';
import 'package:zimbra_api/src/mail/type/added_comment.dart';
import 'package:zimbra_api/src/mail/type/bounce_msg_spec.dart';
import 'package:zimbra_api/src/mail/type/bulk_action.dart';
import 'package:zimbra_api/src/mail/type/calendar_item_hit_info.dart';
import 'package:zimbra_api/src/mail/type/calendar_item_info.dart';
import 'package:zimbra_api/src/mail/type/chat_summary.dart';
import 'package:zimbra_api/src/mail/type/contact_action_selector.dart';
import 'package:zimbra_api/src/mail/type/contact_spec.dart';
import 'package:zimbra_api/src/mail/type/content.dart';
import 'package:zimbra_api/src/mail/type/content_spec.dart';
import 'package:zimbra_api/src/mail/type/conv_action_selector.dart';
import 'package:zimbra_api/src/mail/type/conversation_spec.dart';
import 'package:zimbra_api/src/mail/type/diff_document_version_spec.dart';
import 'package:zimbra_api/src/mail/type/document_spec.dart';
import 'package:zimbra_api/src/mail/type/dt_time_info.dart';
import 'package:zimbra_api/src/mail/type/exclude_recurrence_info.dart';
import 'package:zimbra_api/src/mail/type/folder.dart';
import 'package:zimbra_api/src/mail/type/folder_action_selector.dart';
import 'package:zimbra_api/src/mail/type/folder_spec.dart';
import 'package:zimbra_api/src/mail/type/get_folder_spec.dart';
import 'package:zimbra_api/src/mail/type/ids_attr.dart';
import 'package:zimbra_api/src/mail/type/item_spec.dart';
import 'package:zimbra_api/src/mail/type/legacy_calendaring_data.dart';
import 'package:zimbra_api/src/mail/type/list_document_revisions_spec.dart';
import 'package:zimbra_api/src/mail/type/mail_custom_metadata.dart';
import 'package:zimbra_api/src/mail/type/message_hit_info.dart';
import 'package:zimbra_api/src/mail/type/message_info.dart';
import 'package:zimbra_api/src/mail/type/message_summary.dart';
import 'package:zimbra_api/src/mail/type/modify_contact_spec.dart';
import 'package:zimbra_api/src/mail/type/modify_search_folder_spec.dart';
import 'package:zimbra_api/src/mail/type/msg.dart';
import 'package:zimbra_api/src/mail/type/msg_part_ids.dart';
import 'package:zimbra_api/src/mail/type/msg_spec.dart';
import 'package:zimbra_api/src/mail/type/msg_to_send.dart';
import 'package:zimbra_api/src/mail/type/nested_rule.dart';
import 'package:zimbra_api/src/mail/type/new_folder_spec.dart';
import 'package:zimbra_api/src/mail/type/new_mountpoint_spec.dart';
import 'package:zimbra_api/src/mail/type/new_note_spec.dart';
import 'package:zimbra_api/src/mail/type/new_search_folder_spec.dart';
import 'package:zimbra_api/src/mail/type/note_action_selector.dart';
import 'package:zimbra_api/src/mail/type/parent_id.dart';
import 'package:zimbra_api/src/mail/type/purge_revision_spec.dart';
import 'package:zimbra_api/src/mail/type/ranking_action_spec.dart';
import 'package:zimbra_api/src/mail/type/recurrence_info.dart';
import 'package:zimbra_api/src/mail/type/save_draft_msg.dart';
import 'package:zimbra_api/src/mail/type/shared_reminder_mount.dart';
import 'package:zimbra_api/src/mail/type/tag_action_selector.dart';
import 'package:zimbra_api/src/mail/type/tag_spec.dart';
import 'package:zimbra_api/src/mail/type/target_spec.dart';
import 'package:zimbra_api/src/mail/type/task_item_info.dart';
import 'package:zimbra_api/src/mail/type/updated_alarm_info.dart';
import 'package:zimbra_api/src/mail_api.dart';

void main() {
  final faker = Faker();

  group('Mail api tests', (() {
    test('Add appointment invite test', (() async {
      final calItemId = faker.randomGenerator.integer(100);
      final invId = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);

      final data = {
        'Body': {
          'AddAppointmentInviteResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'invId': invId,
            'compNum': componentNum,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.addAppointmentInvite(Msg());

      expect(response!.calItemId, calItemId);
      expect(response.invId, invId);
      expect(response.componentNum, componentNum);
    }));

    test('Add comment test', (() async {
      final id = faker.guid.guid();
      final data = {
        'Body': {
          'AddCommentResponse': {
            '_jsns': 'urn:zimbraAccount',
            'comment': {
              'id': id,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.addComment(AddedComment(faker.guid.guid(), faker.lorem.word()));
      final comment = response!.comment!;
      expect(comment.id, id);
    }));

    test('Add msg test', (() async {
      final id = faker.guid.guid();
      final autoSendTime = faker.randomGenerator.integer(100);
      final subject = faker.lorem.word();
      final fragment = faker.lorem.word();
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.internet.userName();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);
      final dateString = faker.date.dateTime().toString();
      final utcTime = faker.date.dateTime().toUtc().millisecond;

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final uri = faker.internet.uri('http');
      final contentType = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();

      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.internet.email();

      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final summary = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final uid = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final calItemFolder = faker.lorem.word();
      final isException = faker.randomGenerator.boolean();
      final url = faker.internet.httpsUrl();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'AddMsgResponse': {
            '_jsns': 'urn:zimbraAccount',
            'm': [
              {
                'id': id,
                'autoSendTime': autoSendTime,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'fr': fragment,
                'inv': {
                  'type': InviteType.appt.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'comp': {
                    'category': [
                      {'_content': category}
                    ],
                    'comment': [
                      {'_content': comment}
                    ],
                    'contact': [
                      {'_content': contact}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'alarm': [
                      {
                        'action': AlarmAction.display.name,
                        'trigger': {
                          'abs': {
                            'd': dateString,
                          },
                          'rel': {
                            'd': dateString,
                          },
                        },
                        'repeat': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': AlarmRelated.start.name,
                          'count': repeatCount,
                        },
                        'desc': {'_content': description},
                        'attach': {
                          'uri': uri,
                          'ct': contentType,
                          '_content': binaryB64Data,
                        },
                        'summary': {'_content': summary},
                        'at': [
                          {
                            'a': address,
                            'url': url,
                            'd': displayName,
                            'sentBy': sentBy,
                            'dir': dir,
                            'lang': language,
                            'cutype': cuType,
                            'role': role,
                            'ptst': partStat.name,
                            'rsvp': rsvp,
                            'member': member,
                            'delegatedTo': delegatedTo,
                            'delegatedFrom': delegatedFrom,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'xprop': [
                          {
                            'name': name,
                            'value': value,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'fr': fragment,
                    'desc': {'_content': description},
                    'descHtml': {'_content': htmlDescription},
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'recur': {
                      'add': [
                        {'add': []}
                      ],
                      'exclude': [
                        {'exclude': []}
                      ],
                      'except': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                          'add': {'add': []},
                          'exclude': {'exclude': []},
                        }
                      ],
                      'cancel': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ],
                      'dates': [
                        {
                          'tz': timezone,
                          'dtval': [
                            {
                              's': {
                                'd': dateString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'e': {
                                'd': dateString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'dur': {
                                'neg': durationNegative,
                                'w': weeks,
                                'd': days,
                                'h': hours,
                                'm': minutes,
                                's': seconds,
                                'related': AlarmRelated.start.name,
                                'count': repeatCount,
                              },
                            }
                          ],
                        }
                      ],
                      'rule': [
                        {
                          'freq': Frequency.second.name,
                          'until': {
                            'd': dateString,
                          },
                          'count': {
                            'num': num,
                          },
                          'interval': {
                            'ival': ival,
                          },
                          'bysecond': {
                            'seclist': list,
                          },
                          'byminute': {
                            'minlist': list,
                          },
                          'byhour': {
                            'hrlist': list,
                          },
                          'byday': {
                            'wkday': [
                              {
                                'day': WeekDay.sunday.name,
                                'ordWk': ordWk,
                              }
                            ],
                          },
                          'bymonthday': {
                            'modaylist': list,
                          },
                          'byyearday': {
                            'yrdaylist': list,
                          },
                          'byweekno': {
                            'wklist': list,
                          },
                          'bymonth': {
                            'molist': list,
                          },
                          'bysetpos': {
                            'poslist': list,
                          },
                          'wkst': {
                            'day': WeekDay.sunday.name,
                          },
                          'rule-x-name': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    },
                    'exceptId': {
                      'd': dateString,
                      'tz': timezone,
                      'rangeType': recurrenceRangeType,
                    },
                    's': {
                      'd': dateString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'e': {
                      'd': dateString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'dur': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'method': method,
                    'compNum': componentNum,
                    'rsvp': rsvp,
                    'priority': priority,
                    'name': name,
                    'loc': location,
                    'percentComplete': percentComplete,
                    'completed': completed,
                    'noBlob': noBlob,
                    'fba': FreeBusyStatus.free.name,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'isOrg': isOrganizer,
                    'x_uid': xUid,
                    'uid': uid,
                    'seq': sequence,
                    'd': dateTime,
                    'calItemId': calItemId,
                    'apptId': deprecatedApptId,
                    'ciFolder': calItemFolder,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'url': url,
                    'ex': isException,
                    'ridZ': recurIdZ,
                    'allDay': isAllDay,
                    'draft': isDraft,
                    'neverSent': neverSent,
                    'changes': changes,
                  },
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ]
                  },
                },
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              }
            ],
            'chat': [
              {
                'id': id,
                'autoSendTime': autoSendTime,
                'su': subject,
                'fr': fragment,
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.addMsg(AddMsgSpec());
      final chatMessage = response!.chatMessage!;
      final message = response.message!;

      expect(chatMessage, isA<MessageSummary>());
      expect(chatMessage, isA<ChatSummary>());
      expect(chatMessage.id, id);
      expect(chatMessage.autoSendTime, autoSendTime);
      expect(chatMessage.subject, subject);
      expect(chatMessage.fragment, fragment);
      expect(chatMessage.size, size);
      expect(chatMessage.date, date);
      expect(chatMessage.folder, folder);
      expect(chatMessage.conversationId, conversationId);
      expect(chatMessage.flags, flags);
      expect(chatMessage.tags, tags);
      expect(chatMessage.tagNames, tagNames);
      expect(chatMessage.revision, revision);
      expect(chatMessage.changeDate, changeDate);
      expect(chatMessage.modifiedSequence, modifiedSequence);

      expect(message.id, id);
      expect(message.autoSendTime, autoSendTime);
      expect(message.subject, subject);
      expect(message.fragment, fragment);
      expect(message.size, size);
      expect(message.date, date);
      expect(message.folder, folder);
      expect(message.conversationId, conversationId);
      expect(message.flags, flags);
      expect(message.tags, tags);
      expect(message.tagNames, tagNames);
      expect(message.revision, revision);
      expect(message.changeDate, changeDate);
      expect(message.modifiedSequence, modifiedSequence);

      final email = message.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final meta = message.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final invite = message.invite!;
      expect(invite.calItemType, InviteType.appt);

      final tz = invite.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standardTzOnset = tz.standardTzOnset!;
      expect(standardTzOnset.month, month);
      expect(standardTzOnset.hour, hour);
      expect(standardTzOnset.minute, minute);
      expect(standardTzOnset.second, second);
      expect(standardTzOnset.dayOfMonth, dayOfMonth);
      expect(standardTzOnset.week, week);
      expect(standardTzOnset.dayOfWeek, dayOfWeek);

      final daylightTzOnset = tz.daylightTzOnset!;
      expect(daylightTzOnset.month, month);
      expect(daylightTzOnset.hour, hour);
      expect(daylightTzOnset.minute, minute);
      expect(daylightTzOnset.second, second);
      expect(daylightTzOnset.dayOfMonth, dayOfMonth);
      expect(daylightTzOnset.week, week);
      expect(daylightTzOnset.dayOfWeek, dayOfWeek);

      final reply = invite.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final inviteComponent = invite.inviteComponent!;

      expect(inviteComponent.method, method);
      expect(inviteComponent.componentNum, componentNum);
      expect(inviteComponent.rsvp, rsvp);
      expect(inviteComponent.priority, priority);
      expect(inviteComponent.name, name);
      expect(inviteComponent.location, location);
      expect(inviteComponent.percentComplete, percentComplete);
      expect(inviteComponent.completed, completed);
      expect(inviteComponent.noBlob, noBlob);
      expect(inviteComponent.freeBusyActual, FreeBusyStatus.free);
      expect(inviteComponent.freeBusy, FreeBusyStatus.free);
      expect(inviteComponent.transparency, Transparency.opaque);
      expect(inviteComponent.isOrganizer, isOrganizer);
      expect(inviteComponent.xUid, xUid);
      expect(inviteComponent.uid, uid);
      expect(inviteComponent.sequence, sequence);
      expect(inviteComponent.dateTime, dateTime);
      expect(inviteComponent.calItemId, calItemId);
      expect(inviteComponent.deprecatedApptId, deprecatedApptId);
      expect(inviteComponent.calItemFolder, calItemFolder);
      expect(inviteComponent.status, InviteStatus.completed);
      expect(inviteComponent.calClass, InviteClass.public);
      expect(inviteComponent.url, url);
      expect(inviteComponent.isException, isException);
      expect(inviteComponent.recurIdZ, recurIdZ);
      expect(inviteComponent.isAllDay, isAllDay);
      expect(inviteComponent.isDraft, isDraft);
      expect(inviteComponent.neverSent, neverSent);
      expect(inviteComponent.changes, changes);

      expect(inviteComponent.fragment, fragment);
      expect(inviteComponent.description, description);
      expect(inviteComponent.htmlDescription, htmlDescription);

      expect(inviteComponent.categories.first, category);
      expect(inviteComponent.comments.first, comment);
      expect(inviteComponent.contacts.first, contact);

      final geo = inviteComponent.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final inviteAt = inviteComponent.attendees.first;
      expect(inviteAt.address, address);
      expect(inviteAt.url, url);
      expect(inviteAt.displayName, displayName);
      expect(inviteAt.sentBy, sentBy);
      expect(inviteAt.dir, dir);
      expect(inviteAt.language, language);
      expect(inviteAt.cuType, cuType);
      expect(inviteAt.role, role);
      expect(inviteAt.partStat, partStat);
      expect(inviteAt.rsvp, rsvp);
      expect(inviteAt.member, member);
      expect(inviteAt.delegatedTo, delegatedTo);
      expect(inviteAt.delegatedFrom, delegatedFrom);
      expect(inviteAt.xParams.first.name, name);
      expect(inviteAt.xParams.first.value, value);

      final alarm = inviteComponent.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final inviteXProp = inviteComponent.xProps.first;
      expect(inviteXProp.name, name);
      expect(inviteXProp.value, value);
      expect(inviteXProp.xParams.first.name, name);
      expect(inviteXProp.xParams.first.value, value);

      final organizer = inviteComponent.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = inviteComponent.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = inviteComponent.exceptionId!;
      expect(exceptionId.dateTime, dateString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = inviteComponent.dtStart!;
      expect(dtStart.dateTime, dateString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = inviteComponent.dtEnd!;
      expect(dtEnd.dateTime, dateString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = inviteComponent.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Add task invite test', (() async {
      final calItemId = faker.randomGenerator.integer(100);
      final invId = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);

      final data = {
        'Body': {
          'AddTaskInviteResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'invId': invId,
            'compNum': componentNum,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.addTaskInvite(Msg());

      expect(response!.calItemId, calItemId);
      expect(response.invId, invId);
      expect(response.componentNum, componentNum);
    }));

    test('Announce organizer change test', (() async {
      final data = {
        'Body': {
          'AnnounceOrganizerChangeResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.announceOrganizerChange(faker.guid.guid());
      expect(response, isNotNull);
      expect(response, isA<AnnounceOrganizerChangeResponse>());
    }));

    test('Apply filter rules test', (() async {
      final ids = faker.lorem.words(3).join(',');
      final data = {
        'Body': {
          'ApplyFilterRulesResponse': {
            '_jsns': 'urn:zimbraMail',
            'm': {
              'ids': ids,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.applyFilterRules();
      final msgIds = response!.msgIds!;
      expect(msgIds.ids, ids);
    }));

    test('Apply outgoing filter rules test', (() async {
      final ids = faker.lorem.words(3).join(',');
      final data = {
        'Body': {
          'ApplyOutgoingFilterRulesResponse': {
            '_jsns': 'urn:zimbraMail',
            'm': {
              'ids': ids,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.applyOutgoingFilterRules();
      final msgIds = response!.msgIds!;
      expect(msgIds.ids, ids);
    }));

    test('Auto complete test', (() async {
      final email = faker.internet.email();
      final ranking = faker.randomGenerator.integer(100);
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();
      final id = faker.guid.guid();
      final folder = faker.guid.guid();
      final displayName = faker.person.name();
      final firstName = faker.person.firstName();
      final middleName = faker.lorem.word();
      final lastName = faker.person.lastName();
      final fullName = faker.person.name();
      final nickName = faker.lorem.word();
      final company = faker.company.name();
      final fileAs = faker.lorem.word();
      final canBeCached = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'AutoCompleteResponse': {
            '_jsns': 'urn:zimbraMail',
            'canBeCached': canBeCached,
            'match': [
              {
                'email': email,
                'type': AutoCompleteMatchType.contact.name,
                'ranking': ranking.toString(),
                'isGroup': isGroup,
                'exp': canExpandGroupMembers,
                'id': id,
                'l': folder,
                'display': displayName,
                'first': firstName,
                'middle': middleName,
                'last': lastName,
                'full': fullName,
                'nick': nickName,
                'company': company,
                'fileas': fileAs,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.autoComplete(faker.lorem.word());
      expect(response!.canBeCached, canBeCached);

      final match = response.matches.first;
      expect(match.email, email);
      expect(match.matchType, AutoCompleteMatchType.contact);
      expect(match.ranking, ranking.toString());
      expect(match.isGroup, isGroup);
      expect(match.canExpandGroupMembers, canExpandGroupMembers);
      expect(match.id, id);
      expect(match.folder, folder);
      expect(match.displayName, displayName);
      expect(match.firstName, firstName);
      expect(match.middleName, middleName);
      expect(match.lastName, lastName);
      expect(match.fullName, fullName);
      expect(match.nickName, nickName);
      expect(match.company, company);
      expect(match.fileAs, fileAs);
    }));

    test('Begin tracking IMAP test', (() async {
      final data = {
        'Body': {
          'BeginTrackingIMAPResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.beginTrackingIMAP();
      expect(response, isNotNull);
      expect(response, isA<BeginTrackingIMAPResponse>());
    }));

    test('Bounce msg test', (() async {
      final data = {
        'Body': {
          'BounceMsgResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.bounceMsg(BounceMsgSpec(faker.guid.guid()));
      expect(response, isNotNull);
      expect(response, isA<BounceMsgResponse>());
    }));

    test('Browse test', (() async {
      final browseDomainHeader = faker.lorem.word();
      final frequency = faker.randomGenerator.integer(100);
      final content = faker.lorem.word();

      final data = {
        'Body': {
          'BrowseResponse': {
            '_jsns': 'urn:zimbraMail',
            'bd': [
              {
                'h': browseDomainHeader,
                'freq': frequency,
                '_content': content,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.browse(BrowseBy.domains);
      final bd = response!.browseDatas.first;

      expect(bd.browseDomainHeader, browseDomainHeader);
      expect(bd.frequency, frequency);
      expect(bd.data, content);
    }));

    test('Cancel appointment test', (() async {
      final data = {
        'Body': {
          'CancelAppointmentResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.cancelAppointment();
      expect(response, isNotNull);
      expect(response, isA<CancelAppointmentResponse>());
    }));

    test('Cancel task test', (() async {
      final data = {
        'Body': {
          'CancelTaskResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.cancelTask();
      expect(response, isNotNull);
      expect(response, isA<CancelTaskResponse>());
    }));

    test('Check permission test', (() async {
      final allow = faker.randomGenerator.boolean();
      final rightName = faker.lorem.word();

      final data = {
        'Body': {
          'CheckPermissionResponse': {
            '_jsns': 'urn:zimbraMail',
            'allow': allow,
            'right': [
              {
                'allow': allow,
                '_content': rightName,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.checkPermission(TargetSpec());

      expect(response!.allow, allow);
      expect(response.rights.first.allow, allow);
      expect(response.rights.first.rightName, rightName);
    }));

    test('Check recur conflicts test', (() async {
      final name = faker.lorem.word();
      final startTime = faker.date.dateTime().millisecondsSinceEpoch;
      final duration = faker.randomGenerator.integer(100);
      final allDay = faker.randomGenerator.boolean();
      final tzOffset = faker.randomGenerator.integer(100);
      final recurIdZ = faker.date.dateTime().toString();

      final data = {
        'Body': {
          'CheckRecurConflictsResponse': {
            '_jsns': 'urn:zimbraMail',
            'inst': [
              {
                's': startTime,
                'dur': duration,
                'allDay': allDay,
                'tzo': tzOffset,
                'ridZ': recurIdZ,
                'usr': [
                  {
                    'name': name,
                    'fb': FreeBusyStatus.free.name,
                  }
                ],
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.checkRecurConflicts();
      final inst = response!.instances.first;

      expect(inst.startTime, startTime);
      expect(inst.duration, duration);
      expect(inst.allDay, allDay);
      expect(inst.tzOffset, tzOffset);
      expect(inst.recurIdZ, recurIdZ);

      final usr = inst.freebusyUsers.first;
      expect(usr.name, name);
      expect(usr.freebusyStatus, FreeBusyStatus.free);
    }));

    test('Check spelling test', (() async {
      final available = faker.randomGenerator.boolean();
      final word = faker.lorem.word();
      final suggestions = faker.lorem.words(3).join(',');
      final data = {
        'Body': {
          'CheckSpellingResponse': {
            '_jsns': 'urn:zimbraMail',
            'available': available,
            'misspelled': [
              {
                'word': word,
                'suggestions': suggestions,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.checkSpelling();
      final misspelled = response!.misspelledWords.first;

      expect(response.available, available);
      expect(misspelled.word, word);
      expect(misspelled.suggestions, suggestions);
    }));

    test('Complete task instance test', (() async {
      final data = {
        'Body': {
          'CompleteTaskInstanceResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.completeTaskInstance(faker.guid.guid(), DtTimeInfo());
      expect(response, isNotNull);
      expect(response, isA<CompleteTaskInstanceResponse>());
    }));

    test('Contact action test', (() async {
      final id = faker.guid.guid();
      final operation = faker.randomGenerator.element(ConvAction.values).name;
      final nonExistentIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');
      final newlyCreatedIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');
      final zimbraId = faker.guid.guid();
      final displayName = faker.person.name();
      final accessKey = faker.internet.password();

      final data = {
        'Body': {
          'ContactActionResponse': {
            '_jsns': 'urn:zimbraMail',
            'action': {
              'id': id,
              'op': operation,
              'nei': nonExistentIds,
              'nci': newlyCreatedIds,
              'zid': zimbraId,
              'd': displayName,
              'key': accessKey,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.contactAction(ContactActionSelector(faker.guid.guid(), operation));
      final action = response!.action!;

      expect(action.id, id);
      expect(action.operation, operation);
      expect(action.nonExistentIds, nonExistentIds);
      expect(action.newlyCreatedIds, newlyCreatedIds);
      expect(action.zimbraId, zimbraId);
      expect(action.displayName, displayName);
      expect(action.accessKey, accessKey);
    }));

    test('Conv action test', (() async {
      final id = faker.guid.guid();
      final operation = faker.randomGenerator.element(ConvAction.values).name;
      final nonExistentIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');
      final newlyCreatedIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');

      final data = {
        'Body': {
          'ConvActionResponse': {
            '_jsns': 'urn:zimbraMail',
            'action': {
              'id': id,
              'op': operation,
              'nei': nonExistentIds,
              'nci': newlyCreatedIds,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.convAction(ConvActionSelector(faker.guid.guid(), operation));
      final action = response!.action!;

      expect(action.id, id);
      expect(action.operation, operation);
      expect(action.nonExistentIds, nonExistentIds);
      expect(action.newlyCreatedIds, newlyCreatedIds);
    }));

    test('Counter appointment test', (() async {
      final data = {
        'Body': {
          'CounterAppointmentResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.counterAppointment();
      expect(response, isNotNull);
      expect(response, isA<CounterAppointmentResponse>());
    }));

    test('Create appointment exception test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final calInvId = faker.guid.guid();
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final revision = faker.randomGenerator.integer(100);

      final part = faker.lorem.word();
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.person.name();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final seq = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final content = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();
      final size = faker.randomGenerator.integer(100);
      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final section = faker.lorem.word();

      final data = {
        'Body': {
          'CreateAppointmentExceptionResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'apptId': deprecatedApptId,
            'invId': calInvId,
            'ms': modifiedSequence,
            'rev': revision,
            'm': {'id': id},
            'echo': {
              'm': {
                'id': id,
                'part': part,
                'sd': sentDate,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'mid': messageIdHeader,
                'inv': {
                  'type': InviteType.appt.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                  },
                  'comp': [
                    {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    }
                  ],
                },
                '_attrs': {
                  key: value,
                },
                'mp': [
                  {
                    'part': part,
                    'ct': contentType,
                    's': size,
                    'cd': contentDisposition,
                    'filename': contentFilename,
                    'ci': contentId,
                    'cl': location,
                    'body': body,
                    'truncated': truncatedContent,
                    'content': content,
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'shr': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'dlSubs': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createAppointmentException();

      expect(response!.calItemId, calItemId);
      expect(response.deprecatedApptId, deprecatedApptId);
      expect(response.calInvId, calInvId);
      expect(response.modifiedSequence, modifiedSequence);
      expect(response.msg!.id, id);

      final echo = response.echo!;
      final invite = echo.invite!;

      expect(invite.id, id);
      expect(invite.part, part);
      expect(invite.sentDate, sentDate);
      expect(invite.subject, subject);
      expect(invite.messageIdHeader, messageIdHeader);
      expect(invite.size, size);
      expect(invite.date, date);
      expect(invite.folder, folder);
      expect(invite.conversationId, conversationId);
      expect(invite.flags, flags);
      expect(invite.tags, tags);
      expect(invite.tagNames, tagNames);
      expect(invite.revision, revision);
      expect(invite.changeDate, changeDate);
      expect(invite.modifiedSequence, modifiedSequence);

      final email = invite.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final header = invite.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final mpContent = invite.mpContentElems.first;
      expect(mpContent.part, part);
      expect(mpContent.contentType, contentType);
      expect(mpContent.size, size);
      expect(mpContent.contentDisposition, contentDisposition);
      expect(mpContent.contentFilename, contentFilename);
      expect(mpContent.contentId, contentId);
      expect(mpContent.location, location);
      expect(mpContent.body, body);
      expect(mpContent.truncatedContent, truncatedContent);
      expect(mpContent.content, content);

      final mimePart = mpContent.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = invite.shrContentElems.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = invite.dlSubsContentElems.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final inv = invite.invite!;
      expect(inv.calItemType, InviteType.appt);

      final tz = inv.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = inv.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = inv.inviteComponents.first;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Create appointment test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final calInvId = faker.guid.guid();
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final revision = faker.randomGenerator.integer(100);

      final part = faker.lorem.word();
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.person.name();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final seq = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final content = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();
      final size = faker.randomGenerator.integer(100);
      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final section = faker.lorem.word();

      final data = {
        'Body': {
          'CreateAppointmentResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'apptId': deprecatedApptId,
            'invId': calInvId,
            'ms': modifiedSequence,
            'rev': revision,
            'm': {'id': id},
            'echo': {
              'm': {
                'id': id,
                'part': part,
                'sd': sentDate,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'mid': messageIdHeader,
                'inv': {
                  'type': InviteType.appt.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                  },
                  'comp': [
                    {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    }
                  ],
                },
                '_attrs': {
                  key: value,
                },
                'mp': [
                  {
                    'part': part,
                    'ct': contentType,
                    's': size,
                    'cd': contentDisposition,
                    'filename': contentFilename,
                    'ci': contentId,
                    'cl': location,
                    'body': body,
                    'truncated': truncatedContent,
                    'content': content,
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'shr': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'dlSubs': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createAppointment();

      expect(response!.calItemId, calItemId);
      expect(response.deprecatedApptId, deprecatedApptId);
      expect(response.calInvId, calInvId);
      expect(response.modifiedSequence, modifiedSequence);
      expect(response.msg!.id, id);

      final echo = response.echo!;
      final invite = echo.invite!;

      expect(invite.id, id);
      expect(invite.part, part);
      expect(invite.sentDate, sentDate);
      expect(invite.subject, subject);
      expect(invite.messageIdHeader, messageIdHeader);
      expect(invite.size, size);
      expect(invite.date, date);
      expect(invite.folder, folder);
      expect(invite.conversationId, conversationId);
      expect(invite.flags, flags);
      expect(invite.tags, tags);
      expect(invite.tagNames, tagNames);
      expect(invite.revision, revision);
      expect(invite.changeDate, changeDate);
      expect(invite.modifiedSequence, modifiedSequence);

      final email = invite.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final header = invite.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final mpContent = invite.mpContentElems.first;
      expect(mpContent.part, part);
      expect(mpContent.contentType, contentType);
      expect(mpContent.size, size);
      expect(mpContent.contentDisposition, contentDisposition);
      expect(mpContent.contentFilename, contentFilename);
      expect(mpContent.contentId, contentId);
      expect(mpContent.location, location);
      expect(mpContent.body, body);
      expect(mpContent.truncatedContent, truncatedContent);
      expect(mpContent.content, content);

      final mimePart = mpContent.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = invite.shrContentElems.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = invite.dlSubsContentElems.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final inviteMeta = invite.metadatas.first;
      expect(inviteMeta.section, section);
      expect(inviteMeta.keyValuePairs.first.key, key);
      expect(inviteMeta.keyValuePairs.first.value, value);

      final inv = invite.invite!;
      expect(inv.calItemType, InviteType.appt);

      final tz = inv.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = inv.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = inv.inviteComponents.first;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Create contact test', (() async {
      final sortField = faker.lorem.word();
      final canExpand = faker.randomGenerator.boolean();
      final id = faker.guid.guid();
      final imapUid = faker.randomGenerator.integer(100);
      final folder = faker.lorem.word();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final changeDate = faker.date.dateTime().millisecond;
      final modifiedSequenceId = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final revisionId = faker.randomGenerator.integer(100);
      final fileAs = faker.lorem.word();
      final email = faker.internet.email();
      final email2 = faker.internet.email();
      final email3 = faker.internet.email();
      final type = faker.lorem.word();
      final dlist = faker.lorem.word();
      final reference = faker.lorem.word();
      final tooManyMembers = faker.randomGenerator.boolean();
      final memberOf = faker.internet.email();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final data = {
        'Body': {
          'CreateContactResponse': {
            '_jsns': 'urn:zimbraMail',
            'cn': {
              'sf': sortField,
              'exp': canExpand,
              'id': id,
              'i4uid': imapUid,
              'l': folder,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'md': changeDate,
              'ms': modifiedSequenceId,
              'd': date,
              'rev': revisionId,
              'fileAsStr': fileAs,
              'email': email,
              'email2': email2,
              'email3': email3,
              'type': type,
              'dlist': dlist,
              'ref': reference,
              'tooManyMembers': tooManyMembers,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              '_attrs': {
                key: value,
              },
              'm': [
                {
                  'type': MemberType.contact.name,
                  '_content': value,
                  'cn': {
                    'sf': sortField,
                    'exp': canExpand,
                    'id': id,
                    'i4uid': imapUid,
                    'l': folder,
                    'f': flags,
                    't': tags,
                    'tn': tagNames,
                    'md': changeDate,
                    'ms': modifiedSequenceId,
                    'd': date,
                    'rev': revisionId,
                    'fileAsStr': fileAs,
                    'email': email,
                    'email2': email2,
                    'email3': email3,
                    'type': type,
                    'dlist': dlist,
                    'ref': reference,
                    'tooManyMembers': tooManyMembers,
                    'memberOf': {'_content': memberOf},
                  },
                }
              ],
              'memberOf': {'_content': memberOf},
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createContact(ContactSpec());
      final contact = response!.contact!;

      expect(contact.sortField, sortField);
      expect(contact.canExpand, canExpand);
      expect(contact.id, id);
      expect(contact.imapUid, imapUid);
      expect(contact.folder, folder);
      expect(contact.flags, flags);
      expect(contact.tags, tags);
      expect(contact.tagNames, tagNames);
      expect(contact.changeDate, changeDate);
      expect(contact.modifiedSequenceId, modifiedSequenceId);
      expect(contact.date, date);
      expect(contact.revisionId, revisionId);
      expect(contact.fileAs, fileAs);
      expect(contact.email, email);
      expect(contact.email2, email2);
      expect(contact.email3, email3);
      expect(contact.type, type);
      expect(contact.dlist, dlist);
      expect(contact.reference, reference);
      expect(contact.tooManyMembers, tooManyMembers);
      expect(contact.memberOf, memberOf);

      final meta = contact.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final attr = contact.attrs.first;
      expect(attr.key, key);
      expect(attr.value, value);

      final member = contact.contactGroupMembers.first;
      expect(member.type, MemberType.contact);
      expect(member.value, value);

      final cn = member.contact!;
      expect(cn.sortField, sortField);
      expect(cn.canExpand, canExpand);
      expect(cn.id, id);
      expect(cn.imapUid, imapUid);
      expect(cn.folder, folder);
      expect(cn.flags, flags);
      expect(cn.tags, tags);
      expect(cn.tagNames, tagNames);
      expect(cn.changeDate, changeDate);
      expect(cn.modifiedSequenceId, modifiedSequenceId);
      expect(cn.date, date);
      expect(cn.revisionId, revisionId);
      expect(cn.fileAs, fileAs);
      expect(cn.email, email);
      expect(cn.email2, email2);
      expect(cn.email3, email3);
      expect(cn.type, type);
      expect(cn.dlist, dlist);
      expect(cn.reference, reference);
      expect(cn.tooManyMembers, tooManyMembers);
      expect(cn.memberOf, memberOf);
    }));

    test('Create data source test', (() async {
      final id = faker.guid.guid();
      final data = {
        'Body': {
          'CreateDataSourceResponse': {
            '_jsns': 'urn:zimbraMail',
            'imap': [
              {'id': id}
            ],
            'pop3': [
              {'id': id}
            ],
            'caldav': [
              {'id': id}
            ],
            'yab': [
              {'id': id}
            ],
            'rss': [
              {'id': id}
            ],
            'gal': [
              {'id': id}
            ],
            'cal': [
              {'id': id}
            ],
            'unknown': [
              {'id': id}
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createDataSource();
      expect(response!.imapDataSource!.id, id);
      expect(response.pop3DataSource!.id, id);
      expect(response.caldavDataSource!.id, id);
      expect(response.yabDataSource!.id, id);
      expect(response.rssDataSource!.id, id);
      expect(response.galDataSource!.id, id);
      expect(response.calDataSource!.id, id);
      expect(response.unknownDataSource!.id, id);
    }));

    test('Create folder test', (() async {
      final id = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final absoluteFolderPath = faker.lorem.word();
      final parentId = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unreadCount = faker.randomGenerator.integer(100);
      final imapUnreadCount = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().minute;
      final itemCount = faker.randomGenerator.integer(100);
      final imapItemCount = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final imapModifiedSequence = faker.randomGenerator.integer(100);
      final imapUidNext = faker.randomGenerator.integer(100);
      final url = faker.internet.httpsUrl();
      final activeSyncDisabled = faker.randomGenerator.boolean();
      final webOfflineSyncDays = faker.randomGenerator.integer(100);
      final perm = faker.lorem.word();
      final recursive = faker.randomGenerator.boolean();
      final restUrl = faker.internet.httpsUrl();
      final deletable = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final lifetime = faker.randomGenerator.integer(100).toString();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);

      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();

      final ownerEmail = faker.internet.email();
      final ownerAccountId = faker.guid.guid();
      final remoteFolderId = faker.randomGenerator.integer(100);
      final remoteUuid = faker.guid.guid();
      final remoteFolderName = faker.lorem.word();
      final reminderEnabled = faker.randomGenerator.boolean();
      final broken = faker.randomGenerator.boolean();

      final query = faker.lorem.word();
      final types = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'CreateFolderResponse': {
            '_jsns': 'urn:zimbraMail',
            'folder': {
              'id': id,
              'uuid': uuid,
              'name': name,
              'absFolderPath': absoluteFolderPath,
              'l': parentId,
              'luuid': folderUuid,
              'f': flags,
              'color': color,
              'rgb': rgb,
              'u': unreadCount,
              'i4u': imapUnreadCount,
              'view': ViewType.conversation.name,
              'rev': revision,
              'ms': modifiedSequence,
              'md': changeDate,
              'n': itemCount,
              'i4n': imapItemCount,
              's': totalSize,
              'i4ms': imapModifiedSequence,
              'i4next': imapUidNext,
              'url': url,
              'activesyncdisabled': activeSyncDisabled,
              'webOfflineSyncDays': webOfflineSyncDays,
              'perm': perm,
              'recursive': recursive,
              'rest': restUrl,
              'deletable': deletable,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'acl': {
                'internalGrantExpiry': internalGrantExpiry,
                'guestGrantExpiry': guestGrantExpiry,
                'grant': [
                  {
                    'perm': perm,
                    'gt': GrantGranteeType.all.name,
                    'zid': granteeId,
                    'expiry': expiry,
                    'd': granteeName,
                    'pw': guestPassword,
                    'key': accessKey,
                  }
                ],
              },
              'folder': [
                {
                  'id': id,
                  'uuid': uuid,
                  'name': name,
                }
              ],
              'link': [
                {
                  'id': id,
                  'name': name,
                  'owner': ownerEmail,
                  'zid': ownerAccountId,
                  'rid': remoteFolderId,
                  'ruuid': remoteUuid,
                  'oname': remoteFolderName,
                  'reminder': reminderEnabled,
                  'broken': broken,
                }
              ],
              'search': [
                {
                  'id': id,
                  'name': name,
                  'query': query,
                  'sortBy': SearchSortBy.none.name,
                  'types': types,
                }
              ],
              'retentionPolicy': [
                {
                  'keep': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                  'purge': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                }
              ],
            },
            'link': {
              'id': id,
              'name': name,
              'owner': ownerEmail,
              'zid': ownerAccountId,
              'rid': remoteFolderId,
              'ruuid': remoteUuid,
              'oname': remoteFolderName,
              'reminder': reminderEnabled,
              'broken': broken,
            },
            'search': {
              'id': id,
              'name': name,
              'query': query,
              'sortBy': SearchSortBy.none.name,
              'types': types,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createFolder(NewFolderSpec(name));

      final folder = response!.folder!;
      expect(folder.id, id);
      expect(folder.uuid, uuid);
      expect(folder.name, name);
      expect(folder.absoluteFolderPath, absoluteFolderPath);
      expect(folder.parentId, parentId);
      expect(folder.folderUuid, folderUuid);
      expect(folder.flags, flags);
      expect(folder.color, color);
      expect(folder.rgb, rgb);
      expect(folder.unreadCount, unreadCount);
      expect(folder.imapUnreadCount, imapUnreadCount);
      expect(folder.view, ViewType.conversation);
      expect(folder.revision, revision);
      expect(folder.modifiedSequence, modifiedSequence);
      expect(folder.changeDate, changeDate);
      expect(folder.itemCount, itemCount);
      expect(folder.imapItemCount, imapItemCount);
      expect(folder.totalSize, totalSize);
      expect(folder.imapModifiedSequence, imapModifiedSequence);
      expect(folder.imapUidNext, imapUidNext);
      expect(folder.url, url);
      expect(folder.activeSyncDisabled, activeSyncDisabled);
      expect(folder.webOfflineSyncDays, webOfflineSyncDays);
      expect(folder.perm, perm);
      expect(folder.recursive, recursive);
      expect(folder.restUrl, restUrl);
      expect(folder.deletable, deletable);

      final meta = folder.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final acl = folder.acl!;
      expect(acl.internalGrantExpiry, internalGrantExpiry);
      expect(acl.guestGrantExpiry, guestGrantExpiry);

      final grant = acl.grants.first;
      expect(grant.perm, perm);
      expect(grant.granteeType, GrantGranteeType.all);
      expect(grant.granteeId, granteeId);
      expect(grant.expiry, expiry);
      expect(grant.granteeName, granteeName);
      expect(grant.guestPassword, guestPassword);
      expect(grant.accessKey, accessKey);

      final subFolder = folder.subFolders.first;
      expect(subFolder.id, id);
      expect(subFolder.uuid, uuid);
      expect(subFolder.name, name);
      expect(subFolder, isA<Folder>());

      final link = folder.mountpoints.first;
      expect(link.id, id);
      expect(link.name, name);
      expect(link.ownerEmail, ownerEmail);
      expect(link.ownerAccountId, ownerAccountId);
      expect(link.remoteFolderId, remoteFolderId);
      expect(link.remoteUuid, remoteUuid);
      expect(link.remoteFolderName, remoteFolderName);
      expect(link.reminderEnabled, reminderEnabled);
      expect(link.broken, broken);
      expect(link, isA<Folder>());

      final search = folder.searchFolders.first;
      expect(search.id, id);
      expect(search.name, name);
      expect(search.query, query);
      expect(search.sortBy, SearchSortBy.none);
      expect(search.types, types);
      expect(search, isA<Folder>());

      final retentionPolicy = folder.retentionPolicy!;
      final keep = retentionPolicy.keep.first;
      final purge = retentionPolicy.purge.first;
      expect(keep.type, PolicyType.user);
      expect(keep.id, id);
      expect(keep.name, name);
      expect(keep.lifetime, lifetime);
      expect(purge.type, PolicyType.user);
      expect(purge.id, id);
      expect(purge.name, name);
      expect(purge.lifetime, lifetime);

      final mountpoint = response.mountpoint!;
      expect(mountpoint.id, id);
      expect(mountpoint.name, name);
      expect(mountpoint.ownerEmail, ownerEmail);
      expect(mountpoint.ownerAccountId, ownerAccountId);
      expect(mountpoint.remoteFolderId, remoteFolderId);
      expect(mountpoint.remoteUuid, remoteUuid);
      expect(mountpoint.remoteFolderName, remoteFolderName);
      expect(mountpoint.reminderEnabled, reminderEnabled);
      expect(mountpoint.broken, broken);
      expect(mountpoint, isA<Folder>());

      final searchFolder = response.searchFolder!;
      expect(searchFolder.id, id);
      expect(searchFolder.name, name);
      expect(searchFolder.query, query);
      expect(searchFolder.sortBy, SearchSortBy.none);
      expect(searchFolder.types, types);
      expect(searchFolder, isA<Folder>());
    }));

    test('Create mountpoint test', (() async {
      final id = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final absoluteFolderPath = faker.lorem.word();
      final parentId = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unreadCount = faker.randomGenerator.integer(100);
      final imapUnreadCount = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().minute;
      final itemCount = faker.randomGenerator.integer(100);
      final imapItemCount = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final imapModifiedSequence = faker.randomGenerator.integer(100);
      final imapUidNext = faker.randomGenerator.integer(100);
      final url = faker.internet.httpsUrl();
      final activeSyncDisabled = faker.randomGenerator.boolean();
      final webOfflineSyncDays = faker.randomGenerator.integer(100);
      final perm = faker.lorem.word();
      final recursive = faker.randomGenerator.boolean();
      final restUrl = faker.internet.httpsUrl();
      final deletable = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final lifetime = faker.randomGenerator.integer(100).toString();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);

      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();

      final ownerEmail = faker.internet.email();
      final ownerAccountId = faker.guid.guid();
      final remoteFolderId = faker.randomGenerator.integer(100);
      final remoteUuid = faker.guid.guid();
      final remoteFolderName = faker.lorem.word();
      final reminderEnabled = faker.randomGenerator.boolean();
      final broken = faker.randomGenerator.boolean();

      final query = faker.lorem.word();
      final types = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'CreateMountpointResponse': {
            '_jsns': 'urn:zimbraMail',
            'link': {
              'id': id,
              'uuid': uuid,
              'name': name,
              'owner': ownerEmail,
              'zid': ownerAccountId,
              'rid': remoteFolderId,
              'ruuid': remoteUuid,
              'oname': remoteFolderName,
              'reminder': reminderEnabled,
              'broken': broken,
              'absFolderPath': absoluteFolderPath,
              'l': parentId,
              'luuid': folderUuid,
              'f': flags,
              'color': color,
              'rgb': rgb,
              'u': unreadCount,
              'i4u': imapUnreadCount,
              'view': ViewType.conversation.name,
              'rev': revision,
              'ms': modifiedSequence,
              'md': changeDate,
              'n': itemCount,
              'i4n': imapItemCount,
              's': totalSize,
              'i4ms': imapModifiedSequence,
              'i4next': imapUidNext,
              'url': url,
              'activesyncdisabled': activeSyncDisabled,
              'webOfflineSyncDays': webOfflineSyncDays,
              'perm': perm,
              'recursive': recursive,
              'rest': restUrl,
              'deletable': deletable,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'acl': {
                'internalGrantExpiry': internalGrantExpiry,
                'guestGrantExpiry': guestGrantExpiry,
                'grant': [
                  {
                    'perm': perm,
                    'gt': GrantGranteeType.all.name,
                    'zid': granteeId,
                    'expiry': expiry,
                    'd': granteeName,
                    'pw': guestPassword,
                    'key': accessKey,
                  }
                ],
              },
              'folder': [
                {
                  'id': id,
                  'uuid': uuid,
                  'name': name,
                }
              ],
              'link': [
                {
                  'id': id,
                  'name': name,
                  'owner': ownerEmail,
                  'zid': ownerAccountId,
                  'rid': remoteFolderId,
                  'ruuid': remoteUuid,
                  'oname': remoteFolderName,
                  'reminder': reminderEnabled,
                  'broken': broken,
                }
              ],
              'search': [
                {
                  'id': id,
                  'name': name,
                  'query': query,
                  'sortBy': SearchSortBy.none.name,
                  'types': types,
                }
              ],
              'retentionPolicy': [
                {
                  'keep': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                  'purge': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                }
              ],
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createMountpoint(NewMountpointSpec(name));

      final mountpoint = response!.mountpoint!;
      expect(mountpoint.id, id);
      expect(mountpoint.uuid, uuid);
      expect(mountpoint.name, name);
      expect(mountpoint.ownerEmail, ownerEmail);
      expect(mountpoint.ownerAccountId, ownerAccountId);
      expect(mountpoint.remoteFolderId, remoteFolderId);
      expect(mountpoint.remoteUuid, remoteUuid);
      expect(mountpoint.remoteFolderName, remoteFolderName);
      expect(mountpoint.reminderEnabled, reminderEnabled);
      expect(mountpoint.broken, broken);
      expect(mountpoint.absoluteFolderPath, absoluteFolderPath);
      expect(mountpoint.parentId, parentId);
      expect(mountpoint.folderUuid, folderUuid);
      expect(mountpoint.flags, flags);
      expect(mountpoint.color, color);
      expect(mountpoint.rgb, rgb);
      expect(mountpoint.unreadCount, unreadCount);
      expect(mountpoint.imapUnreadCount, imapUnreadCount);
      expect(mountpoint.view, ViewType.conversation);
      expect(mountpoint.revision, revision);
      expect(mountpoint.modifiedSequence, modifiedSequence);
      expect(mountpoint.changeDate, changeDate);
      expect(mountpoint.itemCount, itemCount);
      expect(mountpoint.imapItemCount, imapItemCount);
      expect(mountpoint.totalSize, totalSize);
      expect(mountpoint.imapModifiedSequence, imapModifiedSequence);
      expect(mountpoint.imapUidNext, imapUidNext);
      expect(mountpoint.url, url);
      expect(mountpoint.activeSyncDisabled, activeSyncDisabled);
      expect(mountpoint.webOfflineSyncDays, webOfflineSyncDays);
      expect(mountpoint.perm, perm);
      expect(mountpoint.recursive, recursive);
      expect(mountpoint.restUrl, restUrl);
      expect(mountpoint.deletable, deletable);

      final meta = mountpoint.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final acl = mountpoint.acl!;
      expect(acl.internalGrantExpiry, internalGrantExpiry);
      expect(acl.guestGrantExpiry, guestGrantExpiry);

      final grant = acl.grants.first;
      expect(grant.perm, perm);
      expect(grant.granteeType, GrantGranteeType.all);
      expect(grant.granteeId, granteeId);
      expect(grant.expiry, expiry);
      expect(grant.granteeName, granteeName);
      expect(grant.guestPassword, guestPassword);
      expect(grant.accessKey, accessKey);

      final subFolder = mountpoint.subFolders.first;
      expect(subFolder.id, id);
      expect(subFolder.uuid, uuid);
      expect(subFolder.name, name);
      expect(subFolder, isA<Folder>());

      final link = mountpoint.mountpoints.first;
      expect(link.id, id);
      expect(link.name, name);
      expect(link.ownerEmail, ownerEmail);
      expect(link.ownerAccountId, ownerAccountId);
      expect(link.remoteFolderId, remoteFolderId);
      expect(link.remoteUuid, remoteUuid);
      expect(link.remoteFolderName, remoteFolderName);
      expect(link.reminderEnabled, reminderEnabled);
      expect(link.broken, broken);
      expect(link, isA<Folder>());

      final search = mountpoint.searchFolders.first;
      expect(search.id, id);
      expect(search.name, name);
      expect(search.query, query);
      expect(search.sortBy, SearchSortBy.none);
      expect(search.types, types);
      expect(search, isA<Folder>());

      final retentionPolicy = mountpoint.retentionPolicy!;
      final keep = retentionPolicy.keep.first;
      final purge = retentionPolicy.purge.first;
      expect(keep.type, PolicyType.user);
      expect(keep.id, id);
      expect(keep.name, name);
      expect(keep.lifetime, lifetime);
      expect(purge.type, PolicyType.user);
      expect(purge.id, id);
      expect(purge.name, name);
      expect(purge.lifetime, lifetime);
    }));

    test('Create note test', (() async {
      final id = faker.guid.guid();
      final revision = faker.randomGenerator.integer(100);
      final folder = faker.guid.guid();
      final date = faker.date.dateTime().millisecond;
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final bounds = faker.lorem.word();
      final color = faker.randomGenerator.integer(100);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final changeDate = faker.date.dateTime().millisecond;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final content = faker.lorem.word();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final data = {
        'Body': {
          'CreateNoteResponse': {
            '_jsns': 'urn:zimbraMail',
            'note': {
              'id': id,
              'rev': revision,
              'l': folder,
              'd': date,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'pos': bounds,
              'color': color,
              'rgb': rgb,
              'md': changeDate,
              'ms': modifiedSequence,
              'content': content,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createNote(NewNoteSpec());
      final note = response!.note!;

      expect(note.id, id);
      expect(note.revision, revision);
      expect(note.folder, folder);
      expect(note.date, date);
      expect(note.flags, flags);
      expect(note.tags, tags);
      expect(note.tagNames, tagNames);
      expect(note.bounds, bounds);
      expect(note.color, color);
      expect(note.rgb, rgb);
      expect(note.changeDate, changeDate);
      expect(note.modifiedSequence, modifiedSequence);
      expect(note.content, content);

      final meta = note.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);
    }));

    test('Create search folder test', (() async {
      final id = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final absoluteFolderPath = faker.lorem.word();
      final parentId = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unreadCount = faker.randomGenerator.integer(100);
      final imapUnreadCount = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().minute;
      final itemCount = faker.randomGenerator.integer(100);
      final imapItemCount = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final imapModifiedSequence = faker.randomGenerator.integer(100);
      final imapUidNext = faker.randomGenerator.integer(100);
      final url = faker.internet.httpsUrl();
      final activeSyncDisabled = faker.randomGenerator.boolean();
      final webOfflineSyncDays = faker.randomGenerator.integer(100);
      final perm = faker.lorem.word();
      final recursive = faker.randomGenerator.boolean();
      final restUrl = faker.internet.httpsUrl();
      final deletable = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final lifetime = faker.randomGenerator.integer(100).toString();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);

      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();

      final ownerEmail = faker.internet.email();
      final ownerAccountId = faker.guid.guid();
      final remoteFolderId = faker.randomGenerator.integer(100);
      final remoteUuid = faker.guid.guid();
      final remoteFolderName = faker.lorem.word();
      final reminderEnabled = faker.randomGenerator.boolean();
      final broken = faker.randomGenerator.boolean();

      final query = faker.lorem.word();
      final types = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'CreateSearchFolderResponse': {
            '_jsns': 'urn:zimbraMail',
            'search': {
              'id': id,
              'uuid': uuid,
              'name': name,
              'query': query,
              'sortBy': SearchSortBy.none.name,
              'types': types,
              'absFolderPath': absoluteFolderPath,
              'l': parentId,
              'luuid': folderUuid,
              'f': flags,
              'color': color,
              'rgb': rgb,
              'u': unreadCount,
              'i4u': imapUnreadCount,
              'view': ViewType.conversation.name,
              'rev': revision,
              'ms': modifiedSequence,
              'md': changeDate,
              'n': itemCount,
              'i4n': imapItemCount,
              's': totalSize,
              'i4ms': imapModifiedSequence,
              'i4next': imapUidNext,
              'url': url,
              'activesyncdisabled': activeSyncDisabled,
              'webOfflineSyncDays': webOfflineSyncDays,
              'perm': perm,
              'recursive': recursive,
              'rest': restUrl,
              'deletable': deletable,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'acl': {
                'internalGrantExpiry': internalGrantExpiry,
                'guestGrantExpiry': guestGrantExpiry,
                'grant': [
                  {
                    'perm': perm,
                    'gt': GrantGranteeType.all.name,
                    'zid': granteeId,
                    'expiry': expiry,
                    'd': granteeName,
                    'pw': guestPassword,
                    'key': accessKey,
                  }
                ],
              },
              'folder': [
                {
                  'id': id,
                  'uuid': uuid,
                  'name': name,
                }
              ],
              'link': [
                {
                  'id': id,
                  'name': name,
                  'owner': ownerEmail,
                  'zid': ownerAccountId,
                  'rid': remoteFolderId,
                  'ruuid': remoteUuid,
                  'oname': remoteFolderName,
                  'reminder': reminderEnabled,
                  'broken': broken,
                }
              ],
              'search': [
                {
                  'id': id,
                  'name': name,
                  'query': query,
                  'sortBy': SearchSortBy.none.name,
                  'types': types,
                }
              ],
              'retentionPolicy': [
                {
                  'keep': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                  'purge': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                }
              ],
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createSearchFolder(NewSearchFolderSpec(name, query));
      final searchFolder = response!.searchFolder!;

      expect(searchFolder.id, id);
      expect(searchFolder.uuid, uuid);
      expect(searchFolder.name, name);
      expect(searchFolder.query, query);
      expect(searchFolder.sortBy, SearchSortBy.none);
      expect(searchFolder.types, types);
      expect(searchFolder.absoluteFolderPath, absoluteFolderPath);
      expect(searchFolder.parentId, parentId);
      expect(searchFolder.folderUuid, folderUuid);
      expect(searchFolder.flags, flags);
      expect(searchFolder.color, color);
      expect(searchFolder.rgb, rgb);
      expect(searchFolder.unreadCount, unreadCount);
      expect(searchFolder.imapUnreadCount, imapUnreadCount);
      expect(searchFolder.view, ViewType.conversation);
      expect(searchFolder.revision, revision);
      expect(searchFolder.modifiedSequence, modifiedSequence);
      expect(searchFolder.changeDate, changeDate);
      expect(searchFolder.itemCount, itemCount);
      expect(searchFolder.imapItemCount, imapItemCount);
      expect(searchFolder.totalSize, totalSize);
      expect(searchFolder.imapModifiedSequence, imapModifiedSequence);
      expect(searchFolder.imapUidNext, imapUidNext);
      expect(searchFolder.url, url);
      expect(searchFolder.activeSyncDisabled, activeSyncDisabled);
      expect(searchFolder.webOfflineSyncDays, webOfflineSyncDays);
      expect(searchFolder.perm, perm);
      expect(searchFolder.recursive, recursive);
      expect(searchFolder.restUrl, restUrl);
      expect(searchFolder.deletable, deletable);

      final meta = searchFolder.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final acl = searchFolder.acl!;
      expect(acl.internalGrantExpiry, internalGrantExpiry);
      expect(acl.guestGrantExpiry, guestGrantExpiry);

      final grant = acl.grants.first;
      expect(grant.perm, perm);
      expect(grant.granteeType, GrantGranteeType.all);
      expect(grant.granteeId, granteeId);
      expect(grant.expiry, expiry);
      expect(grant.granteeName, granteeName);
      expect(grant.guestPassword, guestPassword);
      expect(grant.accessKey, accessKey);

      final subFolder = searchFolder.subFolders.first;
      expect(subFolder.id, id);
      expect(subFolder.uuid, uuid);
      expect(subFolder.name, name);
      expect(subFolder, isA<Folder>());

      final link = searchFolder.mountpoints.first;
      expect(link.id, id);
      expect(link.name, name);
      expect(link.ownerEmail, ownerEmail);
      expect(link.ownerAccountId, ownerAccountId);
      expect(link.remoteFolderId, remoteFolderId);
      expect(link.remoteUuid, remoteUuid);
      expect(link.remoteFolderName, remoteFolderName);
      expect(link.reminderEnabled, reminderEnabled);
      expect(link.broken, broken);
      expect(link, isA<Folder>());

      final search = searchFolder.searchFolders.first;
      expect(search.id, id);
      expect(search.name, name);
      expect(search.query, query);
      expect(search.sortBy, SearchSortBy.none);
      expect(search.types, types);
      expect(search, isA<Folder>());

      final retentionPolicy = searchFolder.retentionPolicy!;
      final keep = retentionPolicy.keep.first;
      final purge = retentionPolicy.purge.first;
      expect(keep.type, PolicyType.user);
      expect(keep.id, id);
      expect(keep.name, name);
      expect(keep.lifetime, lifetime);
      expect(purge.type, PolicyType.user);
      expect(purge.id, id);
      expect(purge.name, name);
      expect(purge.lifetime, lifetime);
    }));

    test('Create tag test', (() async {
      final id = faker.guid.guid();
      final name = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unread = faker.randomGenerator.integer(100);
      final count = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final lifetime = faker.randomGenerator.integer(100).toString();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final data = {
        'Body': {
          'CreateTagResponse': {
            '_jsns': 'urn:zimbraMail',
            'tag': {
              'id': id,
              'name': name,
              'color': color,
              'rgb': rgb,
              'u': unread,
              'n': count,
              'd': date,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'retentionPolicy': [
                {
                  'keep': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                  'purge': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                }
              ],
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createTag(TagSpec(name));
      final tag = response!.tag!;

      expect(tag.id, id);
      expect(tag.name, name);
      expect(tag.color, color);
      expect(tag.rgb, rgb);
      expect(tag.unread, unread);
      expect(tag.count, count);
      expect(tag.date, date);
      expect(tag.revision, revision);
      expect(tag.changeDate, changeDate);
      expect(tag.modifiedSequence, modifiedSequence);

      final meta = tag.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final retentionPolicy = tag.retentionPolicy!;
      final keep = retentionPolicy.keep.first;
      final purge = retentionPolicy.purge.first;
      expect(keep.type, PolicyType.user);
      expect(keep.id, id);
      expect(keep.name, name);
      expect(keep.lifetime, lifetime);
      expect(purge.type, PolicyType.user);
      expect(purge.id, id);
      expect(purge.name, name);
      expect(purge.lifetime, lifetime);
    }));

    test('Create task exception test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final calInvId = faker.guid.guid();
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final revision = faker.randomGenerator.integer(100);

      final part = faker.lorem.word();
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.person.name();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final seq = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final content = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();
      final size = faker.randomGenerator.integer(100);
      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final section = faker.lorem.word();

      final data = {
        'Body': {
          'CreateTaskExceptionResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'apptId': deprecatedApptId,
            'invId': calInvId,
            'ms': modifiedSequence,
            'rev': revision,
            'm': {'id': id},
            'echo': {
              'm': {
                'id': id,
                'part': part,
                'sd': sentDate,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'mid': messageIdHeader,
                'inv': {
                  'type': InviteType.appt.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                  },
                  'comp': [
                    {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    }
                  ],
                },
                '_attrs': {
                  key: value,
                },
                'mp': [
                  {
                    'part': part,
                    'ct': contentType,
                    's': size,
                    'cd': contentDisposition,
                    'filename': contentFilename,
                    'ci': contentId,
                    'cl': location,
                    'body': body,
                    'truncated': truncatedContent,
                    'content': content,
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'shr': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'dlSubs': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createTaskException();

      expect(response!.calItemId, calItemId);
      expect(response.deprecatedApptId, deprecatedApptId);
      expect(response.calInvId, calInvId);
      expect(response.modifiedSequence, modifiedSequence);
      expect(response.msg!.id, id);

      final echo = response.echo!;
      final invite = echo.invite!;

      expect(invite.id, id);
      expect(invite.part, part);
      expect(invite.sentDate, sentDate);
      expect(invite.subject, subject);
      expect(invite.messageIdHeader, messageIdHeader);
      expect(invite.size, size);
      expect(invite.date, date);
      expect(invite.folder, folder);
      expect(invite.conversationId, conversationId);
      expect(invite.flags, flags);
      expect(invite.tags, tags);
      expect(invite.tagNames, tagNames);
      expect(invite.revision, revision);
      expect(invite.changeDate, changeDate);
      expect(invite.modifiedSequence, modifiedSequence);

      final email = invite.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final header = invite.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final mpContent = invite.mpContentElems.first;
      expect(mpContent.part, part);
      expect(mpContent.contentType, contentType);
      expect(mpContent.size, size);
      expect(mpContent.contentDisposition, contentDisposition);
      expect(mpContent.contentFilename, contentFilename);
      expect(mpContent.contentId, contentId);
      expect(mpContent.location, location);
      expect(mpContent.body, body);
      expect(mpContent.truncatedContent, truncatedContent);
      expect(mpContent.content, content);

      final mimePart = mpContent.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = invite.shrContentElems.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = invite.dlSubsContentElems.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final inv = invite.invite!;
      expect(inv.calItemType, InviteType.appt);

      final tz = inv.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = inv.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = inv.inviteComponents.first;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Create task test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final calInvId = faker.guid.guid();
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final revision = faker.randomGenerator.integer(100);

      final part = faker.lorem.word();
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.person.name();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final seq = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final content = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();
      final size = faker.randomGenerator.integer(100);
      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final section = faker.lorem.word();

      final data = {
        'Body': {
          'CreateTaskResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'apptId': deprecatedApptId,
            'invId': calInvId,
            'ms': modifiedSequence,
            'rev': revision,
            'm': {'id': id},
            'echo': {
              'm': {
                'id': id,
                'part': part,
                'sd': sentDate,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'mid': messageIdHeader,
                'inv': {
                  'type': InviteType.appt.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                  },
                  'comp': [
                    {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    }
                  ],
                },
                '_attrs': {
                  key: value,
                },
                'mp': [
                  {
                    'part': part,
                    'ct': contentType,
                    's': size,
                    'cd': contentDisposition,
                    'filename': contentFilename,
                    'ci': contentId,
                    'cl': location,
                    'body': body,
                    'truncated': truncatedContent,
                    'content': content,
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'shr': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'dlSubs': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createTask();

      expect(response!.calItemId, calItemId);
      expect(response.deprecatedApptId, deprecatedApptId);
      expect(response.calInvId, calInvId);
      expect(response.modifiedSequence, modifiedSequence);
      expect(response.msg!.id, id);

      final echo = response.echo!;
      final invite = echo.invite!;

      expect(invite.id, id);
      expect(invite.part, part);
      expect(invite.sentDate, sentDate);
      expect(invite.subject, subject);
      expect(invite.messageIdHeader, messageIdHeader);
      expect(invite.size, size);
      expect(invite.date, date);
      expect(invite.folder, folder);
      expect(invite.conversationId, conversationId);
      expect(invite.flags, flags);
      expect(invite.tags, tags);
      expect(invite.tagNames, tagNames);
      expect(invite.revision, revision);
      expect(invite.changeDate, changeDate);
      expect(invite.modifiedSequence, modifiedSequence);

      final email = invite.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final header = invite.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final mpContent = invite.mpContentElems.first;
      expect(mpContent.part, part);
      expect(mpContent.contentType, contentType);
      expect(mpContent.size, size);
      expect(mpContent.contentDisposition, contentDisposition);
      expect(mpContent.contentFilename, contentFilename);
      expect(mpContent.contentId, contentId);
      expect(mpContent.location, location);
      expect(mpContent.body, body);
      expect(mpContent.truncatedContent, truncatedContent);
      expect(mpContent.content, content);

      final mimePart = mpContent.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = invite.shrContentElems.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = invite.dlSubsContentElems.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final inv = invite.invite!;
      expect(inv.calItemType, InviteType.appt);

      final tz = inv.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = inv.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = inv.inviteComponents.first;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Create WaitSet test', (() async {
      final waitSetId = faker.guid.guid();
      final defaultInterests = faker.randomGenerator
          .amount((_) => random.element(InterestType.values).name, InterestType.values.length)
          .toSet()
          .join(',');
      final sequence = faker.randomGenerator.integer(100);
      final id = faker.guid.guid();
      final type = faker.lorem.word();

      final data = {
        'Body': {
          'CreateWaitSetResponse': {
            '_jsns': 'urn:zimbraMail',
            'waitSet': waitSetId,
            'defTypes': defaultInterests,
            'seq': sequence,
            'error': [
              {
                'id': id,
                'type': type,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.createWaitSet();

      expect(response!.waitSetId, waitSetId);
      expect(response.defaultInterests, defaultInterests);
      expect(response.sequence, sequence);

      final error = response.errors.first;
      expect(error.id, id);
      expect(error.type, type);
    }));

    test('Decline counter appointment test', (() async {
      final data = {
        'Body': {
          'DeclineCounterAppointmentResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.declineCounterAppointment();
      expect(response, isNotNull);
      expect(response, isA<DeclineCounterAppointmentResponse>());
    }));

    test('Delete data source test', (() async {
      final data = {
        'Body': {
          'DeleteDataSourceResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.deleteDataSource();
      expect(response, isNotNull);
      expect(response, isA<DeleteDataSourceResponse>());
    }));

    test('Destroy WaitSet test', (() async {
      final waitSetId = faker.guid.guid();
      final data = {
        'Body': {
          'DestroyWaitSetResponse': {
            '_jsns': 'urn:zimbraMail',
            'waitSet': waitSetId,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.destroyWaitSet(waitSetId);
      expect(response!.waitSetId, waitSetId);
    }));

    test('Diff document test', (() async {
      final disposition = faker.lorem.word();
      final text = faker.lorem.word();

      final data = {
        'Body': {
          'DiffDocumentResponse': {
            '_jsns': 'urn:zimbraMail',
            'chunk': [
              {
                'disp': disposition,
                '_content': text,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.diffDocument(DiffDocumentVersionSpec(faker.guid.guid()));
      final chunk = response!.chunks.first;

      expect(chunk.disposition, disposition);
      expect(chunk.text, text);
    }));

    test('Dismiss calendar item alarm test', (() async {
      final calItemId = faker.guid.guid();
      final nextAlarm = faker.randomGenerator.integer(100);
      final alarmInstanceStart = faker.randomGenerator.integer(100);
      final invId = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);
      final name = faker.lorem.word();
      final value = faker.lorem.word();
      final location = faker.lorem.word();

      final address = faker.internet.email();
      final url = faker.internet.httpsUrl();
      final displayName = faker.person.name();
      final sentBy = faker.internet.email();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final dateString = faker.date.dateTime().toString();
      final description = faker.lorem.word();
      final summary = faker.lorem.word();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final uri = faker.internet.uri('http');
      final contentType = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final data = {
        'Body': {
          'DismissCalendarItemAlarmResponse': {
            '_jsns': 'urn:zimbraMail',
            'appt': [
              {
                'calItemId': calItemId,
                'alarmData': {
                  'nextAlarm': nextAlarm,
                  'alarmInstStart': alarmInstanceStart,
                  'invId': invId,
                  'compNum': componentNum,
                  'name': name,
                  'loc': location,
                  'alarm': {
                    'action': AlarmAction.display.name,
                    'trigger': {
                      'abs': {
                        'd': dateString,
                      },
                      'rel': {
                        'd': dateString,
                      },
                    },
                    'repeat': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'desc': {'_content': description},
                    'attach': {
                      'uri': uri,
                      'ct': contentType,
                      '_content': binaryB64Data,
                    },
                    'summary': {'_content': summary},
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': ParticipationStatus.accept.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                },
              }
            ],
            'task': [
              {
                'calItemId': calItemId,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.dismissCalendarItemAlarm();

      final appt = response!.apptUpdatedAlarms.first;
      expect(appt.calItemId, calItemId);

      final alarmData = appt.alarmData!;
      expect(alarmData.nextAlarm, nextAlarm);
      expect(alarmData.alarmInstanceStart, alarmInstanceStart);
      expect(alarmData.invId, invId);
      expect(alarmData.componentNum, componentNum);
      expect(alarmData.name, name);
      expect(alarmData.location, location);

      final alarm = alarmData.alarm!;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);

      final trigger = alarm.trigger!;
      final absolute = trigger.absolute!;
      final relative = trigger.relative!;
      expect(absolute.date, dateString);
      expect(relative.date, dateString);

      final repeat = alarm.repeat!;
      expect(repeat.durationNegative, durationNegative);
      expect(repeat.weeks, weeks);
      expect(repeat.days, days);
      expect(repeat.hours, hours);
      expect(repeat.minutes, minutes);
      expect(repeat.seconds, seconds);
      expect(repeat.related, AlarmRelated.start);
      expect(repeat.repeatCount, repeatCount);

      final attach = alarm.attach!;
      expect(attach.uri, uri);
      expect(attach.contentType, contentType);
      expect(attach.binaryB64Data, binaryB64Data);

      final attendee = alarm.attendees.first;
      expect(attendee.address, address);
      expect(attendee.url, url);
      expect(attendee.displayName, displayName);
      expect(attendee.sentBy, sentBy);
      expect(attendee.dir, dir);
      expect(attendee.language, language);
      expect(attendee.cuType, cuType);
      expect(attendee.role, role);
      expect(attendee.partStat, ParticipationStatus.accept);
      expect(attendee.rsvp, rsvp);
      expect(attendee.member, member);
      expect(attendee.delegatedTo, delegatedTo);
      expect(attendee.delegatedFrom, delegatedFrom);
      expect(attendee.xParams.first.name, name);
      expect(attendee.xParams.first.value, value);

      final xprop = alarm.xProps.first;
      expect(xprop.name, name);
      expect(xprop.value, value);
      expect(xprop.xParams.first.name, name);
      expect(xprop.xParams.first.value, value);

      final task = response.taskUpdatedAlarms.first;
      expect(task.calItemId, calItemId);
      expect(task, isA<UpdatedAlarmInfo>());
    }));

    test('Empty dumpster test', (() async {
      final data = {
        'Body': {
          'EmptyDumpsterResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.emptyDumpster();
      expect(response, isNotNull);
      expect(response, isA<EmptyDumpsterResponse>());
    }));

    test('Enable shared reminder test', (() async {
      final data = {
        'Body': {
          'EnableSharedReminderResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.enableSharedReminder(SharedReminderMount(faker.guid.guid()));
      expect(response, isNotNull);
      expect(response, isA<EnableSharedReminderResponse>());
    }));

    test('Expand recurrences test', (() async {
      final startTime = faker.date.dateTime().millisecondsSinceEpoch;
      final endTime = faker.date.dateTime().millisecondsSinceEpoch;
      final duration = faker.randomGenerator.integer(100);
      final allDay = faker.randomGenerator.boolean();
      final tzOffset = faker.randomGenerator.integer(100);
      final recurIdZ = faker.date.dateTime().toString();

      final data = {
        'Body': {
          'ExpandRecurResponse': {
            '_jsns': 'urn:zimbraMail',
            'inst': [
              {
                's': startTime,
                'dur': duration,
                'allDay': allDay,
                'tzo': tzOffset,
                'ridZ': recurIdZ,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.expandRecur(startTime, endTime);
      final inst = response!.instances.first;

      expect(inst.startTime, startTime);
      expect(inst.duration, duration);
      expect(inst.allDay, allDay);
      expect(inst.tzOffset, tzOffset);
      expect(inst.recurIdZ, recurIdZ);
    }));

    test('Export contacts test', (() async {
      final content = faker.lorem.word();
      final data = {
        'Body': {
          'ExportContactsResponse': {
            '_jsns': 'urn:zimbraMail',
            'content': {'_content': content},
          }
        }
      };
      final api = mockApi(data);
      final response = await api.exportContacts(faker.lorem.word());
      expect(response!.content, content);
    }));

    test('Folder action test', (() async {
      final id = faker.guid.guid();
      final operation = faker.randomGenerator.element(FolderAction.values).name;
      final nonExistentIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');
      final newlyCreatedIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');
      final zimbraId = faker.guid.guid();
      final displayName = faker.person.name();
      final accessKey = faker.internet.password();

      final data = {
        'Body': {
          'FolderActionResponse': {
            '_jsns': 'urn:zimbraMail',
            'action': {
              'id': id,
              'op': operation,
              'nei': nonExistentIds,
              'nci': newlyCreatedIds,
              'zid': zimbraId,
              'd': displayName,
              'key': accessKey,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.folderAction(FolderActionSelector(id, operation));
      final action = response!.action!;

      expect(action.id, id);
      expect(action.operation, operation);
      expect(action.nonExistentIds, nonExistentIds);
      expect(action.newlyCreatedIds, newlyCreatedIds);
      expect(action.zimbraId, zimbraId);
      expect(action.displayName, displayName);
      expect(action.accessKey, accessKey);
    }));

    test('Forward appointment invite test', (() async {
      final data = {
        'Body': {
          'ForwardAppointmentInviteResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.forwardAppointmentInvite();
      expect(response, isNotNull);
      expect(response, isA<ForwardAppointmentInviteResponse>());
    }));

    test('Forward appointment test', (() async {
      final data = {
        'Body': {
          'ForwardAppointmentResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.forwardAppointment();
      expect(response, isNotNull);
      expect(response, isA<ForwardAppointmentResponse>());
    }));

    test('Generate UUID test', (() async {
      final uuid = faker.guid.guid();
      final data = {
        'Body': {
          'GenerateUUIDResponse': {
            '_jsns': 'urn:zimbraMail',
            '_content': uuid,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.generateUUID();
      expect(response!.uuid, uuid);
    }));

    test('Get appointment test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final section = faker.lorem.word();

      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final revision = faker.randomGenerator.integer(100);
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final nextAlarm = faker.date.dateTime().millisecondsSinceEpoch;
      final orphan = faker.randomGenerator.boolean();

      final sequence = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);
      final recurrenceId = faker.date.dateTime().toString();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final address = faker.internet.email();
      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final contentType = faker.lorem.word();
      final content = faker.lorem.word();
      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final part = faker.lorem.word();
      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GetAppointmentResponse': {
            '_jsns': 'urn:zimbraMail',
            'appt': {
              'f': flags,
              't': tags,
              'tn': tagNames,
              'uid': uid,
              'id': id,
              'rev': revision,
              's': size,
              'd': date,
              'l': folder,
              'md': changeDate,
              'ms': modifiedSequence,
              'nextAlarm': nextAlarm,
              'orphan': orphan,
              'inv': [
                {
                  'type': InviteType.appt.name,
                  'seq': sequence,
                  'id': id,
                  'compNum': componentNum,
                  'recurId': recurrenceId,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'comp': {
                    'category': [
                      {'_content': category}
                    ],
                    'comment': [
                      {'_content': comment}
                    ],
                    'contact': [
                      {'_content': contact}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'alarm': [
                      {
                        'action': AlarmAction.display.name,
                        'trigger': {
                          'abs': {
                            'd': dateTimeString,
                          },
                          'rel': {
                            'd': dateTimeString,
                          },
                        },
                        'repeat': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': AlarmRelated.start.name,
                          'count': repeatCount,
                        },
                        'desc': {'_content': description},
                        'attach': {
                          'uri': uri,
                          'ct': contentType,
                          '_content': binaryB64Data,
                        },
                        'summary': {'_content': summary},
                        'at': [
                          {
                            'a': address,
                            'url': url,
                            'd': displayName,
                            'sentBy': sentBy,
                            'dir': dir,
                            'lang': language,
                            'cutype': cuType,
                            'role': role,
                            'ptst': partStat.name,
                            'rsvp': rsvp,
                            'member': member,
                            'delegatedTo': delegatedTo,
                            'delegatedFrom': delegatedFrom,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'xprop': [
                          {
                            'name': name,
                            'value': value,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'fr': fragment,
                    'desc': {'_content': description},
                    'descHtml': {'_content': htmlDescription},
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'recur': {
                      'add': [
                        {'add': {}}
                      ],
                      'exclude': [
                        {'exclude': {}}
                      ],
                      'except': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                          'add': {'add': []},
                          'exclude': {'exclude': []},
                        }
                      ],
                      'cancel': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ],
                      'dates': [
                        {
                          'tz': timezone,
                          'dtval': [
                            {
                              's': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'e': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'dur': {
                                'neg': durationNegative,
                                'w': weeks,
                                'd': days,
                                'h': hours,
                                'm': minutes,
                                's': seconds,
                                'related': AlarmRelated.start.name,
                                'count': repeatCount,
                              },
                            }
                          ],
                        }
                      ],
                      'rule': [
                        {
                          'freq': Frequency.second.name,
                          'until': {
                            'd': dateTimeString,
                          },
                          'count': {
                            'num': num,
                          },
                          'interval': {
                            'ival': ival,
                          },
                          'bysecond': {
                            'seclist': list,
                          },
                          'byminute': {
                            'minlist': list,
                          },
                          'byhour': {
                            'hrlist': list,
                          },
                          'byday': {
                            'wkday': [
                              {
                                'day': WeekDay.sunday.name,
                                'ordWk': ordWk,
                              }
                            ],
                          },
                          'bymonthday': {
                            'modaylist': list,
                          },
                          'byyearday': {
                            'yrdaylist': list,
                          },
                          'byweekno': {
                            'wklist': list,
                          },
                          'bymonth': {
                            'molist': list,
                          },
                          'bysetpos': {
                            'poslist': list,
                          },
                          'wkst': {
                            'day': WeekDay.sunday.name,
                          },
                          'rule-x-name': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    },
                    'exceptId': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'rangeType': recurrenceRangeType,
                    },
                    's': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'e': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'dur': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'method': method,
                    'compNum': componentNum,
                    'rsvp': rsvp,
                    'priority': priority,
                    'name': name,
                    'loc': location,
                    'percentComplete': percentComplete,
                    'completed': completed,
                    'noBlob': noBlob,
                    'fba': FreeBusyStatus.free.name,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'isOrg': isOrganizer,
                    'x_uid': xUid,
                    'uid': uid,
                    'seq': sequence,
                    'd': dateTime,
                    'calItemId': calItemId,
                    'apptId': deprecatedApptId,
                    'ciFolder': calItemFolder,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'url': url,
                    'ex': isException,
                    'ridZ': recurIdZ,
                    'allDay': isAllDay,
                    'draft': isDraft,
                    'neverSent': neverSent,
                    'changes': changes,
                  },
                  'mp': [
                    {
                      'part': part,
                      'ct': contentType,
                      's': size,
                      'cd': contentDisposition,
                      'filename': contentFilename,
                      'ci': contentId,
                      'cl': location,
                      'body': body,
                      'truncated': truncatedContent,
                      'content': content,
                      'mp': [
                        {
                          'part': part,
                          'ct': contentType,
                          's': size,
                          'cd': contentDisposition,
                          'filename': contentFilename,
                          'ci': contentId,
                          'cl': location,
                          'body': body,
                          'truncated': truncatedContent,
                          'content': content,
                        }
                      ],
                    }
                  ],
                  'shr': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                  'dlSubs': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                }
              ],
              'replies': {
                'reply': [
                  {
                    'rangeType': recurrenceRangeType,
                    'recurId': recurrenceId,
                    'seq': sequence,
                    'd': date,
                    'at': attendee,
                    'sentBy': sentBy,
                    'ptst': partStat.name,
                    'tz': timezone,
                    'ridZ': recurIdZ,
                  }
                ]
              },
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
            'task': {
              'f': flags,
              't': tags,
              'tn': tagNames,
              'uid': uid,
              'id': id,
              'rev': revision,
              's': size,
              'd': date,
              'l': folder,
              'md': changeDate,
              'ms': modifiedSequence,
              'nextAlarm': nextAlarm,
              'orphan': orphan,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getAppointment();
      final appt = response!.appt!;

      expect(appt.flags, flags);
      expect(appt.tags, tags);
      expect(appt.tagNames, tagNames);
      expect(appt.uid, uid);
      expect(appt.id, id);
      expect(appt.revision, revision);
      expect(appt.size, size);
      expect(appt.date, date);
      expect(appt.folder, folder);
      expect(appt.changeDate, changeDate);
      expect(appt.modifiedSequence, modifiedSequence);
      expect(appt.nextAlarm, nextAlarm);
      expect(appt.orphan, orphan);

      final inv = appt.invites.first;
      expect(inv.calItemType, InviteType.appt);
      expect(inv.sequence, sequence);
      expect(inv.id, id);
      expect(inv.componentNum, componentNum);
      expect(inv.recurrenceId, recurrenceId);

      final invTz = inv.timezones.first;
      expect(invTz.id, id);
      expect(invTz.tzStdOffset, tzStdOffset);
      expect(invTz.tzDayOffset, tzDayOffset);
      expect(invTz.standardTZName, standardTZName);
      expect(invTz.daylightTZName, daylightTZName);

      final invTzStandard = invTz.standardTzOnset!;
      expect(invTzStandard.month, month);
      expect(invTzStandard.hour, hour);
      expect(invTzStandard.minute, minute);
      expect(invTzStandard.second, second);
      expect(invTzStandard.dayOfMonth, dayOfMonth);
      expect(invTzStandard.week, week);
      expect(invTzStandard.dayOfWeek, dayOfWeek);

      final invTzDaylight = invTz.daylightTzOnset!;
      expect(invTzDaylight.month, month);
      expect(invTzDaylight.hour, hour);
      expect(invTzDaylight.minute, minute);
      expect(invTzDaylight.second, second);
      expect(invTzDaylight.dayOfMonth, dayOfMonth);
      expect(invTzDaylight.week, week);
      expect(invTzDaylight.dayOfWeek, dayOfWeek);

      final partInfo = inv.partInfos.first;
      expect(partInfo.part, part);
      expect(partInfo.contentType, contentType);
      expect(partInfo.size, size);
      expect(partInfo.contentDisposition, contentDisposition);
      expect(partInfo.contentFilename, contentFilename);
      expect(partInfo.contentId, contentId);
      expect(partInfo.location, location);
      expect(partInfo.body, body);
      expect(partInfo.truncatedContent, truncatedContent);
      expect(partInfo.content, content);
      expect(partInfo.body, body);
      final mpPartInfo = partInfo.mimeParts.first;
      expect(mpPartInfo.part, part);
      expect(mpPartInfo.contentType, contentType);
      expect(mpPartInfo.size, size);
      expect(mpPartInfo.contentDisposition, contentDisposition);
      expect(mpPartInfo.contentFilename, contentFilename);
      expect(mpPartInfo.contentId, contentId);
      expect(mpPartInfo.location, location);
      expect(mpPartInfo.body, body);
      expect(mpPartInfo.truncatedContent, truncatedContent);
      expect(mpPartInfo.content, content);
      expect(mpPartInfo.body, body);

      final shr = inv.shareNotifications.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = inv.dlSubsNotifications.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final comp = inv.inviteComponent!;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);

      final reply = appt.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, sequence);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final meta = appt.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final task = response.task!;
      expect(task, isA<TaskItemInfo>());
      expect(task, isA<CalendarItemInfo>());
      expect(task.flags, flags);
      expect(task.tags, tags);
      expect(task.tagNames, tagNames);
      expect(task.uid, uid);
      expect(task.id, id);
      expect(task.revision, revision);
      expect(task.size, size);
      expect(task.date, date);
      expect(task.folder, folder);
      expect(task.changeDate, changeDate);
      expect(task.modifiedSequence, modifiedSequence);
      expect(task.nextAlarm, nextAlarm);
      expect(task.orphan, orphan);
    }));

    test('Get appointment summaries test', (() async {
      final id = faker.guid.guid();
      final name = faker.lorem.word();
      final value = faker.lorem.word();
      final category = faker.lorem.word();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final summary = faker.lorem.word();

      final address = faker.internet.email();
      final url = faker.internet.httpsUrl();
      final displayName = faker.person.name();
      final sentBy = faker.internet.email();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();

      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final xUid = faker.guid.guid();
      final uid = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final folderId = faker.guid.guid();
      final size = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final duration = faker.randomGenerator.integer(100);
      final recurIdZ = faker.date.dateTime().toString();
      final tzOffset = faker.randomGenerator.integer(100);
      final taskPercentComplete = faker.lorem.word();
      final isRecurring = faker.randomGenerator.boolean();
      final hasExceptions = faker.randomGenerator.boolean();
      final isException = faker.randomGenerator.boolean();
      final priority = faker.lorem.word();
      final location = faker.lorem.word();
      final hasOtherAttendees = faker.randomGenerator.boolean();
      final hasAlarm = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final invId = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);
      final allDay = faker.randomGenerator.boolean();
      final draft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final taskDueDate = faker.randomGenerator.integer(100);
      final taskTzOffsetDue = faker.randomGenerator.integer(100);

      final nextAlarm = faker.date.dateTime().millisecondsSinceEpoch;
      final alarmInstanceStart = faker.date.dateTime().millisecondsSinceEpoch;
      final dateTimeString = faker.date.dateTime().toString();
      final startTime = faker.date.dateTime().millisecondsSinceEpoch;

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final uri = faker.internet.uri('http');
      final contentType = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final data = {
        'Body': {
          'GetApptSummariesResponse': {
            '_jsns': 'urn:zimbraMail',
            'appt': [
              {
                'or': {
                  'a': address,
                  'url': url,
                  'd': displayName,
                  'sentBy': sentBy,
                  'dir': dir,
                  'lang': language,
                  'xparam': [
                    {
                      'name': name,
                      'value': value,
                    }
                  ],
                },
                'category': [
                  {'_content': category}
                ],
                'geo': {
                  'lat': latitude,
                  'lon': longitude,
                },
                'fr': fragment,
                'x_uid': xUid,
                'uid': uid,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'l': folderId,
                's': size,
                'md': changeDate,
                'ms': modifiedSequence,
                'rev': revision,
                'id': id,
                'dur': duration,
                'ptst': partStat.name,
                'ridZ': recurIdZ,
                'tzo': tzOffset,
                'fba': FreeBusyStatus.free.name,
                'percentComplete': taskPercentComplete,
                'recur': isRecurring,
                'hasEx': hasExceptions,
                'priority': priority,
                'fb': FreeBusyStatus.free.name,
                'transp': Transparency.opaque.name,
                'name': name,
                'loc': location,
                'otherAtt': hasOtherAttendees,
                'alarm': hasAlarm,
                'isOrg': isOrganizer,
                'invId': invId.toString(),
                'compNum': componentNum,
                'status': InviteStatus.completed.name,
                'class': InviteClass.public.name,
                'allDay': allDay,
                'draft': draft,
                'neverSent': neverSent,
                'dueDate': taskDueDate,
                'tzoDue': taskTzOffsetDue,
                'alarmData': {
                  'nextAlarm': nextAlarm,
                  'alarmInstStart': alarmInstanceStart,
                  'invId': invId,
                  'compNum': componentNum,
                  'name': name,
                  'loc': location,
                  'alarm': {
                    'action': AlarmAction.display.name,
                    'trigger': {
                      'abs': {
                        'd': dateTimeString,
                      },
                      'rel': {
                        'd': dateTimeString,
                      },
                    },
                    'repeat': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'desc': {'_content': description},
                    'attach': {
                      'uri': uri,
                      'ct': contentType,
                      '_content': binaryB64Data,
                    },
                    'summary': {'_content': summary},
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                },
                'inst': [
                  {
                    's': startTime,
                    'ex': isException,
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'category': [
                      {'_content': category}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'fr': fragment,
                    'd': duration,
                    'ptst': partStat.name,
                    'ridZ': recurIdZ,
                    'tzo': tzOffset,
                    'fba': FreeBusyStatus.free.name,
                    'percentComplete': taskPercentComplete,
                    'recur': isRecurring,
                    'hasEx': hasExceptions,
                    'priority': priority,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'name': name,
                    'loc': location,
                    'otherAtt': hasOtherAttendees,
                    'alarm': hasAlarm,
                    'isOrg': isOrganizer,
                    'invId': invId.toString(),
                    'compNum': componentNum,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'allDay': allDay,
                    'draft': draft,
                    'neverSent': neverSent,
                    'dueDate': taskDueDate,
                    'tzoDue': taskTzOffsetDue,
                  }
                ],
              }
            ],
            'task': [
              {
                'x_uid': xUid,
                'uid': uid,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'l': folderId,
                's': size,
                'md': changeDate,
                'ms': modifiedSequence,
                'rev': revision,
                'id': id,
                'dur': duration,
                'ptst': partStat.name,
                'ridZ': recurIdZ,
                'tzo': tzOffset,
                'fba': FreeBusyStatus.free.name,
                'percentComplete': taskPercentComplete,
                'recur': isRecurring,
                'hasEx': hasExceptions,
                'priority': priority,
                'fb': FreeBusyStatus.free.name,
                'transp': Transparency.opaque.name,
                'name': name,
                'loc': location,
                'otherAtt': hasOtherAttendees,
                'alarm': hasAlarm,
                'isOrg': isOrganizer,
                'invId': invId.toString(),
                'compNum': componentNum,
                'status': InviteStatus.completed.name,
                'class': InviteClass.public.name,
                'allDay': allDay,
                'draft': draft,
                'neverSent': neverSent,
                'dueDate': taskDueDate,
                'tzoDue': taskTzOffsetDue,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getApptSummaries(0, 0);

      final appt = response!.apptEntries.first;
      expect(appt.fragment, fragment);
      expect(appt.xUid, xUid);
      expect(appt.uid, uid);
      expect(appt.flags, flags);
      expect(appt.tags, tags);
      expect(appt.tagNames, tagNames);
      expect(appt.folderId, folderId);
      expect(appt.size, size);
      expect(appt.changeDate, changeDate);
      expect(appt.modifiedSequence, modifiedSequence);
      expect(appt.revision, revision);
      expect(appt.id, id);
      expect(appt.partStat, partStat);
      expect(appt.recurIdZ, recurIdZ);
      expect(appt.tzOffset, tzOffset);
      expect(appt.freeBusyActual, FreeBusyStatus.free);
      expect(appt.taskPercentComplete, taskPercentComplete);
      expect(appt.isRecurring, isRecurring);
      expect(appt.hasExceptions, hasExceptions);
      expect(appt.priority, priority);
      expect(appt.freeBusyIntended, FreeBusyStatus.free);
      expect(appt.transparency, Transparency.opaque);
      expect(appt.name, name);
      expect(appt.location, location);
      expect(appt.hasOtherAttendees, hasOtherAttendees);
      expect(appt.hasAlarm, hasAlarm);
      expect(appt.isOrganizer, isOrganizer);
      expect(appt.invId, invId.toString());
      expect(appt.componentNum, componentNum);
      expect(appt.status, InviteStatus.completed);
      expect(appt.calClass, InviteClass.public);
      expect(appt.allDay, allDay);
      expect(appt.draft, draft);
      expect(appt.neverSent, neverSent);
      expect(appt.taskDueDate, taskDueDate);
      expect(appt.taskTzOffsetDue, taskTzOffsetDue);
      expect(appt.categories.first, category);

      final or = appt.organizer!;
      expect(or.address, address);
      expect(or.url, url);
      expect(or.displayName, displayName);
      expect(or.sentBy, sentBy);
      expect(or.dir, dir);
      expect(or.language, language);
      expect(or.xParams.first.name, name);
      expect(or.xParams.first.value, value);

      final geo = appt.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final inst = appt.instances.first;
      expect(inst.startTime, startTime);
      expect(inst.fragment, fragment);
      expect(inst.isException, isException);
      expect(inst.duration, duration);
      expect(inst.partStat, partStat);
      expect(inst.recurIdZ, recurIdZ);
      expect(inst.tzOffset, tzOffset);
      expect(inst.freeBusyActual, FreeBusyStatus.free);
      expect(inst.taskPercentComplete, taskPercentComplete);
      expect(inst.isRecurring, isRecurring);
      expect(inst.hasExceptions, hasExceptions);
      expect(inst.priority, priority);
      expect(inst.freeBusyIntended, FreeBusyStatus.free);
      expect(inst.transparency, Transparency.opaque);
      expect(inst.name, name);
      expect(inst.location, location);
      expect(inst.hasOtherAttendees, hasOtherAttendees);
      expect(inst.hasAlarm, hasAlarm);
      expect(inst.isOrganizer, isOrganizer);
      expect(inst.invId, invId.toString());
      expect(inst.componentNum, componentNum);
      expect(inst.status, InviteStatus.completed);
      expect(inst.calClass, InviteClass.public);
      expect(inst.allDay, allDay);
      expect(inst.draft, draft);
      expect(inst.neverSent, neverSent);
      expect(inst.taskDueDate, taskDueDate);
      expect(inst.taskTzOffsetDue, taskTzOffsetDue);
      expect(inst.categories.first, category);

      final orInst = inst.organizer!;
      expect(orInst.address, address);
      expect(orInst.url, url);
      expect(orInst.displayName, displayName);
      expect(orInst.sentBy, sentBy);
      expect(orInst.dir, dir);
      expect(orInst.language, language);
      expect(orInst.xParams.first.name, name);
      expect(orInst.xParams.first.value, value);

      final geoInst = inst.geo!;
      expect(geoInst.latitude, latitude);
      expect(geoInst.longitude, longitude);

      final alarmData = appt.alarmData!;
      expect(alarmData.nextAlarm, nextAlarm);
      expect(alarmData.alarmInstanceStart, alarmInstanceStart);
      expect(alarmData.invId, invId);
      expect(alarmData.componentNum, componentNum);
      expect(alarmData.name, name);
      expect(alarmData.location, location);

      final alarm = alarmData.alarm!;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);

      final trigger = alarm.trigger!;
      expect(trigger.absolute!.date, dateTimeString);
      expect(trigger.relative!.date, dateTimeString);

      final repeat = alarm.repeat!;
      expect(repeat.durationNegative, durationNegative);
      expect(repeat.weeks, weeks);
      expect(repeat.days, days);
      expect(repeat.hours, hours);
      expect(repeat.minutes, minutes);
      expect(repeat.seconds, seconds);
      expect(repeat.related, AlarmRelated.start);
      expect(repeat.repeatCount, repeatCount);

      final attach = alarm.attach!;
      expect(attach.uri, uri);
      expect(attach.contentType, contentType);
      expect(attach.binaryB64Data, binaryB64Data);

      final at = alarm.attendees.first;
      expect(at.address, address);
      expect(at.url, url);
      expect(at.displayName, displayName);
      expect(at.sentBy, sentBy);
      expect(at.dir, dir);
      expect(at.language, language);
      expect(at.cuType, cuType);
      expect(at.role, role);
      expect(at.partStat, partStat);
      expect(at.rsvp, rsvp);
      expect(at.member, member);
      expect(at.delegatedTo, delegatedTo);
      expect(at.delegatedFrom, delegatedFrom);
      expect(at.xParams.first.name, name);
      expect(at.xParams.first.value, value);

      final xprop = alarm.xProps.first;
      expect(xprop.name, name);
      expect(xprop.value, value);
      expect(xprop.xParams.first.name, name);
      expect(xprop.xParams.first.value, value);

      final task = response.taskEntries.first;
      expect(task, isA<LegacyCalendaringData>());
      expect(task.xUid, xUid);
      expect(task.uid, uid);
      expect(task.flags, flags);
      expect(task.tags, tags);
      expect(task.tagNames, tagNames);
      expect(task.folderId, folderId);
      expect(task.size, size);
      expect(task.changeDate, changeDate);
      expect(task.modifiedSequence, modifiedSequence);
      expect(task.revision, revision);
      expect(task.id, id);
      expect(task.partStat, partStat);
      expect(task.recurIdZ, recurIdZ);
      expect(task.tzOffset, tzOffset);
      expect(task.freeBusyActual, FreeBusyStatus.free);
      expect(task.taskPercentComplete, taskPercentComplete);
      expect(task.isRecurring, isRecurring);
      expect(task.hasExceptions, hasExceptions);
      expect(task.priority, priority);
      expect(task.freeBusyIntended, FreeBusyStatus.free);
      expect(task.transparency, Transparency.opaque);
      expect(task.name, name);
      expect(task.location, location);
      expect(task.hasOtherAttendees, hasOtherAttendees);
      expect(task.hasAlarm, hasAlarm);
      expect(task.isOrganizer, isOrganizer);
      expect(task.invId, invId.toString());
      expect(task.componentNum, componentNum);
      expect(task.status, InviteStatus.completed);
      expect(task.calClass, InviteClass.public);
      expect(task.allDay, allDay);
      expect(task.draft, draft);
      expect(task.neverSent, neverSent);
      expect(task.taskDueDate, taskDueDate);
      expect(task.taskTzOffsetDue, taskTzOffsetDue);
    }));

    test('Get calendar item summaries test', (() async {
      final id = faker.guid.guid();
      final name = faker.lorem.word();
      final value = faker.lorem.word();
      final category = faker.lorem.word();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final summary = faker.lorem.word();

      final address = faker.internet.email();
      final url = faker.internet.httpsUrl();
      final displayName = faker.person.name();
      final sentBy = faker.internet.email();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();

      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final xUid = faker.guid.guid();
      final uid = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final folderId = faker.guid.guid();
      final size = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final duration = faker.randomGenerator.integer(100);
      final recurIdZ = faker.date.dateTime().toString();
      final tzOffset = faker.randomGenerator.integer(100);
      final taskPercentComplete = faker.lorem.word();
      final isRecurring = faker.randomGenerator.boolean();
      final hasExceptions = faker.randomGenerator.boolean();
      final isException = faker.randomGenerator.boolean();
      final priority = faker.lorem.word();
      final location = faker.lorem.word();
      final hasOtherAttendees = faker.randomGenerator.boolean();
      final hasAlarm = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final invId = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);
      final allDay = faker.randomGenerator.boolean();
      final draft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final taskDueDate = faker.randomGenerator.integer(100);
      final taskTzOffsetDue = faker.randomGenerator.integer(100);

      final nextAlarm = faker.date.dateTime().millisecondsSinceEpoch;
      final alarmInstanceStart = faker.date.dateTime().millisecondsSinceEpoch;
      final dateTimeString = faker.date.dateTime().toString();
      final startTime = faker.date.dateTime().millisecondsSinceEpoch;

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final uri = faker.internet.uri('http');
      final contentType = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final data = {
        'Body': {
          'GetCalendarItemSummariesResponse': {
            '_jsns': 'urn:zimbraMail',
            'appt': [
              {
                'or': {
                  'a': address,
                  'url': url,
                  'd': displayName,
                  'sentBy': sentBy,
                  'dir': dir,
                  'lang': language,
                  'xparam': [
                    {
                      'name': name,
                      'value': value,
                    }
                  ],
                },
                'category': [
                  {'_content': category}
                ],
                'geo': {
                  'lat': latitude,
                  'lon': longitude,
                },
                'fr': fragment,
                'x_uid': xUid,
                'uid': uid,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'l': folderId,
                's': size,
                'md': changeDate,
                'ms': modifiedSequence,
                'rev': revision,
                'id': id,
                'dur': duration,
                'ptst': partStat.name,
                'ridZ': recurIdZ,
                'tzo': tzOffset,
                'fba': FreeBusyStatus.free.name,
                'percentComplete': taskPercentComplete,
                'recur': isRecurring,
                'hasEx': hasExceptions,
                'priority': priority,
                'fb': FreeBusyStatus.free.name,
                'transp': Transparency.opaque.name,
                'name': name,
                'loc': location,
                'otherAtt': hasOtherAttendees,
                'alarm': hasAlarm,
                'isOrg': isOrganizer,
                'invId': invId.toString(),
                'compNum': componentNum,
                'status': InviteStatus.completed.name,
                'class': InviteClass.public.name,
                'allDay': allDay,
                'draft': draft,
                'neverSent': neverSent,
                'dueDate': taskDueDate,
                'tzoDue': taskTzOffsetDue,
                'alarmData': {
                  'nextAlarm': nextAlarm,
                  'alarmInstStart': alarmInstanceStart,
                  'invId': invId,
                  'compNum': componentNum,
                  'name': name,
                  'loc': location,
                  'alarm': {
                    'action': AlarmAction.display.name,
                    'trigger': {
                      'abs': {
                        'd': dateTimeString,
                      },
                      'rel': {
                        'd': dateTimeString,
                      },
                    },
                    'repeat': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'desc': {'_content': description},
                    'attach': {
                      'uri': uri,
                      'ct': contentType,
                      '_content': binaryB64Data,
                    },
                    'summary': {'_content': summary},
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                },
                'inst': [
                  {
                    's': startTime,
                    'ex': isException,
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'category': [
                      {'_content': category}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'fr': fragment,
                    'd': duration,
                    'ptst': partStat.name,
                    'ridZ': recurIdZ,
                    'tzo': tzOffset,
                    'fba': FreeBusyStatus.free.name,
                    'percentComplete': taskPercentComplete,
                    'recur': isRecurring,
                    'hasEx': hasExceptions,
                    'priority': priority,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'name': name,
                    'loc': location,
                    'otherAtt': hasOtherAttendees,
                    'alarm': hasAlarm,
                    'isOrg': isOrganizer,
                    'invId': invId.toString(),
                    'compNum': componentNum,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'allDay': allDay,
                    'draft': draft,
                    'neverSent': neverSent,
                    'dueDate': taskDueDate,
                    'tzoDue': taskTzOffsetDue,
                  }
                ],
              }
            ],
            'task': [
              {
                'x_uid': xUid,
                'uid': uid,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'l': folderId,
                's': size,
                'md': changeDate,
                'ms': modifiedSequence,
                'rev': revision,
                'id': id,
                'dur': duration,
                'ptst': partStat.name,
                'ridZ': recurIdZ,
                'tzo': tzOffset,
                'fba': FreeBusyStatus.free.name,
                'percentComplete': taskPercentComplete,
                'recur': isRecurring,
                'hasEx': hasExceptions,
                'priority': priority,
                'fb': FreeBusyStatus.free.name,
                'transp': Transparency.opaque.name,
                'name': name,
                'loc': location,
                'otherAtt': hasOtherAttendees,
                'alarm': hasAlarm,
                'isOrg': isOrganizer,
                'invId': invId.toString(),
                'compNum': componentNum,
                'status': InviteStatus.completed.name,
                'class': InviteClass.public.name,
                'allDay': allDay,
                'draft': draft,
                'neverSent': neverSent,
                'dueDate': taskDueDate,
                'tzoDue': taskTzOffsetDue,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getCalendarItemSummaries(0, 0);

      final appt = response!.apptEntries.first;
      expect(appt.fragment, fragment);
      expect(appt.xUid, xUid);
      expect(appt.uid, uid);
      expect(appt.flags, flags);
      expect(appt.tags, tags);
      expect(appt.tagNames, tagNames);
      expect(appt.folderId, folderId);
      expect(appt.size, size);
      expect(appt.changeDate, changeDate);
      expect(appt.modifiedSequence, modifiedSequence);
      expect(appt.revision, revision);
      expect(appt.id, id);
      expect(appt.partStat, partStat);
      expect(appt.recurIdZ, recurIdZ);
      expect(appt.tzOffset, tzOffset);
      expect(appt.freeBusyActual, FreeBusyStatus.free);
      expect(appt.taskPercentComplete, taskPercentComplete);
      expect(appt.isRecurring, isRecurring);
      expect(appt.hasExceptions, hasExceptions);
      expect(appt.priority, priority);
      expect(appt.freeBusyIntended, FreeBusyStatus.free);
      expect(appt.transparency, Transparency.opaque);
      expect(appt.name, name);
      expect(appt.location, location);
      expect(appt.hasOtherAttendees, hasOtherAttendees);
      expect(appt.hasAlarm, hasAlarm);
      expect(appt.isOrganizer, isOrganizer);
      expect(appt.invId, invId.toString());
      expect(appt.componentNum, componentNum);
      expect(appt.status, InviteStatus.completed);
      expect(appt.calClass, InviteClass.public);
      expect(appt.allDay, allDay);
      expect(appt.draft, draft);
      expect(appt.neverSent, neverSent);
      expect(appt.taskDueDate, taskDueDate);
      expect(appt.taskTzOffsetDue, taskTzOffsetDue);
      expect(appt.categories.first, category);

      final or = appt.organizer!;
      expect(or.address, address);
      expect(or.url, url);
      expect(or.displayName, displayName);
      expect(or.sentBy, sentBy);
      expect(or.dir, dir);
      expect(or.language, language);
      expect(or.xParams.first.name, name);
      expect(or.xParams.first.value, value);

      final geo = appt.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final inst = appt.instances.first;
      expect(inst.startTime, startTime);
      expect(inst.fragment, fragment);
      expect(inst.isException, isException);
      expect(inst.duration, duration);
      expect(inst.partStat, partStat);
      expect(inst.recurIdZ, recurIdZ);
      expect(inst.tzOffset, tzOffset);
      expect(inst.freeBusyActual, FreeBusyStatus.free);
      expect(inst.taskPercentComplete, taskPercentComplete);
      expect(inst.isRecurring, isRecurring);
      expect(inst.hasExceptions, hasExceptions);
      expect(inst.priority, priority);
      expect(inst.freeBusyIntended, FreeBusyStatus.free);
      expect(inst.transparency, Transparency.opaque);
      expect(inst.name, name);
      expect(inst.location, location);
      expect(inst.hasOtherAttendees, hasOtherAttendees);
      expect(inst.hasAlarm, hasAlarm);
      expect(inst.isOrganizer, isOrganizer);
      expect(inst.invId, invId.toString());
      expect(inst.componentNum, componentNum);
      expect(inst.status, InviteStatus.completed);
      expect(inst.calClass, InviteClass.public);
      expect(inst.allDay, allDay);
      expect(inst.draft, draft);
      expect(inst.neverSent, neverSent);
      expect(inst.taskDueDate, taskDueDate);
      expect(inst.taskTzOffsetDue, taskTzOffsetDue);
      expect(inst.categories.first, category);

      final orInst = inst.organizer!;
      expect(orInst.address, address);
      expect(orInst.url, url);
      expect(orInst.displayName, displayName);
      expect(orInst.sentBy, sentBy);
      expect(orInst.dir, dir);
      expect(orInst.language, language);
      expect(orInst.xParams.first.name, name);
      expect(orInst.xParams.first.value, value);

      final geoInst = inst.geo!;
      expect(geoInst.latitude, latitude);
      expect(geoInst.longitude, longitude);

      final alarmData = appt.alarmData!;
      expect(alarmData.nextAlarm, nextAlarm);
      expect(alarmData.alarmInstanceStart, alarmInstanceStart);
      expect(alarmData.invId, invId);
      expect(alarmData.componentNum, componentNum);
      expect(alarmData.name, name);
      expect(alarmData.location, location);

      final alarm = alarmData.alarm!;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);

      final trigger = alarm.trigger!;
      expect(trigger.absolute!.date, dateTimeString);
      expect(trigger.relative!.date, dateTimeString);

      final repeat = alarm.repeat!;
      expect(repeat.durationNegative, durationNegative);
      expect(repeat.weeks, weeks);
      expect(repeat.days, days);
      expect(repeat.hours, hours);
      expect(repeat.minutes, minutes);
      expect(repeat.seconds, seconds);
      expect(repeat.related, AlarmRelated.start);
      expect(repeat.repeatCount, repeatCount);

      final attach = alarm.attach!;
      expect(attach.uri, uri);
      expect(attach.contentType, contentType);
      expect(attach.binaryB64Data, binaryB64Data);

      final at = alarm.attendees.first;
      expect(at.address, address);
      expect(at.url, url);
      expect(at.displayName, displayName);
      expect(at.sentBy, sentBy);
      expect(at.dir, dir);
      expect(at.language, language);
      expect(at.cuType, cuType);
      expect(at.role, role);
      expect(at.partStat, partStat);
      expect(at.rsvp, rsvp);
      expect(at.member, member);
      expect(at.delegatedTo, delegatedTo);
      expect(at.delegatedFrom, delegatedFrom);
      expect(at.xParams.first.name, name);
      expect(at.xParams.first.value, value);

      final xprop = alarm.xProps.first;
      expect(xprop.name, name);
      expect(xprop.value, value);
      expect(xprop.xParams.first.name, name);
      expect(xprop.xParams.first.value, value);

      final task = response.taskEntries.first;
      expect(task, isA<LegacyCalendaringData>());
      expect(task.xUid, xUid);
      expect(task.uid, uid);
      expect(task.flags, flags);
      expect(task.tags, tags);
      expect(task.tagNames, tagNames);
      expect(task.folderId, folderId);
      expect(task.size, size);
      expect(task.changeDate, changeDate);
      expect(task.modifiedSequence, modifiedSequence);
      expect(task.revision, revision);
      expect(task.id, id);
      expect(task.partStat, partStat);
      expect(task.recurIdZ, recurIdZ);
      expect(task.tzOffset, tzOffset);
      expect(task.freeBusyActual, FreeBusyStatus.free);
      expect(task.taskPercentComplete, taskPercentComplete);
      expect(task.isRecurring, isRecurring);
      expect(task.hasExceptions, hasExceptions);
      expect(task.priority, priority);
      expect(task.freeBusyIntended, FreeBusyStatus.free);
      expect(task.transparency, Transparency.opaque);
      expect(task.name, name);
      expect(task.location, location);
      expect(task.hasOtherAttendees, hasOtherAttendees);
      expect(task.hasAlarm, hasAlarm);
      expect(task.isOrganizer, isOrganizer);
      expect(task.invId, invId.toString());
      expect(task.componentNum, componentNum);
      expect(task.status, InviteStatus.completed);
      expect(task.calClass, InviteClass.public);
      expect(task.allDay, allDay);
      expect(task.draft, draft);
      expect(task.neverSent, neverSent);
      expect(task.taskDueDate, taskDueDate);
      expect(task.taskTzOffsetDue, taskTzOffsetDue);
    }));

    test('Get comments test', (() async {
      final id = faker.guid.guid();
      final email = faker.internet.email();
      final name = faker.person.name();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final section = faker.lorem.word();

      final parentId = faker.guid.guid();
      final uuid = faker.guid.guid();
      final creatorEmail = faker.internet.email();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final date = faker.date.dateTime().millisecondsSinceEpoch;

      final data = {
        'Body': {
          'GetCommentsResponse': {
            '_jsns': 'urn:zimbraMail',
            'user': [
              {
                'id': id,
                'email': email,
                'name': name,
              }
            ],
            'comment': [
              {
                'parentId': parentId,
                'id': id,
                'uuid': uuid,
                'email': creatorEmail,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'color': color,
                'rgb': rgb,
                'd': date,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getComments(ParentId(parentId: id));

      final user = response!.users.first;
      expect(user.id, id);
      expect(user.email, email);
      expect(user.name, name);

      final comment = response.comments.first;
      expect(comment.parentId, parentId);
      expect(comment.id, id);
      expect(comment.uuid, uuid);
      expect(comment.creatorEmail, creatorEmail);
      expect(comment.flags, flags);
      expect(comment.tags, tags);
      expect(comment.tagNames, tagNames);
      expect(comment.color, color);
      expect(comment.rgb, rgb);
      expect(comment.date, date);

      final meta = comment.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);
    }));

    test('Get contact backup list test', (() async {
      final backup1 = faker.lorem.word();
      final backup2 = faker.lorem.word();
      final data = {
        'Body': {
          'GetContactBackupListResponse': {
            '_jsns': 'urn:zimbraMail',
            'backups': {
              'backup': [
                {
                  '_content': backup1,
                },
                {
                  '_content': backup2,
                },
              ]
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getContactBackupList();
      expect(response!.backups, [backup1, backup2]);
    }));

    test('Get contacts test', (() async {
      final sortField = faker.lorem.word();
      final canExpand = faker.randomGenerator.boolean();
      final id = faker.guid.guid();
      final imapUid = faker.randomGenerator.integer(100);
      final folder = faker.lorem.word();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final changeDate = faker.date.dateTime().millisecond;
      final modifiedSequenceId = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final revisionId = faker.randomGenerator.integer(100);
      final fileAs = faker.lorem.word();
      final email = faker.internet.email();
      final email2 = faker.internet.email();
      final email3 = faker.internet.email();
      final type = faker.lorem.word();
      final dlist = faker.lorem.word();
      final reference = faker.lorem.word();
      final tooManyMembers = faker.randomGenerator.boolean();
      final memberOf = faker.internet.email();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final data = {
        'Body': {
          'GetContactsResponse': {
            '_jsns': 'urn:zimbraMail',
            'cn': [
              {
                'sf': sortField,
                'exp': canExpand,
                'id': id,
                'i4uid': imapUid,
                'l': folder,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'md': changeDate,
                'ms': modifiedSequenceId,
                'd': date,
                'rev': revisionId,
                'fileAsStr': fileAs,
                'email': email,
                'email2': email2,
                'email3': email3,
                'type': type,
                'dlist': dlist,
                'ref': reference,
                'tooManyMembers': tooManyMembers,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                '_attrs': {
                  key: value,
                },
                'm': [
                  {
                    'type': MemberType.contact.name,
                    '_content': value,
                    'cn': {
                      'sf': sortField,
                      'exp': canExpand,
                      'id': id,
                      'i4uid': imapUid,
                      'l': folder,
                      'f': flags,
                      't': tags,
                      'tn': tagNames,
                      'md': changeDate,
                      'ms': modifiedSequenceId,
                      'd': date,
                      'rev': revisionId,
                      'fileAsStr': fileAs,
                      'email': email,
                      'email2': email2,
                      'email3': email3,
                      'type': type,
                      'dlist': dlist,
                      'ref': reference,
                      'tooManyMembers': tooManyMembers,
                      'memberOf': {'_content': memberOf},
                    },
                  }
                ],
                'memberOf': {'_content': memberOf},
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getContacts();
      final contact = response!.contacts.first;

      expect(contact.sortField, sortField);
      expect(contact.canExpand, canExpand);
      expect(contact.id, id);
      expect(contact.imapUid, imapUid);
      expect(contact.folder, folder);
      expect(contact.flags, flags);
      expect(contact.tags, tags);
      expect(contact.tagNames, tagNames);
      expect(contact.changeDate, changeDate);
      expect(contact.modifiedSequenceId, modifiedSequenceId);
      expect(contact.date, date);
      expect(contact.revisionId, revisionId);
      expect(contact.fileAs, fileAs);
      expect(contact.email, email);
      expect(contact.email2, email2);
      expect(contact.email3, email3);
      expect(contact.type, type);
      expect(contact.dlist, dlist);
      expect(contact.reference, reference);
      expect(contact.tooManyMembers, tooManyMembers);
      expect(contact.memberOf, memberOf);

      final meta = contact.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final attr = contact.attrs.first;
      expect(attr.key, key);
      expect(attr.value, value);

      final member = contact.contactGroupMembers.first;
      expect(member.type, MemberType.contact);
      expect(member.value, value);

      final cn = member.contact!;
      expect(cn.sortField, sortField);
      expect(cn.canExpand, canExpand);
      expect(cn.id, id);
      expect(cn.imapUid, imapUid);
      expect(cn.folder, folder);
      expect(cn.flags, flags);
      expect(cn.tags, tags);
      expect(cn.tagNames, tagNames);
      expect(cn.changeDate, changeDate);
      expect(cn.modifiedSequenceId, modifiedSequenceId);
      expect(cn.date, date);
      expect(cn.revisionId, revisionId);
      expect(cn.fileAs, fileAs);
      expect(cn.email, email);
      expect(cn.email2, email2);
      expect(cn.email3, email3);
      expect(cn.type, type);
      expect(cn.dlist, dlist);
      expect(cn.reference, reference);
      expect(cn.tooManyMembers, tooManyMembers);
      expect(cn.memberOf, memberOf);
    }));

    test('Get conversation test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final subject = faker.lorem.word();
      final section = faker.lorem.word();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final num = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final flags = faker.lorem.word();
      final tags = faker.randomGenerator.amount((_) => random.integer(10), 10, min: 5).join(',');
      final tagNames = faker.randomGenerator.amount((_) => random.string(10), 10, min: 5).join(',');

      final imapUid = faker.randomGenerator.integer(100);
      final calendarIntendedFor = faker.lorem.word();
      final origId = faker.guid.guid();
      final identityId = faker.guid.guid();
      final draftAccountId = faker.guid.guid();
      final draftAutoSendTime = faker.randomGenerator.integer(100);
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final resentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final part = faker.lorem.word();
      final fragment = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();
      final inReplyTo = faker.internet.email();
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.lorem.word();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();
      final recurrenceId = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final contentType = faker.lorem.word();
      final content = faker.lorem.word();
      final summary = faker.guid.guid();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final componentNum = faker.randomGenerator.integer(100);
      final method = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.date.dateTime().millisecondsSinceEpoch;
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GetConvResponse': {
            '_jsns': 'urn:zimbraMail',
            'c': {
              'id': id,
              'n': num,
              'total': totalSize,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'su': subject,
              'm': [
                {
                  'id': id,
                  'i4uid': imapUid,
                  'cif': calendarIntendedFor,
                  'origid': origId,
                  'rt': ReplyType.replied.name,
                  'idnt': identityId,
                  'forAcct': draftAccountId,
                  'autoSendTime': draftAutoSendTime,
                  'sd': sentDate,
                  'rd': resentDate,
                  'part': part,
                  'fr': fragment,
                  'e': [
                    {
                      'a': address,
                      'd': display,
                      'p': personal,
                      't': AddressType.from.name,
                      'isGroup': isGroup,
                      'exp': canExpandGroupMembers,
                    }
                  ],
                  'su': subject,
                  'mid': messageIdHeader,
                  'irt': inReplyTo,
                  's': size,
                  'd': date,
                  'l': folder,
                  'cid': conversationId,
                  'f': flags,
                  't': tags,
                  'tn': tagNames,
                  'rev': revision,
                  'md': changeDate,
                  'ms': modifiedSequence,
                  'inv': {
                    'type': InviteType.appt.name,
                    'tz': [
                      {
                        'id': id,
                        'stdoff': tzStdOffset,
                        'dayoff': tzDayOffset,
                        'standard': {
                          'mon': month,
                          'hour': hour,
                          'min': minute,
                          'sec': second,
                          'mday': dayOfMonth,
                          'week': week,
                          'wkday': dayOfWeek,
                        },
                        'daylight': {
                          'mon': month,
                          'hour': hour,
                          'min': minute,
                          'sec': second,
                          'mday': dayOfMonth,
                          'week': week,
                          'wkday': dayOfWeek,
                        },
                        'stdname': standardTZName,
                        'dayname': daylightTZName,
                      }
                    ],
                    'comp': {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    },
                    'replies': {
                      'reply': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'seq': seq,
                          'd': date,
                          'at': attendee,
                          'sentBy': sentBy,
                          'ptst': partStat.name,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ]
                    }
                  },
                  '_attrs': {
                    key: value,
                  },
                  'mp': [
                    {
                      'part': part,
                      'ct': contentType,
                      's': size,
                      'cd': contentDisposition,
                      'filename': contentFilename,
                      'ci': contentId,
                      'cl': location,
                      'body': body,
                      'truncated': truncatedContent,
                      'content': content,
                      'mp': [
                        {
                          'part': part,
                          'ct': contentType,
                          's': size,
                          'cd': contentDisposition,
                          'filename': contentFilename,
                          'ci': contentId,
                          'cl': location,
                          'body': body,
                          'truncated': truncatedContent,
                          'content': content,
                        }
                      ],
                    }
                  ],
                  'shr': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                  'dlSubs': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                  'meta': [
                    {
                      'section': section,
                      '_attrs': {
                        key: value,
                      },
                    }
                  ],
                }
              ],
              'chat': [
                {
                  'id': id,
                  'i4uid': imapUid,
                  'cif': calendarIntendedFor,
                  'origid': origId,
                  'rt': ReplyType.replied.name,
                  'idnt': identityId,
                  'forAcct': draftAccountId,
                  'autoSendTime': draftAutoSendTime,
                  'sd': sentDate,
                  'rd': resentDate,
                  'part': part,
                  'fr': fragment,
                  'su': subject,
                  'mid': messageIdHeader,
                  'irt': inReplyTo,
                  's': size,
                  'd': date,
                  'l': folder,
                  'cid': conversationId,
                  'f': flags,
                  't': tags,
                  'tn': tagNames,
                  'rev': revision,
                  'md': changeDate,
                  'ms': modifiedSequence,
                }
              ],
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getConv(ConversationSpec());
      final conv = response!.conversation!;

      expect(conv.id, id);
      expect(conv.num, num);
      expect(conv.totalSize, totalSize);
      expect(conv.flags, flags);
      expect(conv.tags, tags);
      expect(conv.tagNames, tagNames);
      expect(conv.subject, subject);

      final meta = conv.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final msg = conv.messages.first;
      expect(msg.id, id);
      expect(msg.imapUid, imapUid);
      expect(msg.calendarIntendedFor, calendarIntendedFor);
      expect(msg.origId, origId);
      expect(msg.draftReplyType, ReplyType.replied);
      expect(msg.identityId, identityId);
      expect(msg.draftAccountId, draftAccountId);
      expect(msg.draftAutoSendTime, draftAutoSendTime);
      expect(msg.sentDate, sentDate);
      expect(msg.resentDate, resentDate);
      expect(msg.part, part);
      expect(msg.fragment, fragment);
      expect(msg.subject, subject);
      expect(msg.messageIdHeader, messageIdHeader);
      expect(msg.inReplyTo, inReplyTo);
      expect(msg.size, size);
      expect(msg.date, date);
      expect(msg.folder, folder);
      expect(msg.conversationId, conversationId);
      expect(msg.flags, flags);
      expect(msg.tags, tags);
      expect(msg.tagNames, tagNames);
      expect(msg.revision, revision);
      expect(msg.changeDate, changeDate);
      expect(msg.modifiedSequence, modifiedSequence);

      final header = msg.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final partInfo = msg.partInfos.first;
      expect(partInfo.part, part);
      expect(partInfo.contentType, contentType);
      expect(partInfo.size, size);
      expect(partInfo.contentDisposition, contentDisposition);
      expect(partInfo.contentFilename, contentFilename);
      expect(partInfo.contentId, contentId);
      expect(partInfo.location, location);
      expect(partInfo.body, body);
      expect(partInfo.truncatedContent, truncatedContent);
      expect(partInfo.content, content);

      final mimePart = partInfo.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = msg.shareNotifications.first;
      expect(shr.content, content);
      expect(shr.truncatedContent, truncatedContent);

      final dlSubs = msg.dlSubsNotifications.first;
      expect(dlSubs.content, content);
      expect(dlSubs.truncatedContent, truncatedContent);

      final msgMeta = msg.metadatas.first;
      expect(msgMeta.section, section);
      expect(msgMeta.keyValuePairs.first.key, key);
      expect(msgMeta.keyValuePairs.first.value, value);

      final invite = msg.invite!;
      expect(invite.calItemType, InviteType.appt);

      final tz = invite.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = invite.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = invite.inviteComponent!;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);

      final chat = conv.chatMessages.first;
      expect(chat.id, id);
      expect(chat.imapUid, imapUid);
      expect(chat.calendarIntendedFor, calendarIntendedFor);
      expect(chat.origId, origId);
      expect(chat.draftReplyType, ReplyType.replied);
      expect(chat.identityId, identityId);
      expect(chat.draftAccountId, draftAccountId);
      expect(chat.draftAutoSendTime, draftAutoSendTime);
      expect(chat.sentDate, sentDate);
      expect(chat.resentDate, resentDate);
      expect(chat.part, part);
      expect(chat.fragment, fragment);
      expect(chat.subject, subject);
      expect(chat.messageIdHeader, messageIdHeader);
      expect(chat.inReplyTo, inReplyTo);
      expect(chat.size, size);
      expect(chat.date, date);
      expect(chat.folder, folder);
      expect(chat.conversationId, conversationId);
      expect(chat.flags, flags);
      expect(chat.tags, tags);
      expect(chat.tagNames, tagNames);
      expect(chat.revision, revision);
      expect(chat.changeDate, changeDate);
      expect(chat.modifiedSequence, modifiedSequence);
    }));

    test('Get custom metadata test', (() async {
      final id = faker.guid.guid();
      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final data = {
        'Body': {
          'GetCustomMetadataResponse': {
            '_jsns': 'urn:zimbraMail',
            'id': id,
            'meta': {
              'section': section,
              '_attrs': {
                key: value,
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getCustomMetadata(SectionAttr());

      expect(response!.id, id);

      final meta = response.metadata!;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);
    }));

    test('Get data source usage test', (() async {
      final id = faker.guid.guid();
      final usage = faker.randomGenerator.integer(100);
      final dataSourceQuota = faker.randomGenerator.integer(100);
      final totalQuota = faker.randomGenerator.integer(100);

      final data = {
        'Body': {
          'GetDataSourceUsageResponse': {
            '_jsns': 'urn:zimbraMail',
            'dsQuota': dataSourceQuota,
            'dsTotalQuota': totalQuota,
            'dataSourceUsage': [
              {
                'id': id,
                'usage': usage,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getDataSourceUsage();

      expect(response!.dataSourceQuota, dataSourceQuota);
      expect(response.totalQuota, totalQuota);

      final dsUsage = response.usages.first;
      expect(dsUsage.id, id);
      expect(dsUsage.usage, usage);
    }));

    test('Get data sources test', (() async {
      final id = faker.guid.guid();
      final name = faker.lorem.word();
      final folderId = faker.guid.guid();
      final isEnabled = faker.randomGenerator.boolean();
      final importOnly = faker.randomGenerator.boolean();
      final host = faker.internet.ipv4Address();
      final port = faker.randomGenerator.integer(100);
      final username = faker.internet.userName();
      final password = faker.internet.password();
      final pollingInterval = faker.lorem.word();
      final emailAddress = faker.internet.email();
      final smtpEnabled = faker.randomGenerator.boolean();
      final smtpHost = faker.internet.ipv4Address();
      final smtpPort = faker.randomGenerator.integer(100);
      final smtpAuthRequired = faker.randomGenerator.boolean();
      final smtpUsername = faker.internet.userName();
      final smtpPassword = faker.internet.password();
      final useAddressForForwardReply = faker.randomGenerator.boolean();
      final defaultSignature = faker.lorem.word();
      final forwardReplySignature = faker.lorem.word();
      final fromDisplay = faker.lorem.word();
      final replyToAddress = faker.internet.email();
      final replyToDisplay = faker.person.name();
      final importClass = faker.lorem.word();
      final failingSince = faker.randomGenerator.integer(100);
      final lastError = faker.lorem.word();
      final attribute = faker.lorem.word();
      final refreshToken = faker.guid.guid();
      final refreshTokenUrl = faker.internet.httpsUrl();
      final leaveOnServer = faker.randomGenerator.boolean();
      final oauthToken = faker.guid.guid();
      final clientId = faker.guid.guid();
      final clientSecret = faker.guid.guid();
      final test = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GetDataSourcesResponse': {
            '_jsns': 'urn:zimbraMail',
            'imap': [
              {
                'id': id,
                'name': name,
                'l': folderId,
                'isEnabled': isEnabled,
                'importOnly': importOnly,
                'host': host,
                'port': port,
                'connectionType': ConnectionType.clearText.name,
                'username': username,
                'password': password,
                'pollingInterval': pollingInterval,
                'emailAddress': emailAddress,
                'smtpEnabled': smtpEnabled,
                'smtpHost': smtpHost,
                'smtpPort': smtpPort,
                'smtpConnectionType': ConnectionType.clearText.name,
                'smtpAuthRequired': smtpAuthRequired,
                'smtpUsername': smtpUsername,
                'smtpPassword': smtpPassword,
                'useAddressForForwardReply': useAddressForForwardReply,
                'defaultSignature': defaultSignature,
                'forwardReplySignature': forwardReplySignature,
                'fromDisplay': fromDisplay,
                'replyToAddress': replyToAddress,
                'replyToDisplay': replyToDisplay,
                'importClass': importClass,
                'failingSince': failingSince,
                'lastError': {'_content': lastError},
                'refreshToken': refreshToken,
                'refreshTokenUrl': refreshTokenUrl,
                'oauthToken': oauthToken,
                'clientId': clientId,
                'clientSecret': clientSecret,
                'test': test,
                'a': [
                  {'_content': attribute}
                ],
              }
            ],
            'pop3': [
              {
                'id': id,
                'name': name,
                'l': folderId,
                'isEnabled': isEnabled,
                'importOnly': importOnly,
                'host': host,
                'port': port,
                'connectionType': ConnectionType.clearText.name,
                'username': username,
                'password': password,
                'pollingInterval': pollingInterval,
                'emailAddress': emailAddress,
                'smtpEnabled': smtpEnabled,
                'smtpHost': smtpHost,
                'smtpPort': smtpPort,
                'smtpConnectionType': ConnectionType.clearText.name,
                'smtpAuthRequired': smtpAuthRequired,
                'smtpUsername': smtpUsername,
                'smtpPassword': smtpPassword,
                'useAddressForForwardReply': useAddressForForwardReply,
                'defaultSignature': defaultSignature,
                'forwardReplySignature': forwardReplySignature,
                'fromDisplay': fromDisplay,
                'replyToAddress': replyToAddress,
                'replyToDisplay': replyToDisplay,
                'importClass': importClass,
                'failingSince': failingSince,
                'lastError': {'_content': lastError},
                'refreshToken': refreshToken,
                'refreshTokenUrl': refreshTokenUrl,
                'leaveOnServer': leaveOnServer,
                'a': [
                  {'_content': attribute}
                ],
              }
            ],
            'caldav': [
              {
                'id': id,
                'name': name,
                'l': folderId,
                'isEnabled': isEnabled,
                'importOnly': importOnly,
                'host': host,
                'port': port,
                'connectionType': ConnectionType.clearText.name,
                'username': username,
                'password': password,
                'pollingInterval': pollingInterval,
                'emailAddress': emailAddress,
                'smtpEnabled': smtpEnabled,
                'smtpHost': smtpHost,
                'smtpPort': smtpPort,
                'smtpConnectionType': ConnectionType.clearText.name,
                'smtpAuthRequired': smtpAuthRequired,
                'smtpUsername': smtpUsername,
                'smtpPassword': smtpPassword,
                'useAddressForForwardReply': useAddressForForwardReply,
                'defaultSignature': defaultSignature,
                'forwardReplySignature': forwardReplySignature,
                'fromDisplay': fromDisplay,
                'replyToAddress': replyToAddress,
                'replyToDisplay': replyToDisplay,
                'importClass': importClass,
                'failingSince': failingSince,
                'lastError': {'_content': lastError},
                'refreshToken': refreshToken,
                'refreshTokenUrl': refreshTokenUrl,
                'a': [
                  {'_content': attribute}
                ],
              }
            ],
            'yab': [
              {
                'id': id,
                'name': name,
                'l': folderId,
                'isEnabled': isEnabled,
                'importOnly': importOnly,
                'host': host,
                'port': port,
                'connectionType': ConnectionType.clearText.name,
                'username': username,
                'password': password,
                'pollingInterval': pollingInterval,
                'emailAddress': emailAddress,
                'smtpEnabled': smtpEnabled,
                'smtpHost': smtpHost,
                'smtpPort': smtpPort,
                'smtpConnectionType': ConnectionType.clearText.name,
                'smtpAuthRequired': smtpAuthRequired,
                'smtpUsername': smtpUsername,
                'smtpPassword': smtpPassword,
                'useAddressForForwardReply': useAddressForForwardReply,
                'defaultSignature': defaultSignature,
                'forwardReplySignature': forwardReplySignature,
                'fromDisplay': fromDisplay,
                'replyToAddress': replyToAddress,
                'replyToDisplay': replyToDisplay,
                'importClass': importClass,
                'failingSince': failingSince,
                'lastError': {'_content': lastError},
                'refreshToken': refreshToken,
                'refreshTokenUrl': refreshTokenUrl,
                'a': [
                  {'_content': attribute}
                ],
              }
            ],
            'rss': [
              {
                'id': id,
                'name': name,
                'l': folderId,
                'isEnabled': isEnabled,
                'importOnly': importOnly,
                'host': host,
                'port': port,
                'connectionType': ConnectionType.clearText.name,
                'username': username,
                'password': password,
                'pollingInterval': pollingInterval,
                'emailAddress': emailAddress,
                'smtpEnabled': smtpEnabled,
                'smtpHost': smtpHost,
                'smtpPort': smtpPort,
                'smtpConnectionType': ConnectionType.clearText.name,
                'smtpAuthRequired': smtpAuthRequired,
                'smtpUsername': smtpUsername,
                'smtpPassword': smtpPassword,
                'useAddressForForwardReply': useAddressForForwardReply,
                'defaultSignature': defaultSignature,
                'forwardReplySignature': forwardReplySignature,
                'fromDisplay': fromDisplay,
                'replyToAddress': replyToAddress,
                'replyToDisplay': replyToDisplay,
                'importClass': importClass,
                'failingSince': failingSince,
                'lastError': {'_content': lastError},
                'refreshToken': refreshToken,
                'refreshTokenUrl': refreshTokenUrl,
                'a': [
                  {'_content': attribute}
                ],
              }
            ],
            'gal': [
              {
                'id': id,
                'name': name,
                'l': folderId,
                'isEnabled': isEnabled,
                'importOnly': importOnly,
                'host': host,
                'port': port,
                'connectionType': ConnectionType.clearText.name,
                'username': username,
                'password': password,
                'pollingInterval': pollingInterval,
                'emailAddress': emailAddress,
                'smtpEnabled': smtpEnabled,
                'smtpHost': smtpHost,
                'smtpPort': smtpPort,
                'smtpConnectionType': ConnectionType.clearText.name,
                'smtpAuthRequired': smtpAuthRequired,
                'smtpUsername': smtpUsername,
                'smtpPassword': smtpPassword,
                'useAddressForForwardReply': useAddressForForwardReply,
                'defaultSignature': defaultSignature,
                'forwardReplySignature': forwardReplySignature,
                'fromDisplay': fromDisplay,
                'replyToAddress': replyToAddress,
                'replyToDisplay': replyToDisplay,
                'importClass': importClass,
                'failingSince': failingSince,
                'lastError': {'_content': lastError},
                'refreshToken': refreshToken,
                'refreshTokenUrl': refreshTokenUrl,
                'a': [
                  {'_content': attribute}
                ],
              }
            ],
            'cal': [
              {
                'id': id,
                'name': name,
                'l': folderId,
                'isEnabled': isEnabled,
                'importOnly': importOnly,
                'host': host,
                'port': port,
                'connectionType': ConnectionType.clearText.name,
                'username': username,
                'password': password,
                'pollingInterval': pollingInterval,
                'emailAddress': emailAddress,
                'smtpEnabled': smtpEnabled,
                'smtpHost': smtpHost,
                'smtpPort': smtpPort,
                'smtpConnectionType': ConnectionType.clearText.name,
                'smtpAuthRequired': smtpAuthRequired,
                'smtpUsername': smtpUsername,
                'smtpPassword': smtpPassword,
                'useAddressForForwardReply': useAddressForForwardReply,
                'defaultSignature': defaultSignature,
                'forwardReplySignature': forwardReplySignature,
                'fromDisplay': fromDisplay,
                'replyToAddress': replyToAddress,
                'replyToDisplay': replyToDisplay,
                'importClass': importClass,
                'failingSince': failingSince,
                'lastError': {'_content': lastError},
                'refreshToken': refreshToken,
                'refreshTokenUrl': refreshTokenUrl,
                'a': [
                  {'_content': attribute}
                ],
              }
            ],
            'unknown': [
              {
                'id': id,
                'name': name,
                'l': folderId,
                'isEnabled': isEnabled,
                'importOnly': importOnly,
                'host': host,
                'port': port,
                'connectionType': ConnectionType.clearText.name,
                'username': username,
                'password': password,
                'pollingInterval': pollingInterval,
                'emailAddress': emailAddress,
                'smtpEnabled': smtpEnabled,
                'smtpHost': smtpHost,
                'smtpPort': smtpPort,
                'smtpConnectionType': ConnectionType.clearText.name,
                'smtpAuthRequired': smtpAuthRequired,
                'smtpUsername': smtpUsername,
                'smtpPassword': smtpPassword,
                'useAddressForForwardReply': useAddressForForwardReply,
                'defaultSignature': defaultSignature,
                'forwardReplySignature': forwardReplySignature,
                'fromDisplay': fromDisplay,
                'replyToAddress': replyToAddress,
                'replyToDisplay': replyToDisplay,
                'importClass': importClass,
                'failingSince': failingSince,
                'lastError': {'_content': lastError},
                'refreshToken': refreshToken,
                'refreshTokenUrl': refreshTokenUrl,
                'a': [
                  {'_content': attribute}
                ],
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getDataSources();

      final imap = response!.imapDataSources.first;
      expect(imap.id, id);
      expect(imap.name, name);
      expect(imap.folderId, folderId);
      expect(imap.isEnabled, isEnabled);
      expect(imap.importOnly, importOnly);
      expect(imap.host, host);
      expect(imap.port, port);
      expect(imap.connectionType, ConnectionType.clearText);
      expect(imap.username, username);
      expect(imap.password, password);
      expect(imap.pollingInterval, pollingInterval);
      expect(imap.emailAddress, emailAddress);
      expect(imap.smtpEnabled, smtpEnabled);
      expect(imap.smtpHost, smtpHost);
      expect(imap.smtpPort, smtpPort);
      expect(imap.smtpConnectionType, ConnectionType.clearText);
      expect(imap.smtpAuthRequired, smtpAuthRequired);
      expect(imap.smtpUsername, smtpUsername);
      expect(imap.smtpPassword, smtpPassword);
      expect(imap.useAddressForForwardReply, useAddressForForwardReply);
      expect(imap.defaultSignature, defaultSignature);
      expect(imap.forwardReplySignature, forwardReplySignature);
      expect(imap.fromDisplay, fromDisplay);
      expect(imap.replyToAddress, replyToAddress);
      expect(imap.replyToDisplay, replyToDisplay);
      expect(imap.importClass, importClass);
      expect(imap.failingSince, failingSince);
      expect(imap.lastError, lastError);
      expect(imap.refreshToken, refreshToken);
      expect(imap.refreshTokenUrl, refreshTokenUrl);
      expect(imap.oauthToken, oauthToken);
      expect(imap.clientId, clientId);
      expect(imap.clientSecret, clientSecret);
      expect(imap.test, test);
      expect(imap.attributes.first, attribute);

      final pop3 = response.pop3DataSources.first;
      expect(pop3.id, id);
      expect(pop3.name, name);
      expect(pop3.folderId, folderId);
      expect(pop3.isEnabled, isEnabled);
      expect(pop3.importOnly, importOnly);
      expect(pop3.host, host);
      expect(pop3.port, port);
      expect(pop3.connectionType, ConnectionType.clearText);
      expect(pop3.username, username);
      expect(pop3.password, password);
      expect(pop3.pollingInterval, pollingInterval);
      expect(pop3.emailAddress, emailAddress);
      expect(pop3.smtpEnabled, smtpEnabled);
      expect(pop3.smtpHost, smtpHost);
      expect(pop3.smtpPort, smtpPort);
      expect(pop3.smtpConnectionType, ConnectionType.clearText);
      expect(pop3.smtpAuthRequired, smtpAuthRequired);
      expect(pop3.smtpUsername, smtpUsername);
      expect(pop3.smtpPassword, smtpPassword);
      expect(pop3.useAddressForForwardReply, useAddressForForwardReply);
      expect(pop3.defaultSignature, defaultSignature);
      expect(pop3.forwardReplySignature, forwardReplySignature);
      expect(pop3.fromDisplay, fromDisplay);
      expect(pop3.replyToAddress, replyToAddress);
      expect(pop3.replyToDisplay, replyToDisplay);
      expect(pop3.importClass, importClass);
      expect(pop3.failingSince, failingSince);
      expect(pop3.lastError, lastError);
      expect(pop3.refreshToken, refreshToken);
      expect(pop3.refreshTokenUrl, refreshTokenUrl);
      expect(pop3.leaveOnServer, leaveOnServer);
      expect(pop3.attributes.first, attribute);

      final caldav = response.caldavDataSources.first;
      expect(caldav.id, id);
      expect(caldav.name, name);
      expect(caldav.folderId, folderId);
      expect(caldav.isEnabled, isEnabled);
      expect(caldav.importOnly, importOnly);
      expect(caldav.host, host);
      expect(caldav.port, port);
      expect(caldav.connectionType, ConnectionType.clearText);
      expect(caldav.username, username);
      expect(caldav.password, password);
      expect(caldav.pollingInterval, pollingInterval);
      expect(caldav.emailAddress, emailAddress);
      expect(caldav.smtpEnabled, smtpEnabled);
      expect(caldav.smtpHost, smtpHost);
      expect(caldav.smtpPort, smtpPort);
      expect(caldav.smtpConnectionType, ConnectionType.clearText);
      expect(caldav.smtpAuthRequired, smtpAuthRequired);
      expect(caldav.smtpUsername, smtpUsername);
      expect(caldav.smtpPassword, smtpPassword);
      expect(caldav.useAddressForForwardReply, useAddressForForwardReply);
      expect(caldav.defaultSignature, defaultSignature);
      expect(caldav.forwardReplySignature, forwardReplySignature);
      expect(caldav.fromDisplay, fromDisplay);
      expect(caldav.replyToAddress, replyToAddress);
      expect(caldav.replyToDisplay, replyToDisplay);
      expect(caldav.importClass, importClass);
      expect(caldav.failingSince, failingSince);
      expect(caldav.lastError, lastError);
      expect(caldav.refreshToken, refreshToken);
      expect(caldav.refreshTokenUrl, refreshTokenUrl);
      expect(caldav.attributes.first, attribute);

      final yab = response.yabDataSources.first;
      expect(yab.id, id);
      expect(yab.name, name);
      expect(yab.folderId, folderId);
      expect(yab.isEnabled, isEnabled);
      expect(yab.importOnly, importOnly);
      expect(yab.host, host);
      expect(yab.port, port);
      expect(yab.connectionType, ConnectionType.clearText);
      expect(yab.username, username);
      expect(yab.password, password);
      expect(yab.pollingInterval, pollingInterval);
      expect(yab.emailAddress, emailAddress);
      expect(yab.smtpEnabled, smtpEnabled);
      expect(yab.smtpHost, smtpHost);
      expect(yab.smtpPort, smtpPort);
      expect(yab.smtpConnectionType, ConnectionType.clearText);
      expect(yab.smtpAuthRequired, smtpAuthRequired);
      expect(yab.smtpUsername, smtpUsername);
      expect(yab.smtpPassword, smtpPassword);
      expect(yab.useAddressForForwardReply, useAddressForForwardReply);
      expect(yab.defaultSignature, defaultSignature);
      expect(yab.forwardReplySignature, forwardReplySignature);
      expect(yab.fromDisplay, fromDisplay);
      expect(yab.replyToAddress, replyToAddress);
      expect(yab.replyToDisplay, replyToDisplay);
      expect(yab.importClass, importClass);
      expect(yab.failingSince, failingSince);
      expect(yab.lastError, lastError);
      expect(yab.refreshToken, refreshToken);
      expect(yab.refreshTokenUrl, refreshTokenUrl);
      expect(yab.attributes.first, attribute);

      final rss = response.rssDataSources.first;
      expect(rss.id, id);
      expect(rss.name, name);
      expect(rss.folderId, folderId);
      expect(rss.isEnabled, isEnabled);
      expect(rss.importOnly, importOnly);
      expect(rss.host, host);
      expect(rss.port, port);
      expect(rss.connectionType, ConnectionType.clearText);
      expect(rss.username, username);
      expect(rss.password, password);
      expect(rss.pollingInterval, pollingInterval);
      expect(rss.emailAddress, emailAddress);
      expect(rss.smtpEnabled, smtpEnabled);
      expect(rss.smtpHost, smtpHost);
      expect(rss.smtpPort, smtpPort);
      expect(rss.smtpConnectionType, ConnectionType.clearText);
      expect(rss.smtpAuthRequired, smtpAuthRequired);
      expect(rss.smtpUsername, smtpUsername);
      expect(rss.smtpPassword, smtpPassword);
      expect(rss.useAddressForForwardReply, useAddressForForwardReply);
      expect(rss.defaultSignature, defaultSignature);
      expect(rss.forwardReplySignature, forwardReplySignature);
      expect(rss.fromDisplay, fromDisplay);
      expect(rss.replyToAddress, replyToAddress);
      expect(rss.replyToDisplay, replyToDisplay);
      expect(rss.importClass, importClass);
      expect(rss.failingSince, failingSince);
      expect(rss.lastError, lastError);
      expect(rss.refreshToken, refreshToken);
      expect(rss.refreshTokenUrl, refreshTokenUrl);
      expect(rss.attributes.first, attribute);

      final gal = response.galDataSources.first;
      expect(gal.id, id);
      expect(gal.name, name);
      expect(gal.folderId, folderId);
      expect(gal.isEnabled, isEnabled);
      expect(gal.importOnly, importOnly);
      expect(gal.host, host);
      expect(gal.port, port);
      expect(gal.connectionType, ConnectionType.clearText);
      expect(gal.username, username);
      expect(gal.password, password);
      expect(gal.pollingInterval, pollingInterval);
      expect(gal.emailAddress, emailAddress);
      expect(gal.smtpEnabled, smtpEnabled);
      expect(gal.smtpHost, smtpHost);
      expect(gal.smtpPort, smtpPort);
      expect(gal.smtpConnectionType, ConnectionType.clearText);
      expect(gal.smtpAuthRequired, smtpAuthRequired);
      expect(gal.smtpUsername, smtpUsername);
      expect(gal.smtpPassword, smtpPassword);
      expect(gal.useAddressForForwardReply, useAddressForForwardReply);
      expect(gal.defaultSignature, defaultSignature);
      expect(gal.forwardReplySignature, forwardReplySignature);
      expect(gal.fromDisplay, fromDisplay);
      expect(gal.replyToAddress, replyToAddress);
      expect(gal.replyToDisplay, replyToDisplay);
      expect(gal.importClass, importClass);
      expect(gal.failingSince, failingSince);
      expect(gal.lastError, lastError);
      expect(gal.refreshToken, refreshToken);
      expect(gal.refreshTokenUrl, refreshTokenUrl);
      expect(gal.attributes.first, attribute);

      final cal = response.calDataSources.first;
      expect(cal.id, id);
      expect(cal.name, name);
      expect(cal.folderId, folderId);
      expect(cal.isEnabled, isEnabled);
      expect(cal.importOnly, importOnly);
      expect(cal.host, host);
      expect(cal.port, port);
      expect(cal.connectionType, ConnectionType.clearText);
      expect(cal.username, username);
      expect(cal.password, password);
      expect(cal.pollingInterval, pollingInterval);
      expect(cal.emailAddress, emailAddress);
      expect(cal.smtpEnabled, smtpEnabled);
      expect(cal.smtpHost, smtpHost);
      expect(cal.smtpPort, smtpPort);
      expect(cal.smtpConnectionType, ConnectionType.clearText);
      expect(cal.smtpAuthRequired, smtpAuthRequired);
      expect(cal.smtpUsername, smtpUsername);
      expect(cal.smtpPassword, smtpPassword);
      expect(cal.useAddressForForwardReply, useAddressForForwardReply);
      expect(cal.defaultSignature, defaultSignature);
      expect(cal.forwardReplySignature, forwardReplySignature);
      expect(cal.fromDisplay, fromDisplay);
      expect(cal.replyToAddress, replyToAddress);
      expect(cal.replyToDisplay, replyToDisplay);
      expect(cal.importClass, importClass);
      expect(cal.failingSince, failingSince);
      expect(cal.lastError, lastError);
      expect(cal.refreshToken, refreshToken);
      expect(cal.refreshTokenUrl, refreshTokenUrl);
      expect(cal.attributes.first, attribute);

      final unknown = response.unknownDataSources.first;
      expect(unknown.id, id);
      expect(unknown.name, name);
      expect(unknown.folderId, folderId);
      expect(unknown.isEnabled, isEnabled);
      expect(unknown.importOnly, importOnly);
      expect(unknown.host, host);
      expect(unknown.port, port);
      expect(unknown.connectionType, ConnectionType.clearText);
      expect(unknown.username, username);
      expect(unknown.password, password);
      expect(unknown.pollingInterval, pollingInterval);
      expect(unknown.emailAddress, emailAddress);
      expect(unknown.smtpEnabled, smtpEnabled);
      expect(unknown.smtpHost, smtpHost);
      expect(unknown.smtpPort, smtpPort);
      expect(unknown.smtpConnectionType, ConnectionType.clearText);
      expect(unknown.smtpAuthRequired, smtpAuthRequired);
      expect(unknown.smtpUsername, smtpUsername);
      expect(unknown.smtpPassword, smtpPassword);
      expect(unknown.useAddressForForwardReply, useAddressForForwardReply);
      expect(unknown.defaultSignature, defaultSignature);
      expect(unknown.forwardReplySignature, forwardReplySignature);
      expect(unknown.fromDisplay, fromDisplay);
      expect(unknown.replyToAddress, replyToAddress);
      expect(unknown.replyToDisplay, replyToDisplay);
      expect(unknown.importClass, importClass);
      expect(unknown.failingSince, failingSince);
      expect(unknown.lastError, lastError);
      expect(unknown.refreshToken, refreshToken);
      expect(unknown.refreshTokenUrl, refreshTokenUrl);
      expect(unknown.attributes.first, attribute);
    }));

    test('Get effective folder perms test', (() async {
      final effectivePermissions = faker.lorem.word();
      final data = {
        'Body': {
          'GetEffectiveFolderPermsResponse': {
            '_jsns': 'urn:zimbraMail',
            'folder': {
              'perm': effectivePermissions,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getEffectiveFolderPerms(FolderSpec());
      final folder = response!.folder!;
      expect(folder.effectivePermissions, effectivePermissions);
    }));

    test('Get filter rules test', (() async {
      final name = faker.lorem.word();
      final value = faker.lorem.word();
      final active = faker.randomGenerator.boolean();
      final index = faker.randomGenerator.integer(100);
      final negative = faker.randomGenerator.boolean();
      final caseSensitive = faker.randomGenerator.boolean();
      final header = faker.lorem.word();
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final time = faker.date.dateTime().toString();
      final method = faker.lorem.word();
      final size = faker.lorem.word();

      final folder = faker.lorem.word();
      final copy = faker.randomGenerator.boolean();
      final tag = faker.lorem.word();
      final address = faker.internet.email();
      final content = faker.lorem.word();
      final subject = faker.lorem.word();
      final maxBodySize = faker.randomGenerator.integer(100);
      final origHeaders = faker.lorem.word();
      final from = faker.internet.email();
      final importance = faker.lorem.word();
      final options = faker.lorem.word();
      final message = faker.lorem.word();
      final last = faker.randomGenerator.boolean();
      final offset = faker.randomGenerator.integer(100);
      final countComparator = faker.randomGenerator.boolean();
      final valueComparator = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GetFilterRulesResponse': {
            '_jsns': 'urn:zimbraMail',
            'filterRules': [
              {
                'filterRule': [
                  {
                    'name': name,
                    'active': active,
                    'filterVariables': [
                      {
                        'index': index,
                        'filterVariable': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'filterTests': [
                      {
                        'condition': FilterCondition.allof.name,
                        'addressBookTest': [
                          {
                            'header': header,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'addressTest': [
                          {
                            'header': header,
                            'part': AddressPart.all.name,
                            'stringComparison': StringComparison.contains.name,
                            'caseSensitive': caseSensitive,
                            'value': value,
                            'valueComparison': ValueComparison.equal.name,
                            'countComparison': CountComparison.equal.name,
                            'valueComparisonComparator': ComparisonComparator.asciiNumeric.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'envelopeTest': [
                          {
                            'header': header,
                            'part': AddressPart.all.name,
                            'stringComparison': StringComparison.contains.name,
                            'caseSensitive': caseSensitive,
                            'value': value,
                            'valueComparison': ValueComparison.equal.name,
                            'countComparison': CountComparison.equal.name,
                            'valueComparisonComparator': ComparisonComparator.asciiNumeric.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'attachmentTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'bodyTest': [
                          {
                            'value': value,
                            'caseSensitive': caseSensitive,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'bulkTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'contactRankingTest': [
                          {
                            'header': header,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'conversationTest': [
                          {
                            'where': WhereSetting.started.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'currentDayOfWeekTest': [
                          {
                            'value': value,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'currentTimeTest': [
                          {
                            'dateComparison': DateComparison.before.name,
                            'time': time,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'dateTest': [
                          {
                            'dateComparison': DateComparison.before.name,
                            'date': date,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'facebookTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'flaggedTest': [
                          {
                            'flagName': FilterFlagName.flagged.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'headerExistsTest': [
                          {
                            'header': header,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'headerTest': [
                          {
                            'header': header,
                            'stringComparison': StringComparison.contains.name,
                            'valueComparison': ValueComparison.equal.name,
                            'countComparison': CountComparison.equal.name,
                            'valueComparisonComparator': ComparisonComparator.asciiNumeric.name,
                            'value': value,
                            'caseSensitive': caseSensitive,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'importanceTest': [
                          {
                            'imp': Importance.normal.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'inviteTest': [
                          {
                            'method': [
                              {'_content': method}
                            ],
                            'index': index,
                            'negative': negative,
                          },
                        ],
                        'linkedinTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'listTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'meTest': [
                          {
                            'header': header,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'mimeHeaderTest': [
                          {
                            'header': header,
                            'stringComparison': StringComparison.contains.name,
                            'value': value,
                            'caseSensitive': caseSensitive,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'sizeTest': [
                          {
                            'numberComparison': NumberComparison.over.name,
                            's': size,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'socialcastTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'trueTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'twitterTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'communityRequestsTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'communityContentTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'communityConnectionsTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                      }
                    ],
                    'filterActions': [
                      {
                        'filterVariables': [
                          {
                            'index': index,
                            'filterVariable': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'actionKeep': [
                          {
                            'index': index,
                          }
                        ],
                        'actionDiscard': [
                          {
                            'index': index,
                          }
                        ],
                        'actionFileInto': [
                          {
                            'folderPath': folder,
                            'copy': copy,
                            'index': index,
                          }
                        ],
                        'actionFlag': [
                          {
                            'flagName': FilterFlagName.flagged.name,
                            'index': index,
                          }
                        ],
                        'actionTag': [
                          {
                            'tagName': tag,
                            'index': index,
                          }
                        ],
                        'actionRedirect': [
                          {
                            'a': address,
                            'copy': copy,
                            'index': index,
                          }
                        ],
                        'actionReply': [
                          {
                            'content': {'_content': content},
                            'index': index,
                          }
                        ],
                        'actionNotify': [
                          {
                            'a': address,
                            'su': subject,
                            'maxBodySize': maxBodySize,
                            'content': {'_content': content},
                            'origHeaders': origHeaders,
                            'index': index,
                          }
                        ],
                        'actionRFCCompliantNotify': [
                          {
                            'from': from,
                            'importance': importance,
                            'options': options,
                            'message': message,
                            'method': {'_content': method},
                            'index': index,
                          }
                        ],
                        'actionStop': [
                          {
                            'index': index,
                          }
                        ],
                        'actionReject': [
                          {
                            '_content': content,
                            'index': index,
                          }
                        ],
                        'actionEreject': [
                          {
                            '_content': content,
                            'index': index,
                          }
                        ],
                        'actionLog': [
                          {
                            'level': LoggingLevel.info.name,
                            '_content': content,
                            'index': index,
                          }
                        ],
                        'actionAddheader': [
                          {
                            'headerName': {'_content': header},
                            'headerValue': {'_content': value},
                            'last': last,
                            'index': index,
                          }
                        ],
                        'actionDeleteheader': [
                          {
                            'last': last,
                            'offset': offset,
                            'test': {
                              'matchType': MatchType.value.name,
                              'countComparator': countComparator,
                              'valueComparator': valueComparator,
                              'relationalComparator': RelationalComparator.equal.name,
                              'comparator': ComparisonComparator.asciiNumeric.name,
                              'headerName': {'_content': header},
                              'headerValue': [
                                {'_content': value}
                              ],
                            },
                            'index': index,
                          }
                        ],
                        'actionReplaceheader': [
                          {
                            'newName': {'_content': name},
                            'newValue': {'_content': value},
                            'last': last,
                            'offset': offset,
                            'test': {
                              'matchType': MatchType.value.name,
                              'countComparator': countComparator,
                              'valueComparator': valueComparator,
                              'relationalComparator': RelationalComparator.equal.name,
                              'comparator': ComparisonComparator.asciiNumeric.name,
                              'headerName': {'_content': header},
                              'headerValue': [
                                {'_content': value}
                              ],
                            },
                            'index': index,
                          }
                        ],
                      }
                    ],
                    'nestedRule': {
                      'filterVariables': {
                        'index': index,
                        'filterVariable': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'filterTests': {
                        'condition': FilterCondition.allof.name,
                      },
                      'filterActions': {
                        'filterVariables': [
                          {
                            'index': index,
                            'filterVariable': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ]
                      },
                      'nestedRule': {'nestedRule': null},
                    },
                  }
                ]
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getFilterRules();
      final filterRule = response!.filterRules.first;

      expect(filterRule.name, name);
      expect(filterRule.active, active);

      final filterVariables = filterRule.filterVariables!;
      expect(filterVariables.index, index);
      expect(filterVariables.variables.first.name, name);
      expect(filterVariables.variables.first.value, value);

      final filterTests = filterRule.filterTests!;
      expect(filterTests.condition, FilterCondition.allof);

      final addressBookTest = filterTests.addressBookTests.first;
      expect(addressBookTest.header, header);
      expect(addressBookTest.index, index);
      expect(addressBookTest.negative, negative);

      final addressTest = filterTests.addressTests.first;
      expect(addressTest.header, header);
      expect(addressTest.part, AddressPart.all);
      expect(addressTest.stringComparison, StringComparison.contains);
      expect(addressTest.caseSensitive, caseSensitive);
      expect(addressTest.value, value);
      expect(addressTest.valueComparison, ValueComparison.equal);
      expect(addressTest.countComparison, CountComparison.equal);
      expect(addressTest.valueComparisonComparator, ComparisonComparator.asciiNumeric);
      expect(addressTest.index, index);
      expect(addressTest.negative, negative);

      final envelopeTest = filterTests.envelopeTests.first;
      expect(envelopeTest.header, header);
      expect(envelopeTest.part, AddressPart.all);
      expect(envelopeTest.stringComparison, StringComparison.contains);
      expect(envelopeTest.caseSensitive, caseSensitive);
      expect(addressTest.value, value);
      expect(envelopeTest.valueComparison, ValueComparison.equal);
      expect(envelopeTest.countComparison, CountComparison.equal);
      expect(envelopeTest.valueComparisonComparator, ComparisonComparator.asciiNumeric);
      expect(envelopeTest.index, index);
      expect(envelopeTest.negative, negative);

      final attachmentTest = filterTests.attachmentTests.first;
      expect(attachmentTest.index, index);
      expect(attachmentTest.negative, negative);

      final bodyTest = filterTests.bodyTests.first;
      expect(bodyTest.value, value);
      expect(bodyTest.caseSensitive, caseSensitive);
      expect(bodyTest.index, index);
      expect(bodyTest.negative, negative);

      final bulkTest = filterTests.bulkTests.first;
      expect(bulkTest.index, index);
      expect(bulkTest.negative, negative);

      final contactRankingTest = filterTests.contactRankingTests.first;
      expect(contactRankingTest.header, header);
      expect(contactRankingTest.index, index);
      expect(contactRankingTest.negative, negative);

      final conversationTest = filterTests.conversationTests.first;
      expect(conversationTest.where, WhereSetting.started);
      expect(conversationTest.index, index);
      expect(conversationTest.negative, negative);

      final currentDayOfWeekTest = filterTests.currentDayOfWeekTests.first;
      expect(currentDayOfWeekTest.values, value);
      expect(currentDayOfWeekTest.index, index);
      expect(currentDayOfWeekTest.negative, negative);

      final currentTimeTest = filterTests.currentTimeTests.first;
      expect(currentTimeTest.dateComparison, DateComparison.before);
      expect(currentTimeTest.time, time);
      expect(currentTimeTest.index, index);
      expect(currentTimeTest.negative, negative);

      final dateTest = filterTests.dateTests.first;
      expect(dateTest.dateComparison, DateComparison.before);
      expect(dateTest.date, date);
      expect(dateTest.index, index);
      expect(dateTest.negative, negative);

      final facebookTest = filterTests.facebookTests.first;
      expect(facebookTest.index, index);
      expect(facebookTest.negative, negative);

      final flaggedTest = filterTests.flaggedTests.first;
      expect(flaggedTest.flag, FilterFlagName.flagged);
      expect(flaggedTest.index, index);
      expect(flaggedTest.negative, negative);

      final headerExistsTest = filterTests.headerExistsTests.first;
      expect(headerExistsTest.header, header);
      expect(headerExistsTest.index, index);
      expect(headerExistsTest.negative, negative);

      final headerTest = filterTests.headerTests.first;
      expect(headerTest.headers, header);
      expect(headerTest.stringComparison, StringComparison.contains);
      expect(headerTest.valueComparison, ValueComparison.equal);
      expect(headerTest.countComparison, CountComparison.equal);
      expect(headerTest.valueComparisonComparator, ComparisonComparator.asciiNumeric);
      expect(headerTest.value, value);
      expect(headerTest.caseSensitive, caseSensitive);
      expect(headerTest.index, index);
      expect(headerTest.negative, negative);

      final importanceTest = filterTests.importanceTests.first;
      expect(importanceTest.importance, Importance.normal);
      expect(importanceTest.index, index);
      expect(importanceTest.negative, negative);

      final inviteTest = filterTests.inviteTests.first;
      expect(inviteTest.methods.first, method);
      expect(inviteTest.index, index);
      expect(inviteTest.negative, negative);

      final linkedinTest = filterTests.linkedinTests.first;
      expect(linkedinTest.index, index);
      expect(linkedinTest.negative, negative);

      final listTest = filterTests.listTests.first;
      expect(listTest.index, index);
      expect(listTest.negative, negative);

      final meTest = filterTests.meTests.first;
      expect(meTest.header, header);
      expect(meTest.index, index);
      expect(meTest.negative, negative);

      final mimeHeaderTest = filterTests.mimeHeaderTests.first;
      expect(mimeHeaderTest.headers, header);
      expect(mimeHeaderTest.stringComparison, StringComparison.contains);
      expect(mimeHeaderTest.value, value);
      expect(mimeHeaderTest.caseSensitive, caseSensitive);
      expect(mimeHeaderTest.index, index);
      expect(mimeHeaderTest.negative, negative);

      final sizeTest = filterTests.sizeTests.first;
      expect(sizeTest.numberComparison, NumberComparison.over);
      expect(sizeTest.size, size);
      expect(sizeTest.index, index);
      expect(sizeTest.negative, negative);

      final socialcastTest = filterTests.socialcastTests.first;
      expect(socialcastTest.index, index);
      expect(socialcastTest.negative, negative);

      final trueTest = filterTests.trueTests.first;
      expect(trueTest.index, index);
      expect(trueTest.negative, negative);

      final twitterTest = filterTests.twitterTests.first;
      expect(twitterTest.index, index);
      expect(twitterTest.negative, negative);

      final communityRequestsTest = filterTests.communityRequestsTests.first;
      expect(communityRequestsTest.index, index);
      expect(communityRequestsTest.negative, negative);

      final communityContentTest = filterTests.communityContentTests.first;
      expect(communityContentTest.index, index);
      expect(communityContentTest.negative, negative);

      final communityConnectionsTest = filterTests.communityConnectionsTests.first;
      expect(communityConnectionsTest.index, index);
      expect(communityConnectionsTest.negative, negative);

      final filterActions = filterRule.filterActions!;
      final filterVars = filterActions.filterVariables.first;
      expect(filterVars.index, index);
      expect(filterVars.variables.first.name, name);
      expect(filterVars.variables.first.value, value);

      final actionKeep = filterActions.keepActions.first;
      expect(actionKeep.index, index);

      final actionDiscard = filterActions.discardActions.first;
      expect(actionDiscard.index, index);

      final actionFileInto = filterActions.fileIntoActions.first;
      expect(actionFileInto.folder, folder);
      expect(actionFileInto.copy, copy);
      expect(actionFileInto.index, index);

      final actionFlag = filterActions.flagActions.first;
      expect(actionFlag.flag, FilterFlagName.flagged);
      expect(actionFlag.index, index);

      final actionTag = filterActions.tagActions.first;
      expect(actionTag.tag, tag);
      expect(actionTag.index, index);

      final actionRedirect = filterActions.redirectActions.first;
      expect(actionRedirect.address, address);
      expect(actionRedirect.copy, copy);
      expect(actionRedirect.index, index);

      final actionReply = filterActions.replyActions.first;
      expect(actionReply.content, content);
      expect(actionReply.index, index);

      final actionNotify = filterActions.notifyActions.first;
      expect(actionNotify.address, address);
      expect(actionNotify.subject, subject);
      expect(actionNotify.maxBodySize, maxBodySize);
      expect(actionNotify.content, content);
      expect(actionNotify.origHeaders, origHeaders);
      expect(actionNotify.index, index);

      final actionRFC = filterActions.rfcCompliantNotifyActions.first;
      expect(actionRFC.from, from);
      expect(actionRFC.importance, importance);
      expect(actionRFC.options, options);
      expect(actionRFC.message, message);
      expect(actionRFC.method, method);
      expect(actionRFC.index, index);

      final actionStop = filterActions.stopActions.first;
      expect(actionStop.index, index);

      final actionReject = filterActions.rejectActions.first;
      expect(actionReject.content, content);
      expect(actionReject.index, index);

      final actionEreject = filterActions.erejectActions.first;
      expect(actionEreject.content, content);
      expect(actionEreject.index, index);

      final actionLog = filterActions.logActions.first;
      expect(actionLog.level, LoggingLevel.info);
      expect(actionLog.content, content);
      expect(actionLog.index, index);

      final actionAddheader = filterActions.addheaderActions.first;
      expect(actionAddheader.headerName, header);
      expect(actionAddheader.headerValue, value);
      expect(actionAddheader.last, last);
      expect(actionAddheader.index, index);

      final actionDeleteheader = filterActions.deleteheaderActions.first;
      expect(actionDeleteheader.last, last);
      expect(actionDeleteheader.offset, offset);
      expect(actionDeleteheader.index, index);

      final testDeleteheader = actionDeleteheader.test!;
      expect(testDeleteheader.matchType, MatchType.value);
      expect(testDeleteheader.countComparator, countComparator);
      expect(testDeleteheader.valueComparator, valueComparator);
      expect(testDeleteheader.relationalComparator, RelationalComparator.equal);
      expect(testDeleteheader.comparator, ComparisonComparator.asciiNumeric);
      expect(testDeleteheader.headerName, header);
      expect(testDeleteheader.headerValue.first, value);

      final actionReplaceheader = filterActions.replaceheaderActions.first;
      expect(actionReplaceheader.newName, name);
      expect(actionReplaceheader.newValue, value);
      expect(actionReplaceheader.last, last);
      expect(actionReplaceheader.offset, offset);
      expect(actionReplaceheader.index, index);

      final testReplaceheader = actionReplaceheader.test!;
      expect(testReplaceheader.matchType, MatchType.value);
      expect(testReplaceheader.countComparator, countComparator);
      expect(testReplaceheader.valueComparator, valueComparator);
      expect(testReplaceheader.relationalComparator, RelationalComparator.equal);
      expect(testReplaceheader.comparator, ComparisonComparator.asciiNumeric);
      expect(testReplaceheader.headerName, header);
      expect(testReplaceheader.headerValue.first, value);

      final nestedRule = filterRule.child!;
      expect(nestedRule.child, isNotNull);
      expect(nestedRule.child, isA<NestedRule>());

      final nestedFilterVars = nestedRule.filterVariables!;
      expect(nestedFilterVars.index, index);
      expect(nestedFilterVars.variables.first.name, name);
      expect(nestedFilterVars.variables.first.value, value);

      final nestedFilterTests = nestedRule.filterTests!;
      expect(nestedFilterTests.condition, FilterCondition.allof);

      final nestedFilterActions = nestedRule.filterActions!;
      final nestedFAFilterVars = nestedFilterActions.filterVariables.first;
      expect(nestedFAFilterVars.index, index);
      expect(nestedFAFilterVars.variables.first.name, name);
      expect(nestedFAFilterVars.variables.first.value, value);
    }));

    test('Get folder test', (() async {
      final id = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final absoluteFolderPath = faker.lorem.word();
      final parentId = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unreadCount = faker.randomGenerator.integer(100);
      final imapUnreadCount = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().minute;
      final itemCount = faker.randomGenerator.integer(100);
      final imapItemCount = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final imapModifiedSequence = faker.randomGenerator.integer(100);
      final imapUidNext = faker.randomGenerator.integer(100);
      final url = faker.internet.httpsUrl();
      final activeSyncDisabled = faker.randomGenerator.boolean();
      final webOfflineSyncDays = faker.randomGenerator.integer(100);
      final perm = faker.lorem.word();
      final recursive = faker.randomGenerator.boolean();
      final restUrl = faker.internet.httpsUrl();
      final deletable = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final lifetime = faker.randomGenerator.integer(100).toString();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);

      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();

      final ownerEmail = faker.internet.email();
      final ownerAccountId = faker.guid.guid();
      final remoteFolderId = faker.randomGenerator.integer(100);
      final remoteUuid = faker.guid.guid();
      final remoteFolderName = faker.lorem.word();
      final reminderEnabled = faker.randomGenerator.boolean();
      final broken = faker.randomGenerator.boolean();

      final query = faker.lorem.word();
      final types = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'GetFolderResponse': {
            '_jsns': 'urn:zimbraMail',
            'folder': [
              {
                'id': id,
                'uuid': uuid,
                'name': name,
                'absFolderPath': absoluteFolderPath,
                'l': parentId,
                'luuid': folderUuid,
                'f': flags,
                'color': color,
                'rgb': rgb,
                'u': unreadCount,
                'i4u': imapUnreadCount,
                'view': ViewType.conversation.name,
                'rev': revision,
                'ms': modifiedSequence,
                'md': changeDate,
                'n': itemCount,
                'i4n': imapItemCount,
                's': totalSize,
                'i4ms': imapModifiedSequence,
                'i4next': imapUidNext,
                'url': url,
                'activesyncdisabled': activeSyncDisabled,
                'webOfflineSyncDays': webOfflineSyncDays,
                'perm': perm,
                'recursive': recursive,
                'rest': restUrl,
                'deletable': deletable,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'acl': {
                  'internalGrantExpiry': internalGrantExpiry,
                  'guestGrantExpiry': guestGrantExpiry,
                  'grant': [
                    {
                      'perm': perm,
                      'gt': GrantGranteeType.all.name,
                      'zid': granteeId,
                      'expiry': expiry,
                      'd': granteeName,
                      'pw': guestPassword,
                      'key': accessKey,
                    }
                  ],
                },
                'folder': [
                  {
                    'id': id,
                    'uuid': uuid,
                    'name': name,
                  }
                ],
                'link': [
                  {
                    'id': id,
                    'name': name,
                    'owner': ownerEmail,
                    'zid': ownerAccountId,
                    'rid': remoteFolderId,
                    'ruuid': remoteUuid,
                    'oname': remoteFolderName,
                    'reminder': reminderEnabled,
                    'broken': broken,
                  }
                ],
                'search': [
                  {
                    'id': id,
                    'name': name,
                    'query': query,
                    'sortBy': SearchSortBy.none.name,
                    'types': types,
                  }
                ],
                'retentionPolicy': [
                  {
                    'keep': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                    'purge': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                  }
                ],
              }
            ],
            'link': [
              {
                'id': id,
                'name': name,
                'owner': ownerEmail,
                'zid': ownerAccountId,
                'rid': remoteFolderId,
                'ruuid': remoteUuid,
                'oname': remoteFolderName,
                'reminder': reminderEnabled,
                'broken': broken,
              }
            ],
            'search': [
              {
                'id': id,
                'name': name,
                'query': query,
                'sortBy': SearchSortBy.none.name,
                'types': types,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getFolder(GetFolderSpec());

      final folder = response!.folder!;
      expect(folder.id, id);
      expect(folder.uuid, uuid);
      expect(folder.name, name);
      expect(folder.absoluteFolderPath, absoluteFolderPath);
      expect(folder.parentId, parentId);
      expect(folder.folderUuid, folderUuid);
      expect(folder.flags, flags);
      expect(folder.color, color);
      expect(folder.rgb, rgb);
      expect(folder.unreadCount, unreadCount);
      expect(folder.imapUnreadCount, imapUnreadCount);
      expect(folder.view, ViewType.conversation);
      expect(folder.revision, revision);
      expect(folder.modifiedSequence, modifiedSequence);
      expect(folder.changeDate, changeDate);
      expect(folder.itemCount, itemCount);
      expect(folder.imapItemCount, imapItemCount);
      expect(folder.totalSize, totalSize);
      expect(folder.imapModifiedSequence, imapModifiedSequence);
      expect(folder.imapUidNext, imapUidNext);
      expect(folder.url, url);
      expect(folder.activeSyncDisabled, activeSyncDisabled);
      expect(folder.webOfflineSyncDays, webOfflineSyncDays);
      expect(folder.perm, perm);
      expect(folder.recursive, recursive);
      expect(folder.restUrl, restUrl);
      expect(folder.deletable, deletable);

      final meta = folder.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final acl = folder.acl!;
      expect(acl.internalGrantExpiry, internalGrantExpiry);
      expect(acl.guestGrantExpiry, guestGrantExpiry);

      final grant = acl.grants.first;
      expect(grant.perm, perm);
      expect(grant.granteeType, GrantGranteeType.all);
      expect(grant.granteeId, granteeId);
      expect(grant.expiry, expiry);
      expect(grant.granteeName, granteeName);
      expect(grant.guestPassword, guestPassword);
      expect(grant.accessKey, accessKey);

      final subFolder = folder.subFolders.first;
      expect(subFolder.id, id);
      expect(subFolder.uuid, uuid);
      expect(subFolder.name, name);
      expect(subFolder, isA<Folder>());

      final link = folder.mountpoints.first;
      expect(link.id, id);
      expect(link.name, name);
      expect(link.ownerEmail, ownerEmail);
      expect(link.ownerAccountId, ownerAccountId);
      expect(link.remoteFolderId, remoteFolderId);
      expect(link.remoteUuid, remoteUuid);
      expect(link.remoteFolderName, remoteFolderName);
      expect(link.reminderEnabled, reminderEnabled);
      expect(link.broken, broken);
      expect(link, isA<Folder>());

      final search = folder.searchFolders.first;
      expect(search.id, id);
      expect(search.name, name);
      expect(search.query, query);
      expect(search.sortBy, SearchSortBy.none);
      expect(search.types, types);
      expect(search, isA<Folder>());

      final retentionPolicy = folder.retentionPolicy!;
      final keep = retentionPolicy.keep.first;
      final purge = retentionPolicy.purge.first;
      expect(keep.type, PolicyType.user);
      expect(keep.id, id);
      expect(keep.name, name);
      expect(keep.lifetime, lifetime);
      expect(purge.type, PolicyType.user);
      expect(purge.id, id);
      expect(purge.name, name);
      expect(purge.lifetime, lifetime);

      final mountpoint = response.mountpoint!;
      expect(mountpoint.id, id);
      expect(mountpoint.name, name);
      expect(mountpoint.ownerEmail, ownerEmail);
      expect(mountpoint.ownerAccountId, ownerAccountId);
      expect(mountpoint.remoteFolderId, remoteFolderId);
      expect(mountpoint.remoteUuid, remoteUuid);
      expect(mountpoint.remoteFolderName, remoteFolderName);
      expect(mountpoint.reminderEnabled, reminderEnabled);
      expect(mountpoint.broken, broken);
      expect(mountpoint, isA<Folder>());

      final searchFolder = response.searchFolder!;
      expect(searchFolder.id, id);
      expect(searchFolder.name, name);
      expect(searchFolder.query, query);
      expect(searchFolder.sortBy, SearchSortBy.none);
      expect(searchFolder.types, types);
      expect(searchFolder, isA<Folder>());
    }));

    test('Get Free/Busy test', (() async {
      final id = faker.guid.guid();
      final startTime = faker.date.dateTime().millisecondsSinceEpoch;
      final endTime = faker.date.dateTime().millisecondsSinceEpoch;
      final eventId = faker.guid.guid();
      final subject = faker.lorem.word();
      final location = faker.lorem.word();
      final isMeeting = faker.randomGenerator.boolean();
      final isRecurring = faker.randomGenerator.boolean();
      final isException = faker.randomGenerator.boolean();
      final isReminderSet = faker.randomGenerator.boolean();
      final isPrivate = faker.randomGenerator.boolean();
      final hasPermission = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GetFreeBusyResponse': {
            '_jsns': 'urn:zimbraMail',
            'usr': [
              {
                'id': id,
                'f': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
                'b': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
                't': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
                'u': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
                'n': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getFreeBusy(0, 0);
      final usr = response!.freebusyUsers.first;

      expect(usr.id, id);

      final free = usr.freeSlots.first;
      expect(free.startTime, startTime);
      expect(free.endTime, endTime);
      expect(free.eventId, eventId);
      expect(free.subject, subject);
      expect(free.location, location);
      expect(free.isMeeting, isMeeting);
      expect(free.isRecurring, isRecurring);
      expect(free.isException, isException);
      expect(free.isReminderSet, isReminderSet);
      expect(free.isPrivate, isPrivate);
      expect(free.hasPermission, hasPermission);

      final busy = usr.busySlots.first;
      expect(busy.startTime, startTime);
      expect(busy.endTime, endTime);
      expect(busy.eventId, eventId);
      expect(busy.subject, subject);
      expect(busy.location, location);
      expect(busy.isMeeting, isMeeting);
      expect(busy.isRecurring, isRecurring);
      expect(busy.isException, isException);
      expect(busy.isReminderSet, isReminderSet);
      expect(busy.isPrivate, isPrivate);
      expect(busy.hasPermission, hasPermission);

      final tentative = usr.tentativeSlots.first;
      expect(tentative.startTime, startTime);
      expect(tentative.endTime, endTime);
      expect(tentative.eventId, eventId);
      expect(tentative.subject, subject);
      expect(tentative.location, location);
      expect(tentative.isMeeting, isMeeting);
      expect(tentative.isRecurring, isRecurring);
      expect(tentative.isException, isException);
      expect(tentative.isReminderSet, isReminderSet);
      expect(tentative.isPrivate, isPrivate);
      expect(tentative.hasPermission, hasPermission);

      final unavailable = usr.unavailableSlots.first;
      expect(unavailable.startTime, startTime);
      expect(unavailable.endTime, endTime);
      expect(unavailable.eventId, eventId);
      expect(unavailable.subject, subject);
      expect(unavailable.location, location);
      expect(unavailable.isMeeting, isMeeting);
      expect(unavailable.isRecurring, isRecurring);
      expect(unavailable.isException, isException);
      expect(unavailable.isReminderSet, isReminderSet);
      expect(unavailable.isPrivate, isPrivate);
      expect(unavailable.hasPermission, hasPermission);

      final nodata = usr.nodataSlots.first;
      expect(nodata.startTime, startTime);
      expect(nodata.endTime, endTime);
      expect(nodata.eventId, eventId);
      expect(nodata.subject, subject);
      expect(nodata.location, location);
      expect(nodata.isMeeting, isMeeting);
      expect(nodata.isRecurring, isRecurring);
      expect(nodata.isException, isException);
      expect(nodata.isReminderSet, isReminderSet);
      expect(nodata.isPrivate, isPrivate);
      expect(nodata.hasPermission, hasPermission);
    }));

    test('Get iCalendar test', (() async {
      final id = faker.guid.guid();
      final ical = faker.lorem.word();
      final data = {
        'Body': {
          'GetICalResponse': {
            '_jsns': 'urn:zimbraMail',
            'ical': {
              'id': id,
              '_content': ical,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getICal();
      final content = response!.content!;

      expect(content.id, id);
      expect(content.ical, ical);
    }));

    test('Get IMAP recent cutoff test', (() async {
      final cutoff = faker.randomGenerator.integer(100);
      final data = {
        'Body': {
          'GetIMAPRecentCutoffResponse': {
            '_jsns': 'urn:zimbraMail',
            'cutoff': cutoff,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getIMAPRecentCutoff(faker.guid.guid());
      expect(response!.cutoff, cutoff);
    }));

    test('Get IMAP recent test', (() async {
      final num = faker.randomGenerator.integer(100);
      final data = {
        'Body': {
          'GetIMAPRecentResponse': {
            '_jsns': 'urn:zimbraMail',
            'n': num,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getIMAPRecent(faker.guid.guid());
      expect(response!.num, num);
    }));

    test('Get import status test', (() async {
      final id = faker.guid.guid();
      final isRunning = faker.randomGenerator.boolean();
      final success = faker.randomGenerator.boolean();
      final error = faker.lorem.word();

      final data = {
        'Body': {
          'GetImportStatusResponse': {
            '_jsns': 'urn:zimbraMail',
            'imap': [
              {
                'id': id,
                'isRunning': isRunning,
                'success': success,
                'error': error,
              }
            ],
            'pop3': [
              {
                'id': id,
                'isRunning': isRunning,
                'success': success,
                'error': error,
              }
            ],
            'caldav': [
              {
                'id': id,
                'isRunning': isRunning,
                'success': success,
                'error': error,
              }
            ],
            'yab': [
              {
                'id': id,
                'isRunning': isRunning,
                'success': success,
                'error': error,
              }
            ],
            'rss': [
              {
                'id': id,
                'isRunning': isRunning,
                'success': success,
                'error': error,
              }
            ],
            'gal': [
              {
                'id': id,
                'isRunning': isRunning,
                'success': success,
                'error': error,
              }
            ],
            'cal': [
              {
                'id': id,
                'isRunning': isRunning,
                'success': success,
                'error': error,
              }
            ],
            'unknown': [
              {
                'id': id,
                'isRunning': isRunning,
                'success': success,
                'error': error,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getImportStatus();

      final imap = response!.imapStatuses.first;
      expect(imap.id, id);
      expect(imap.isRunning, isRunning);
      expect(imap.success, success);
      expect(imap.error, error);

      final pop3 = response.pop3Statuses.first;
      expect(pop3.id, id);
      expect(pop3.isRunning, isRunning);
      expect(pop3.success, success);
      expect(pop3.error, error);

      final caldav = response.caldavStatuses.first;
      expect(caldav.id, id);
      expect(caldav.isRunning, isRunning);
      expect(caldav.success, success);
      expect(caldav.error, error);

      final yab = response.yabStatuses.first;
      expect(yab.id, id);
      expect(yab.isRunning, isRunning);
      expect(yab.success, success);
      expect(yab.error, error);

      final rss = response.rssStatuses.first;
      expect(rss.id, id);
      expect(rss.isRunning, isRunning);
      expect(rss.success, success);
      expect(rss.error, error);

      final gal = response.galStatuses.first;
      expect(gal.id, id);
      expect(gal.isRunning, isRunning);
      expect(gal.success, success);
      expect(gal.error, error);

      final cal = response.calStatuses.first;
      expect(cal.id, id);
      expect(cal.isRunning, isRunning);
      expect(cal.success, success);
      expect(cal.error, error);

      final unknown = response.unknownStatuses.first;
      expect(unknown.id, id);
      expect(unknown.isRunning, isRunning);
      expect(unknown.success, success);
      expect(unknown.error, error);
    }));

    test('Get item test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final absoluteFolderPath = faker.lorem.word();
      final parentId = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unreadCount = faker.randomGenerator.integer(100);
      final imapUnreadCount = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final version = faker.randomGenerator.integer(100);
      final modifiedSequence = faker.randomGenerator.integer(100);
      final metadataVersion = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().minute;
      final itemCount = faker.randomGenerator.integer(100);
      final imapItemCount = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final imapModifiedSequence = faker.randomGenerator.integer(100);
      final imapUidNext = faker.randomGenerator.integer(100);
      final url = faker.internet.httpsUrl();
      final activeSyncDisabled = faker.randomGenerator.boolean();
      final webOfflineSyncDays = faker.randomGenerator.integer(100);
      final perm = faker.lorem.word();
      final recursive = faker.randomGenerator.boolean();
      final restUrl = faker.internet.httpsUrl();
      final deletable = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final lifetime = faker.randomGenerator.integer(100).toString();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);

      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();

      final ownerEmail = faker.internet.email();
      final ownerAccountId = faker.guid.guid();
      final remoteFolderId = faker.randomGenerator.integer(100);
      final remoteUuid = faker.guid.guid();
      final remoteFolderName = faker.lorem.word();
      final reminderEnabled = faker.randomGenerator.boolean();
      final broken = faker.randomGenerator.boolean();

      final query = faker.lorem.word();
      final types = faker.lorem.words(3).join(',');

      final unread = faker.randomGenerator.integer(100);
      final count = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;

      final folder = faker.guid.guid();
      final folderId = faker.guid.guid();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final bounds = faker.lorem.word();
      final content = faker.lorem.word();

      final sortField = faker.lorem.word();
      final canExpand = faker.randomGenerator.boolean();
      final imapUid = faker.randomGenerator.integer(100);
      final modifiedSequenceId = faker.randomGenerator.integer(100);
      final revisionId = faker.randomGenerator.integer(100);
      final fileAs = faker.lorem.word();
      final email = faker.internet.email();
      final email2 = faker.internet.email();
      final email3 = faker.internet.email();
      final type = faker.lorem.word();
      final dlist = faker.lorem.word();
      final reference = faker.lorem.word();
      final tooManyMembers = faker.randomGenerator.boolean();
      final memberOf = faker.internet.email();

      final part = faker.lorem.word();
      final contentType = faker.lorem.word();
      final size = faker.randomGenerator.integer(100);
      final contentFilename = faker.lorem.word();

      final nextAlarm = faker.date.dateTime().millisecondsSinceEpoch;
      final orphan = faker.randomGenerator.boolean();

      final sequence = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);
      final recurrenceId = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.lorem.word();
      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final subject = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final num = faker.randomGenerator.integer(100);
      final numUnread = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final contentDisposition = faker.lorem.word();
      final contentId = faker.guid.guid();
      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();
      final elided = faker.randomGenerator.boolean();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();
      final descEnabled = faker.randomGenerator.boolean();

      final lastEditedBy = faker.lorem.word();
      final creator = faker.lorem.word();
      final createdDate = faker.date.dateTime().millisecondsSinceEpoch;
      final lockOwnerId = faker.guid.guid();
      final lockOwnerEmail = faker.internet.email();
      final lockOwnerTimestamp = faker.date.dateTime().toString();
      final autoSendTime = faker.randomGenerator.integer(100);
      final conversationId = faker.guid.guid();

      final data = {
        'Body': {
          'GetItemResponse': {
            '_jsns': 'urn:zimbraMail',
            'folder': {
              'id': id,
              'uuid': uuid,
              'name': name,
              'absFolderPath': absoluteFolderPath,
              'l': parentId,
              'luuid': folderUuid,
              'f': flags,
              'color': color,
              'rgb': rgb,
              'u': unreadCount,
              'i4u': imapUnreadCount,
              'view': ViewType.conversation.name,
              'rev': revision,
              'ms': modifiedSequence,
              'md': changeDate,
              'n': itemCount,
              'i4n': imapItemCount,
              's': totalSize,
              'i4ms': imapModifiedSequence,
              'i4next': imapUidNext,
              'url': url,
              'activesyncdisabled': activeSyncDisabled,
              'webOfflineSyncDays': webOfflineSyncDays,
              'perm': perm,
              'recursive': recursive,
              'rest': restUrl,
              'deletable': deletable,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'acl': {
                'internalGrantExpiry': internalGrantExpiry,
                'guestGrantExpiry': guestGrantExpiry,
                'grant': [
                  {
                    'perm': perm,
                    'gt': GrantGranteeType.all.name,
                    'zid': granteeId,
                    'expiry': expiry,
                    'd': granteeName,
                    'pw': guestPassword,
                    'key': accessKey,
                  }
                ],
              },
              'folder': [
                {
                  'id': id,
                  'uuid': uuid,
                  'name': name,
                }
              ],
              'link': [
                {
                  'id': id,
                  'name': name,
                  'owner': ownerEmail,
                  'zid': ownerAccountId,
                  'rid': remoteFolderId,
                  'ruuid': remoteUuid,
                  'oname': remoteFolderName,
                  'reminder': reminderEnabled,
                  'broken': broken,
                }
              ],
              'search': [
                {
                  'id': id,
                  'name': name,
                  'query': query,
                  'sortBy': SearchSortBy.none.name,
                  'types': types,
                }
              ],
              'retentionPolicy': [
                {
                  'keep': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                  'purge': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                }
              ],
            },
            'tag': {
              'id': id,
              'name': name,
              'color': color,
              'rgb': rgb,
              'u': unread,
              'n': count,
              'd': date,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'retentionPolicy': [
                {
                  'keep': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                  'purge': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                }
              ],
            },
            'note': {
              'id': id,
              'rev': revision,
              'l': folder,
              'd': date,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'pos': bounds,
              'color': color,
              'rgb': rgb,
              'md': changeDate,
              'ms': modifiedSequence,
              'content': content,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
            'cn': {
              'sf': sortField,
              'exp': canExpand,
              'id': id,
              'i4uid': imapUid,
              'l': folder,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'md': changeDate,
              'ms': modifiedSequenceId,
              'd': date,
              'rev': revisionId,
              'fileAsStr': fileAs,
              'email': email,
              'email2': email2,
              'email3': email3,
              'type': type,
              'dlist': dlist,
              'ref': reference,
              'tooManyMembers': tooManyMembers,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              '_attrs': {
                key: value,
              },
              'm': [
                {
                  'type': MemberType.contact.name,
                  '_content': value,
                  'cn': {
                    'sf': sortField,
                    'exp': canExpand,
                    'id': id,
                    'i4uid': imapUid,
                    'l': folder,
                    'f': flags,
                    't': tags,
                    'tn': tagNames,
                    'md': changeDate,
                    'ms': modifiedSequenceId,
                    'd': date,
                    'rev': revisionId,
                    'fileAsStr': fileAs,
                    'email': email,
                    'email2': email2,
                    'email3': email3,
                    'type': type,
                    'dlist': dlist,
                    'ref': reference,
                    'tooManyMembers': tooManyMembers,
                    'memberOf': {'_content': memberOf},
                  },
                }
              ],
              'memberOf': {'_content': memberOf},
            },
            'appt': {
              'f': flags,
              't': tags,
              'tn': tagNames,
              'uid': uid,
              'id': id,
              'rev': revision,
              's': size,
              'd': date,
              'l': folder,
              'md': changeDate,
              'ms': modifiedSequence,
              'nextAlarm': nextAlarm,
              'orphan': orphan,
              'inv': [
                {
                  'type': InviteType.appt.name,
                  'seq': sequence,
                  'id': id,
                  'compNum': componentNum,
                  'recurId': recurrenceId,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'comp': {
                    'category': [
                      {'_content': category}
                    ],
                    'comment': [
                      {'_content': comment}
                    ],
                    'contact': [
                      {'_content': contact}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'alarm': [
                      {
                        'action': AlarmAction.display.name,
                        'trigger': {
                          'abs': {
                            'd': dateTimeString,
                          },
                          'rel': {
                            'd': dateTimeString,
                          },
                        },
                        'repeat': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': AlarmRelated.start.name,
                          'count': repeatCount,
                        },
                        'desc': {'_content': description},
                        'attach': {
                          'uri': uri,
                          'ct': contentType,
                          '_content': binaryB64Data,
                        },
                        'summary': {'_content': summary},
                        'at': [
                          {
                            'a': address,
                            'url': url,
                            'd': displayName,
                            'sentBy': sentBy,
                            'dir': dir,
                            'lang': language,
                            'cutype': cuType,
                            'role': role,
                            'ptst': partStat.name,
                            'rsvp': rsvp,
                            'member': member,
                            'delegatedTo': delegatedTo,
                            'delegatedFrom': delegatedFrom,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'xprop': [
                          {
                            'name': name,
                            'value': value,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'fr': fragment,
                    'desc': {'_content': description},
                    'descHtml': {'_content': htmlDescription},
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'recur': {
                      'add': [
                        {'add': {}}
                      ],
                      'exclude': [
                        {'exclude': {}}
                      ],
                      'except': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                          'add': {'add': []},
                          'exclude': {'exclude': []},
                        }
                      ],
                      'cancel': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ],
                      'dates': [
                        {
                          'tz': timezone,
                          'dtval': [
                            {
                              's': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'e': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'dur': {
                                'neg': durationNegative,
                                'w': weeks,
                                'd': days,
                                'h': hours,
                                'm': minutes,
                                's': seconds,
                                'related': AlarmRelated.start.name,
                                'count': repeatCount,
                              },
                            }
                          ],
                        }
                      ],
                      'rule': [
                        {
                          'freq': Frequency.second.name,
                          'until': {
                            'd': dateTimeString,
                          },
                          'count': {
                            'num': num,
                          },
                          'interval': {
                            'ival': ival,
                          },
                          'bysecond': {
                            'seclist': list,
                          },
                          'byminute': {
                            'minlist': list,
                          },
                          'byhour': {
                            'hrlist': list,
                          },
                          'byday': {
                            'wkday': [
                              {
                                'day': WeekDay.sunday.name,
                                'ordWk': ordWk,
                              }
                            ],
                          },
                          'bymonthday': {
                            'modaylist': list,
                          },
                          'byyearday': {
                            'yrdaylist': list,
                          },
                          'byweekno': {
                            'wklist': list,
                          },
                          'bymonth': {
                            'molist': list,
                          },
                          'bysetpos': {
                            'poslist': list,
                          },
                          'wkst': {
                            'day': WeekDay.sunday.name,
                          },
                          'rule-x-name': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    },
                    'exceptId': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'rangeType': recurrenceRangeType,
                    },
                    's': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'e': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'dur': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'method': method,
                    'compNum': componentNum,
                    'rsvp': rsvp,
                    'priority': priority,
                    'name': name,
                    'loc': location,
                    'percentComplete': percentComplete,
                    'completed': completed,
                    'noBlob': noBlob,
                    'fba': FreeBusyStatus.free.name,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'isOrg': isOrganizer,
                    'x_uid': xUid,
                    'uid': uid,
                    'seq': sequence,
                    'd': dateTime,
                    'calItemId': calItemId,
                    'apptId': deprecatedApptId,
                    'ciFolder': calItemFolder,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'url': url,
                    'ex': isException,
                    'ridZ': recurIdZ,
                    'allDay': isAllDay,
                    'draft': isDraft,
                    'neverSent': neverSent,
                    'changes': changes,
                  },
                  'mp': [
                    {
                      'part': part,
                      'ct': contentType,
                      's': size,
                      'cd': contentDisposition,
                      'filename': contentFilename,
                      'ci': contentId,
                      'cl': location,
                      'body': body,
                      'truncated': truncatedContent,
                      'content': content,
                      'mp': [
                        {
                          'part': part,
                          'ct': contentType,
                          's': size,
                          'cd': contentDisposition,
                          'filename': contentFilename,
                          'ci': contentId,
                          'cl': location,
                          'body': body,
                          'truncated': truncatedContent,
                          'content': content,
                        }
                      ],
                    }
                  ],
                  'shr': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                  'dlSubs': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                }
              ],
              'replies': {
                'reply': [
                  {
                    'rangeType': recurrenceRangeType,
                    'recurId': recurrenceId,
                    'seq': sequence,
                    'd': date,
                    'at': attendee,
                    'sentBy': sentBy,
                    'ptst': partStat.name,
                    'tz': timezone,
                    'ridZ': recurIdZ,
                  }
                ]
              },
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
            'task': {
              'f': flags,
              't': tags,
              'tn': tagNames,
              'uid': uid,
              'id': id,
              'rev': revision,
              's': size,
              'd': date,
              'l': folder,
              'md': changeDate,
              'ms': modifiedSequence,
              'nextAlarm': nextAlarm,
              'orphan': orphan,
            },
            'c': {
              'id': id,
              'n': num,
              'u': numUnread,
              'total': totalSize,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'd': date,
              'elided': elided,
              'md': changeDate,
              'ms': modifiedSequence,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'su': subject,
              'fr': fragment,
              'e': [
                {
                  'a': address,
                  'd': display,
                  'p': personal,
                  't': AddressType.from.name,
                  'isGroup': isGroup,
                  'exp': canExpandGroupMembers,
                }
              ],
            },
            'w': {
              'id': id,
              'uuid': uuid,
              'name': name,
              's': size,
              'd': date,
              'l': folderId,
              'luuid': folderUuid,
              'ms': modifiedSequence,
              'mdver': metadataVersion,
              'md': changeDate,
              'rev': revision,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'desc': description,
              'ct': contentType,
              'descEnabled': descEnabled,
              'ver': version,
              'leb': lastEditedBy,
              'cr': creator,
              'cd': createdDate,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'fr': fragment,
              'acl': {
                'internalGrantExpiry': internalGrantExpiry,
                'guestGrantExpiry': guestGrantExpiry,
                'grant': [
                  {
                    'perm': perm,
                    'gt': GrantGranteeType.all.name,
                    'zid': granteeId,
                    'expiry': expiry,
                    'd': granteeName,
                    'pw': guestPassword,
                    'key': accessKey,
                  }
                ],
              },
            },
            'doc': {
              'loid': lockOwnerId,
              'loe': lockOwnerEmail,
              'lt': lockOwnerTimestamp,
              'id': id,
              'uuid': uuid,
              'name': name,
              's': size,
              'd': date,
              'l': folderId,
              'luuid': folderUuid,
              'ms': modifiedSequence,
              'mdver': metadataVersion,
              'md': changeDate,
              'rev': revision,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'desc': description,
              'ct': contentType,
              'descEnabled': descEnabled,
              'ver': version,
              'leb': lastEditedBy,
              'cr': creator,
              'cd': createdDate,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'fr': fragment,
              'acl': {
                'internalGrantExpiry': internalGrantExpiry,
                'guestGrantExpiry': guestGrantExpiry,
                'grant': [
                  {
                    'perm': perm,
                    'gt': GrantGranteeType.all.name,
                    'zid': granteeId,
                    'expiry': expiry,
                    'd': granteeName,
                    'pw': guestPassword,
                    'key': accessKey,
                  }
                ],
              },
            },
            'm': {
              'id': id,
              'autoSendTime': autoSendTime,
              'e': [
                {
                  'a': address,
                  'd': display,
                  'p': personal,
                  't': AddressType.from.name,
                  'isGroup': isGroup,
                  'exp': canExpandGroupMembers,
                }
              ],
              'su': subject,
              'fr': fragment,
              'inv': {
                'type': InviteType.appt.name,
                'tz': [
                  {
                    'id': id,
                    'stdoff': tzStdOffset,
                    'dayoff': tzDayOffset,
                    'standard': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'daylight': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'stdname': standardTZName,
                    'dayname': daylightTZName,
                  }
                ],
                'comp': {
                  'category': [
                    {'_content': category}
                  ],
                  'comment': [
                    {'_content': comment}
                  ],
                  'contact': [
                    {'_content': contact}
                  ],
                  'geo': {
                    'lat': latitude,
                    'lon': longitude,
                  },
                  'at': [
                    {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'cutype': cuType,
                      'role': role,
                      'ptst': partStat.name,
                      'rsvp': rsvp,
                      'member': member,
                      'delegatedTo': delegatedTo,
                      'delegatedFrom': delegatedFrom,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    }
                  ],
                  'alarm': [
                    {
                      'action': AlarmAction.display.name,
                      'trigger': {
                        'abs': {
                          'd': dateTimeString,
                        },
                        'rel': {
                          'd': dateTimeString,
                        },
                      },
                      'repeat': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'desc': {'_content': description},
                      'attach': {
                        'uri': uri,
                        'ct': contentType,
                        '_content': binaryB64Data,
                      },
                      'summary': {'_content': summary},
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    }
                  ],
                  'xprop': [
                    {
                      'name': name,
                      'value': value,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    }
                  ],
                  'fr': fragment,
                  'desc': {'_content': description},
                  'descHtml': {'_content': htmlDescription},
                  'or': {
                    'a': address,
                    'url': url,
                    'd': displayName,
                    'sentBy': sentBy,
                    'dir': dir,
                    'lang': language,
                    'xparam': [
                      {
                        'name': name,
                        'value': value,
                      }
                    ],
                  },
                  'recur': {
                    'add': [
                      {'add': []}
                    ],
                    'exclude': [
                      {'exclude': []}
                    ],
                    'except': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                        'add': {'add': []},
                        'exclude': {'exclude': []},
                      }
                    ],
                    'cancel': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                    'dates': [
                      {
                        'tz': timezone,
                        'dtval': [
                          {
                            's': {
                              'd': dateTimeString,
                              'tz': timezone,
                              'u': utcTime,
                            },
                            'e': {
                              'd': dateTimeString,
                              'tz': timezone,
                              'u': utcTime,
                            },
                            'dur': {
                              'neg': durationNegative,
                              'w': weeks,
                              'd': days,
                              'h': hours,
                              'm': minutes,
                              's': seconds,
                              'related': AlarmRelated.start.name,
                              'count': repeatCount,
                            },
                          }
                        ],
                      }
                    ],
                    'rule': [
                      {
                        'freq': Frequency.second.name,
                        'until': {
                          'd': dateTimeString,
                        },
                        'count': {
                          'num': num,
                        },
                        'interval': {
                          'ival': ival,
                        },
                        'bysecond': {
                          'seclist': list,
                        },
                        'byminute': {
                          'minlist': list,
                        },
                        'byhour': {
                          'hrlist': list,
                        },
                        'byday': {
                          'wkday': [
                            {
                              'day': WeekDay.sunday.name,
                              'ordWk': ordWk,
                            }
                          ],
                        },
                        'bymonthday': {
                          'modaylist': list,
                        },
                        'byyearday': {
                          'yrdaylist': list,
                        },
                        'byweekno': {
                          'wklist': list,
                        },
                        'bymonth': {
                          'molist': list,
                        },
                        'bysetpos': {
                          'poslist': list,
                        },
                        'wkst': {
                          'day': WeekDay.sunday.name,
                        },
                        'rule-x-name': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                  'exceptId': {
                    'd': dateTimeString,
                    'tz': timezone,
                    'rangeType': recurrenceRangeType,
                  },
                  's': {
                    'd': dateTimeString,
                    'tz': timezone,
                    'u': utcTime,
                  },
                  'e': {
                    'd': dateTimeString,
                    'tz': timezone,
                    'u': utcTime,
                  },
                  'dur': {
                    'neg': durationNegative,
                    'w': weeks,
                    'd': days,
                    'h': hours,
                    'm': minutes,
                    's': seconds,
                    'related': AlarmRelated.start.name,
                    'count': repeatCount,
                  },
                  'method': method,
                  'compNum': componentNum,
                  'rsvp': rsvp,
                  'priority': priority,
                  'name': name,
                  'loc': location,
                  'percentComplete': percentComplete,
                  'completed': completed,
                  'noBlob': noBlob,
                  'fba': FreeBusyStatus.free.name,
                  'fb': FreeBusyStatus.free.name,
                  'transp': Transparency.opaque.name,
                  'isOrg': isOrganizer,
                  'x_uid': xUid,
                  'uid': uid,
                  'seq': sequence,
                  'd': dateTime,
                  'calItemId': calItemId,
                  'apptId': deprecatedApptId,
                  'ciFolder': calItemFolder,
                  'status': InviteStatus.completed.name,
                  'class': InviteClass.public.name,
                  'url': url,
                  'ex': isException,
                  'ridZ': recurIdZ,
                  'allDay': isAllDay,
                  'draft': isDraft,
                  'neverSent': neverSent,
                  'changes': changes,
                },
                'replies': {
                  'reply': [
                    {
                      'rangeType': recurrenceRangeType,
                      'recurId': recurrenceId,
                      'seq': seq,
                      'd': date,
                      'at': attendee,
                      'sentBy': sentBy,
                      'ptst': partStat.name,
                      'tz': timezone,
                      'ridZ': recurIdZ,
                    }
                  ]
                },
              },
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
            'chat': {
              'id': id,
              'autoSendTime': autoSendTime,
              'su': subject,
              'fr': fragment,
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getItem(ItemSpec());

      final folderItem = response!.folderItem!;
      expect(folderItem.id, id);
      expect(folderItem.uuid, uuid);
      expect(folderItem.name, name);
      expect(folderItem.absoluteFolderPath, absoluteFolderPath);
      expect(folderItem.parentId, parentId);
      expect(folderItem.folderUuid, folderUuid);
      expect(folderItem.flags, flags);
      expect(folderItem.color, color);
      expect(folderItem.rgb, rgb);
      expect(folderItem.unreadCount, unreadCount);
      expect(folderItem.imapUnreadCount, imapUnreadCount);
      expect(folderItem.view, ViewType.conversation);
      expect(folderItem.revision, revision);
      expect(folderItem.modifiedSequence, modifiedSequence);
      expect(folderItem.changeDate, changeDate);
      expect(folderItem.itemCount, itemCount);
      expect(folderItem.imapItemCount, imapItemCount);
      expect(folderItem.totalSize, totalSize);
      expect(folderItem.imapModifiedSequence, imapModifiedSequence);
      expect(folderItem.imapUidNext, imapUidNext);
      expect(folderItem.url, url);
      expect(folderItem.activeSyncDisabled, activeSyncDisabled);
      expect(folderItem.webOfflineSyncDays, webOfflineSyncDays);
      expect(folderItem.perm, perm);
      expect(folderItem.recursive, recursive);
      expect(folderItem.restUrl, restUrl);
      expect(folderItem.deletable, deletable);

      final folderMeta = folderItem.metadatas.first;
      expect(folderMeta.section, section);
      expect(folderMeta.keyValuePairs.first.key, key);
      expect(folderMeta.keyValuePairs.first.value, value);

      final folderAcl = folderItem.acl!;
      expect(folderAcl.internalGrantExpiry, internalGrantExpiry);
      expect(folderAcl.guestGrantExpiry, guestGrantExpiry);

      final folderGrant = folderAcl.grants.first;
      expect(folderGrant.perm, perm);
      expect(folderGrant.granteeType, GrantGranteeType.all);
      expect(folderGrant.granteeId, granteeId);
      expect(folderGrant.expiry, expiry);
      expect(folderGrant.granteeName, granteeName);
      expect(folderGrant.guestPassword, guestPassword);
      expect(folderGrant.accessKey, accessKey);

      final subFolder = folderItem.subFolders.first;
      expect(subFolder.id, id);
      expect(subFolder.uuid, uuid);
      expect(subFolder.name, name);
      expect(subFolder, isA<Folder>());

      final link = folderItem.mountpoints.first;
      expect(link.id, id);
      expect(link.name, name);
      expect(link.ownerEmail, ownerEmail);
      expect(link.ownerAccountId, ownerAccountId);
      expect(link.remoteFolderId, remoteFolderId);
      expect(link.remoteUuid, remoteUuid);
      expect(link.remoteFolderName, remoteFolderName);
      expect(link.reminderEnabled, reminderEnabled);
      expect(link.broken, broken);
      expect(link, isA<Folder>());

      final search = folderItem.searchFolders.first;
      expect(search.id, id);
      expect(search.name, name);
      expect(search.query, query);
      expect(search.sortBy, SearchSortBy.none);
      expect(search.types, types);
      expect(search, isA<Folder>());

      final folderRetentionPolicy = folderItem.retentionPolicy!;
      final folderKeep = folderRetentionPolicy.keep.first;
      final folderPurge = folderRetentionPolicy.purge.first;
      expect(folderKeep.type, PolicyType.user);
      expect(folderKeep.id, id);
      expect(folderKeep.name, name);
      expect(folderKeep.lifetime, lifetime);
      expect(folderPurge.type, PolicyType.user);
      expect(folderPurge.id, id);
      expect(folderPurge.name, name);
      expect(folderPurge.lifetime, lifetime);

      final tagItem = response.tagItem!;
      expect(tagItem.id, id);
      expect(tagItem.name, name);
      expect(tagItem.color, color);
      expect(tagItem.rgb, rgb);
      expect(tagItem.unread, unread);
      expect(tagItem.count, count);
      expect(tagItem.date, date);
      expect(tagItem.revision, revision);
      expect(tagItem.changeDate, changeDate);
      expect(tagItem.modifiedSequence, modifiedSequence);

      final tagMeta = tagItem.metadatas.first;
      expect(tagMeta.section, section);
      expect(tagMeta.keyValuePairs.first.key, key);
      expect(tagMeta.keyValuePairs.first.value, value);

      final tagRetentionPolicy = tagItem.retentionPolicy!;
      final tagKeep = tagRetentionPolicy.keep.first;
      final tagPurge = tagRetentionPolicy.purge.first;
      expect(tagKeep.type, PolicyType.user);
      expect(tagKeep.id, id);
      expect(tagKeep.name, name);
      expect(tagKeep.lifetime, lifetime);
      expect(tagPurge.type, PolicyType.user);
      expect(tagPurge.id, id);
      expect(tagPurge.name, name);
      expect(tagPurge.lifetime, lifetime);

      final noteItem = response.noteItem!;
      expect(noteItem.id, id);
      expect(noteItem.revision, revision);
      expect(noteItem.folder, folder);
      expect(noteItem.date, date);
      expect(noteItem.flags, flags);
      expect(noteItem.tags, tags);
      expect(noteItem.tagNames, tagNames);
      expect(noteItem.bounds, bounds);
      expect(noteItem.color, color);
      expect(noteItem.rgb, rgb);
      expect(noteItem.changeDate, changeDate);
      expect(noteItem.modifiedSequence, modifiedSequence);
      expect(noteItem.content, content);

      final noteMeta = noteItem.metadatas.first;
      expect(noteMeta.section, section);
      expect(noteMeta.keyValuePairs.first.key, key);
      expect(noteMeta.keyValuePairs.first.value, value);

      final contactItem = response.contactItem!;
      expect(contactItem.sortField, sortField);
      expect(contactItem.canExpand, canExpand);
      expect(contactItem.id, id);
      expect(contactItem.imapUid, imapUid);
      expect(contactItem.folder, folder);
      expect(contactItem.flags, flags);
      expect(contactItem.tags, tags);
      expect(contactItem.tagNames, tagNames);
      expect(contactItem.changeDate, changeDate);
      expect(contactItem.modifiedSequenceId, modifiedSequenceId);
      expect(contactItem.date, date);
      expect(contactItem.revisionId, revisionId);
      expect(contactItem.fileAs, fileAs);
      expect(contactItem.email, email);
      expect(contactItem.email2, email2);
      expect(contactItem.email3, email3);
      expect(contactItem.type, type);
      expect(contactItem.dlist, dlist);
      expect(contactItem.reference, reference);
      expect(contactItem.tooManyMembers, tooManyMembers);
      expect(contactItem.memberOf, memberOf);

      final contactMeta = contactItem.metadatas.first;
      expect(contactMeta.section, section);
      expect(contactMeta.keyValuePairs.first.key, key);
      expect(contactMeta.keyValuePairs.first.value, value);

      final contactAttr = contactItem.attrs.first;
      expect(contactAttr.key, key);
      expect(contactAttr.value, value);

      final contactMember = contactItem.contactGroupMembers.first;
      expect(contactMember.type, MemberType.contact);
      expect(contactMember.value, value);

      final cn = contactMember.contact!;
      expect(cn.sortField, sortField);
      expect(cn.canExpand, canExpand);
      expect(cn.id, id);
      expect(cn.imapUid, imapUid);
      expect(cn.folder, folder);
      expect(cn.flags, flags);
      expect(cn.tags, tags);
      expect(cn.tagNames, tagNames);
      expect(cn.changeDate, changeDate);
      expect(cn.modifiedSequenceId, modifiedSequenceId);
      expect(cn.date, date);
      expect(cn.revisionId, revisionId);
      expect(cn.fileAs, fileAs);
      expect(cn.email, email);
      expect(cn.email2, email2);
      expect(cn.email3, email3);
      expect(cn.type, type);
      expect(cn.dlist, dlist);
      expect(cn.reference, reference);
      expect(cn.tooManyMembers, tooManyMembers);
      expect(cn.memberOf, memberOf);

      final apptItem = response.apptItem!;
      expect(apptItem.flags, flags);
      expect(apptItem.tags, tags);
      expect(apptItem.tagNames, tagNames);
      expect(apptItem.uid, uid);
      expect(apptItem.id, id);
      expect(apptItem.revision, revision);
      expect(apptItem.size, size);
      expect(apptItem.date, date);
      expect(apptItem.folder, folder);
      expect(apptItem.changeDate, changeDate);
      expect(apptItem.modifiedSequence, modifiedSequence);
      expect(apptItem.nextAlarm, nextAlarm);
      expect(apptItem.orphan, orphan);

      final inv = apptItem.invites.first;
      expect(inv.calItemType, InviteType.appt);
      expect(inv.sequence, sequence);
      expect(inv.id, id);
      expect(inv.componentNum, componentNum);
      expect(inv.recurrenceId, recurrenceId);

      final invTz = inv.timezones.first;
      expect(invTz.id, id);
      expect(invTz.tzStdOffset, tzStdOffset);
      expect(invTz.tzDayOffset, tzDayOffset);
      expect(invTz.standardTZName, standardTZName);
      expect(invTz.daylightTZName, daylightTZName);

      final invTzStandard = invTz.standardTzOnset!;
      expect(invTzStandard.month, month);
      expect(invTzStandard.hour, hour);
      expect(invTzStandard.minute, minute);
      expect(invTzStandard.second, second);
      expect(invTzStandard.dayOfMonth, dayOfMonth);
      expect(invTzStandard.week, week);
      expect(invTzStandard.dayOfWeek, dayOfWeek);

      final invTzDaylight = invTz.daylightTzOnset!;
      expect(invTzDaylight.month, month);
      expect(invTzDaylight.hour, hour);
      expect(invTzDaylight.minute, minute);
      expect(invTzDaylight.second, second);
      expect(invTzDaylight.dayOfMonth, dayOfMonth);
      expect(invTzDaylight.week, week);
      expect(invTzDaylight.dayOfWeek, dayOfWeek);

      final partInfo = inv.partInfos.first;
      expect(partInfo.part, part);
      expect(partInfo.contentType, contentType);
      expect(partInfo.size, size);
      expect(partInfo.contentDisposition, contentDisposition);
      expect(partInfo.contentFilename, contentFilename);
      expect(partInfo.contentId, contentId);
      expect(partInfo.location, location);
      expect(partInfo.body, body);
      expect(partInfo.truncatedContent, truncatedContent);
      expect(partInfo.content, content);
      expect(partInfo.body, body);
      final mpPartInfo = partInfo.mimeParts.first;
      expect(mpPartInfo.part, part);
      expect(mpPartInfo.contentType, contentType);
      expect(mpPartInfo.size, size);
      expect(mpPartInfo.contentDisposition, contentDisposition);
      expect(mpPartInfo.contentFilename, contentFilename);
      expect(mpPartInfo.contentId, contentId);
      expect(mpPartInfo.location, location);
      expect(mpPartInfo.body, body);
      expect(mpPartInfo.truncatedContent, truncatedContent);
      expect(mpPartInfo.content, content);
      expect(mpPartInfo.body, body);

      final shr = inv.shareNotifications.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = inv.dlSubsNotifications.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final comp = inv.inviteComponent!;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);

      final apptReply = apptItem.calendarReplies.first;
      expect(apptReply.recurrenceRangeType, recurrenceRangeType);
      expect(apptReply.recurrenceId, recurrenceId);
      expect(apptReply.seq, sequence);
      expect(apptReply.date, date);
      expect(apptReply.attendee, attendee);
      expect(apptReply.sentBy, sentBy);
      expect(apptReply.partStat, partStat);
      expect(apptReply.timezone, timezone);
      expect(apptReply.recurIdZ, recurIdZ);

      final apptMeta = apptItem.metadatas.first;
      expect(apptMeta.section, section);
      expect(apptMeta.keyValuePairs.first.key, key);
      expect(apptMeta.keyValuePairs.first.value, value);

      final taskItem = response.taskItem!;
      expect(taskItem, isA<TaskItemInfo>());
      expect(taskItem, isA<CalendarItemInfo>());
      expect(taskItem.flags, flags);
      expect(taskItem.tags, tags);
      expect(taskItem.tagNames, tagNames);
      expect(taskItem.uid, uid);
      expect(taskItem.id, id);
      expect(taskItem.revision, revision);
      expect(taskItem.size, size);
      expect(taskItem.date, date);
      expect(taskItem.folder, folder);
      expect(taskItem.changeDate, changeDate);
      expect(taskItem.modifiedSequence, modifiedSequence);
      expect(taskItem.nextAlarm, nextAlarm);
      expect(taskItem.orphan, orphan);

      final convItem = response.convItem!;
      expect(convItem.id, id);
      expect(convItem.numMsg, num);
      expect(convItem.numUnread, numUnread);
      expect(convItem.totalSize, totalSize);
      expect(convItem.flags, flags);
      expect(convItem.tags, tags);
      expect(convItem.tagNames, tagNames);
      expect(convItem.date, date);
      expect(convItem.elided, elided);
      expect(convItem.changeDate, changeDate);
      expect(convItem.modifiedSequence, modifiedSequence);
      expect(convItem.subject, subject);
      expect(convItem.fragment, fragment);

      final convMeta = convItem.metadatas.first;
      expect(convMeta.section, section);
      expect(convMeta.keyValuePairs.first.key, key);
      expect(convMeta.keyValuePairs.first.value, value);

      final convEmail = convItem.emails.first;
      expect(convEmail.address, address);
      expect(convEmail.display, display);
      expect(convEmail.personal, personal);
      expect(convEmail.addressType, AddressType.from);
      expect(convEmail.isGroup, isGroup);
      expect(convEmail.canExpandGroupMembers, canExpandGroupMembers);

      final wikiItem = response.wikiItem!;
      expect(wikiItem.id, id);
      expect(wikiItem.uuid, uuid);
      expect(wikiItem.name, name);
      expect(wikiItem.size, size);
      expect(wikiItem.date, date);
      expect(wikiItem.folderId, folderId);
      expect(wikiItem.folderUuid, folderUuid);
      expect(wikiItem.modifiedSequence, modifiedSequence);
      expect(wikiItem.metadataVersion, metadataVersion);
      expect(wikiItem.changeDate, changeDate);
      expect(wikiItem.revision, revision);
      expect(wikiItem.flags, flags);
      expect(wikiItem.tags, tags);
      expect(wikiItem.tagNames, tagNames);
      expect(wikiItem.description, description);
      expect(wikiItem.contentType, contentType);
      expect(wikiItem.descEnabled, descEnabled);
      expect(wikiItem.version, version);
      expect(wikiItem.lastEditedBy, lastEditedBy);
      expect(wikiItem.creator, creator);
      expect(wikiItem.createdDate, createdDate);
      expect(wikiItem.fragment, fragment);

      final wikiMeta = wikiItem.metadatas.first;
      expect(wikiMeta.section, section);
      expect(wikiMeta.keyValuePairs.first.key, key);
      expect(wikiMeta.keyValuePairs.first.value, value);

      final wikiAcl = wikiItem.acl!;
      expect(wikiAcl.internalGrantExpiry, internalGrantExpiry);
      expect(wikiAcl.guestGrantExpiry, guestGrantExpiry);

      final wikiGrant = wikiAcl.grants.first;
      expect(wikiGrant.perm, perm);
      expect(wikiGrant.granteeType, GrantGranteeType.all);
      expect(wikiGrant.granteeId, granteeId);
      expect(wikiGrant.expiry, expiry);
      expect(wikiGrant.granteeName, granteeName);
      expect(wikiGrant.guestPassword, guestPassword);
      expect(wikiGrant.accessKey, accessKey);

      final docItem = response.docItem!;
      expect(docItem.lockOwnerId, lockOwnerId);
      expect(docItem.lockOwnerEmail, lockOwnerEmail);
      expect(docItem.lockOwnerTimestamp, lockOwnerTimestamp);
      expect(docItem.id, id);
      expect(docItem.uuid, uuid);
      expect(docItem.name, name);
      expect(docItem.size, size);
      expect(docItem.date, date);
      expect(docItem.folderId, folderId);
      expect(docItem.folderUuid, folderUuid);
      expect(docItem.modifiedSequence, modifiedSequence);
      expect(docItem.metadataVersion, metadataVersion);
      expect(docItem.changeDate, changeDate);
      expect(docItem.revision, revision);
      expect(docItem.flags, flags);
      expect(docItem.tags, tags);
      expect(docItem.tagNames, tagNames);
      expect(docItem.description, description);
      expect(docItem.contentType, contentType);
      expect(docItem.descEnabled, descEnabled);
      expect(docItem.version, version);
      expect(docItem.lastEditedBy, lastEditedBy);
      expect(docItem.creator, creator);
      expect(docItem.createdDate, createdDate);
      expect(docItem.fragment, fragment);

      final docMeta = docItem.metadatas.first;
      expect(docMeta.section, section);
      expect(docMeta.keyValuePairs.first.key, key);
      expect(docMeta.keyValuePairs.first.value, value);

      final docAcl = docItem.acl!;
      expect(docAcl.internalGrantExpiry, internalGrantExpiry);
      expect(docAcl.guestGrantExpiry, guestGrantExpiry);

      final docGrant = docAcl.grants.first;
      expect(docGrant.perm, perm);
      expect(docGrant.granteeType, GrantGranteeType.all);
      expect(docGrant.granteeId, granteeId);
      expect(docGrant.expiry, expiry);
      expect(docGrant.granteeName, granteeName);
      expect(docGrant.guestPassword, guestPassword);
      expect(docGrant.accessKey, accessKey);

      final msgItem = response.msgItem!;

      expect(msgItem.id, id);
      expect(msgItem.autoSendTime, autoSendTime);
      expect(msgItem.subject, subject);
      expect(msgItem.fragment, fragment);
      expect(msgItem.size, size);
      expect(msgItem.date, date);
      expect(msgItem.folder, folder);
      expect(msgItem.conversationId, conversationId);
      expect(msgItem.flags, flags);
      expect(msgItem.tags, tags);
      expect(msgItem.tagNames, tagNames);
      expect(msgItem.revision, revision);
      expect(msgItem.changeDate, changeDate);
      expect(msgItem.modifiedSequence, modifiedSequence);

      final msgEmail = msgItem.emails.first;
      expect(msgEmail.address, address);
      expect(msgEmail.display, display);
      expect(msgEmail.personal, personal);
      expect(msgEmail.addressType, AddressType.from);
      expect(msgEmail.isGroup, isGroup);
      expect(msgEmail.canExpandGroupMembers, canExpandGroupMembers);

      final msgMeta = msgItem.metadatas.first;
      expect(msgMeta.section, section);
      expect(msgMeta.keyValuePairs.first.key, key);
      expect(msgMeta.keyValuePairs.first.value, value);

      final msgInvite = msgItem.invite!;
      expect(msgInvite.calItemType, InviteType.appt);

      final msgTz = msgInvite.timezones.first;
      expect(msgTz.id, id);
      expect(msgTz.tzStdOffset, tzStdOffset);
      expect(msgTz.tzDayOffset, tzDayOffset);
      expect(msgTz.standardTZName, standardTZName);
      expect(msgTz.daylightTZName, daylightTZName);

      final msgStandardTzOnset = msgTz.standardTzOnset!;
      expect(msgStandardTzOnset.month, month);
      expect(msgStandardTzOnset.hour, hour);
      expect(msgStandardTzOnset.minute, minute);
      expect(msgStandardTzOnset.second, second);
      expect(msgStandardTzOnset.dayOfMonth, dayOfMonth);
      expect(msgStandardTzOnset.week, week);
      expect(msgStandardTzOnset.dayOfWeek, dayOfWeek);

      final msgDaylightTzOnset = msgTz.daylightTzOnset!;
      expect(msgDaylightTzOnset.month, month);
      expect(msgDaylightTzOnset.hour, hour);
      expect(msgDaylightTzOnset.minute, minute);
      expect(msgDaylightTzOnset.second, second);
      expect(msgDaylightTzOnset.dayOfMonth, dayOfMonth);
      expect(msgDaylightTzOnset.week, week);
      expect(msgDaylightTzOnset.dayOfWeek, dayOfWeek);

      final msgReply = msgInvite.calendarReplies.first;
      expect(msgReply.recurrenceRangeType, recurrenceRangeType);
      expect(msgReply.recurrenceId, recurrenceId);
      expect(msgReply.seq, seq);
      expect(msgReply.date, date);
      expect(msgReply.attendee, attendee);
      expect(msgReply.sentBy, sentBy);
      expect(msgReply.partStat, partStat);
      expect(msgReply.timezone, timezone);
      expect(msgReply.recurIdZ, recurIdZ);

      final msgInviteComponent = msgInvite.inviteComponent!;

      expect(msgInviteComponent.method, method);
      expect(msgInviteComponent.componentNum, componentNum);
      expect(msgInviteComponent.rsvp, rsvp);
      expect(msgInviteComponent.priority, priority);
      expect(msgInviteComponent.name, name);
      expect(msgInviteComponent.location, location);
      expect(msgInviteComponent.percentComplete, percentComplete);
      expect(msgInviteComponent.completed, completed);
      expect(msgInviteComponent.noBlob, noBlob);
      expect(msgInviteComponent.freeBusyActual, FreeBusyStatus.free);
      expect(msgInviteComponent.freeBusy, FreeBusyStatus.free);
      expect(msgInviteComponent.transparency, Transparency.opaque);
      expect(msgInviteComponent.isOrganizer, isOrganizer);
      expect(msgInviteComponent.xUid, xUid);
      expect(msgInviteComponent.uid, uid);
      expect(msgInviteComponent.sequence, sequence);
      expect(msgInviteComponent.dateTime, dateTime);
      expect(msgInviteComponent.calItemId, calItemId);
      expect(msgInviteComponent.deprecatedApptId, deprecatedApptId);
      expect(msgInviteComponent.calItemFolder, calItemFolder);
      expect(msgInviteComponent.status, InviteStatus.completed);
      expect(msgInviteComponent.calClass, InviteClass.public);
      expect(msgInviteComponent.url, url);
      expect(msgInviteComponent.isException, isException);
      expect(msgInviteComponent.recurIdZ, recurIdZ);
      expect(msgInviteComponent.isAllDay, isAllDay);
      expect(msgInviteComponent.isDraft, isDraft);
      expect(msgInviteComponent.neverSent, neverSent);
      expect(msgInviteComponent.changes, changes);

      expect(msgInviteComponent.fragment, fragment);
      expect(msgInviteComponent.description, description);
      expect(msgInviteComponent.htmlDescription, htmlDescription);

      expect(msgInviteComponent.categories.first, category);
      expect(msgInviteComponent.comments.first, comment);
      expect(msgInviteComponent.contacts.first, contact);

      final msgGeo = msgInviteComponent.geo!;
      expect(msgGeo.latitude, latitude);
      expect(msgGeo.longitude, longitude);

      final inviteAt = msgInviteComponent.attendees.first;
      expect(inviteAt.address, address);
      expect(inviteAt.url, url);
      expect(inviteAt.displayName, displayName);
      expect(inviteAt.sentBy, sentBy);
      expect(inviteAt.dir, dir);
      expect(inviteAt.language, language);
      expect(inviteAt.cuType, cuType);
      expect(inviteAt.role, role);
      expect(inviteAt.partStat, partStat);
      expect(inviteAt.rsvp, rsvp);
      expect(inviteAt.member, member);
      expect(inviteAt.delegatedTo, delegatedTo);
      expect(inviteAt.delegatedFrom, delegatedFrom);
      expect(inviteAt.xParams.first.name, name);
      expect(inviteAt.xParams.first.value, value);

      final msgAlarm = msgInviteComponent.alarms.first;
      expect(msgAlarm.action, AlarmAction.display);
      expect(msgAlarm.description, description);
      expect(msgAlarm.summary, summary);
      expect(msgAlarm.attach!.uri, uri);
      expect(msgAlarm.attach!.contentType, contentType);
      expect(msgAlarm.attach!.binaryB64Data, binaryB64Data);

      final msgAlarmAt = msgAlarm.attendees.first;
      expect(msgAlarmAt.address, address);
      expect(msgAlarmAt.url, url);
      expect(msgAlarmAt.displayName, displayName);
      expect(msgAlarmAt.sentBy, sentBy);
      expect(msgAlarmAt.dir, dir);
      expect(msgAlarmAt.language, language);
      expect(msgAlarmAt.cuType, cuType);
      expect(msgAlarmAt.role, role);
      expect(msgAlarmAt.partStat, partStat);
      expect(msgAlarmAt.rsvp, rsvp);
      expect(msgAlarmAt.member, member);
      expect(msgAlarmAt.delegatedTo, delegatedTo);
      expect(msgAlarmAt.delegatedFrom, delegatedFrom);
      expect(msgAlarmAt.xParams.first.name, name);
      expect(msgAlarmAt.xParams.first.value, value);

      final msgAlarmXProp = msgAlarm.xProps.first;
      expect(msgAlarmXProp.name, name);
      expect(msgAlarmXProp.value, value);
      expect(msgAlarmXProp.xParams.first.name, name);
      expect(msgAlarmXProp.xParams.first.value, value);

      final msgInviteXProp = msgInviteComponent.xProps.first;
      expect(msgInviteXProp.name, name);
      expect(msgInviteXProp.value, value);
      expect(msgInviteXProp.xParams.first.name, name);
      expect(msgInviteXProp.xParams.first.value, value);

      final msgOrganizer = msgInviteComponent.organizer!;
      expect(msgOrganizer.address, address);
      expect(msgOrganizer.url, url);
      expect(msgOrganizer.displayName, displayName);
      expect(msgOrganizer.sentBy, sentBy);
      expect(msgOrganizer.dir, dir);
      expect(msgOrganizer.language, language);
      expect(msgOrganizer.xParams.first.name, name);
      expect(msgOrganizer.xParams.first.value, value);

      final msgRecurrence = msgInviteComponent.recurrence!;
      expect(msgRecurrence.add.first, isA<AddRecurrenceInfo>());
      expect(msgRecurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final msgExcept = msgRecurrence.except.first;
      expect(msgExcept.recurrenceRangeType, recurrenceRangeType);
      expect(msgExcept.recurrenceId, recurrenceId);
      expect(msgExcept.timezone, timezone);
      expect(msgExcept.recurIdZ, recurIdZ);
      expect(msgExcept.add, isA<RecurrenceInfo>());
      expect(msgExcept.exclude, isA<RecurrenceInfo>());

      final msgCancel = msgRecurrence.cancel.first;
      expect(msgCancel.recurrenceRangeType, recurrenceRangeType);
      expect(msgCancel.recurrenceId, recurrenceId);
      expect(msgCancel.timezone, timezone);
      expect(msgCancel.recurIdZ, recurIdZ);

      final msgDates = msgRecurrence.dates.first;
      expect(dates.timezone, timezone);

      final msgStartTime = msgDates.dtVals.first.startTime!;
      expect(msgStartTime.dateTime, dateTimeString);
      expect(msgStartTime.timezone, timezone);
      expect(msgStartTime.utcTime, utcTime);

      final msgEndTime = msgDates.dtVals.first.endTime!;
      expect(msgEndTime.dateTime, dateTimeString);
      expect(msgEndTime.timezone, timezone);
      expect(msgEndTime.utcTime, utcTime);

      final msgDuration = msgDates.dtVals.first.duration!;
      expect(msgDuration.durationNegative, durationNegative);
      expect(msgDuration.weeks, weeks);
      expect(msgDuration.days, days);
      expect(msgDuration.hours, hours);
      expect(msgDuration.minutes, minutes);
      expect(msgDuration.seconds, seconds);
      expect(msgDuration.related, AlarmRelated.start);
      expect(msgDuration.repeatCount, repeatCount);

      final msgSimple = msgRecurrence.simple.first;
      expect(msgSimple.until!.dateTime, dateTimeString);
      expect(msgSimple.count!.num, num);
      expect(msgSimple.interval!.ival, ival);
      expect(msgSimple.bySecond!.list, list);
      expect(msgSimple.byMinute!.list, list);
      expect(msgSimple.byHour!.list, list);
      expect(msgSimple.byDay!.days.first.day, WeekDay.sunday);
      expect(msgSimple.byDay!.days.first.ordWk, ordWk);
      expect(msgSimple.byMonthDay!.list, list);
      expect(msgSimple.byYearDay!.list, list);
      expect(msgSimple.byWeekNo!.list, list);
      expect(msgSimple.byMonth!.list, list);
      expect(msgSimple.bySetPose!.list, list);
      expect(msgSimple.weekStart!.day, WeekDay.sunday);
      expect(msgSimple.xNames.first.name, name);
      expect(msgSimple.xNames.first.value, value);

      final msgExceptionId = msgInviteComponent.exceptionId!;
      expect(msgExceptionId.dateTime, dateTimeString);
      expect(msgExceptionId.timezone, timezone);
      expect(msgExceptionId.recurrenceRangeType, recurrenceRangeType);

      final msgDtStart = msgInviteComponent.dtStart!;
      expect(msgDtStart.dateTime, dateTimeString);
      expect(msgDtStart.timezone, timezone);
      expect(msgDtStart.utcTime, utcTime);

      final msgDtEnd = msgInviteComponent.dtEnd!;
      expect(msgDtEnd.dateTime, dateTimeString);
      expect(msgDtEnd.timezone, timezone);
      expect(msgDtEnd.utcTime, utcTime);

      final msgInviteDuration = msgInviteComponent.duration!;
      expect(msgInviteDuration.durationNegative, durationNegative);
      expect(msgInviteDuration.weeks, weeks);
      expect(msgInviteDuration.days, days);
      expect(msgInviteDuration.hours, hours);
      expect(msgInviteDuration.minutes, minutes);
      expect(msgInviteDuration.seconds, seconds);
      expect(msgInviteDuration.related, AlarmRelated.start);
      expect(msgInviteDuration.repeatCount, repeatCount);

      final chatItem = response.chatItem!;
      expect(chatItem, isA<MessageSummary>());
      expect(chatItem, isA<ChatSummary>());
      expect(chatItem.id, id);
      expect(chatItem.autoSendTime, autoSendTime);
      expect(chatItem.subject, subject);
      expect(chatItem.fragment, fragment);
      expect(chatItem.size, size);
      expect(chatItem.date, date);
      expect(chatItem.folder, folder);
      expect(chatItem.conversationId, conversationId);
      expect(chatItem.flags, flags);
      expect(chatItem.tags, tags);
      expect(chatItem.tagNames, tagNames);
      expect(chatItem.revision, revision);
      expect(chatItem.changeDate, changeDate);
      expect(chatItem.modifiedSequence, modifiedSequence);
    }));

    test('Get last item id in mailbox test', (() async {
      final id = faker.randomGenerator.integer(100);
      final data = {
        'Body': {
          'GetLastItemIdInMailboxResponse': {
            '_jsns': 'urn:zimbraMail',
            'id': {'_content': id},
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getLastItemIdInMailbox();
      expect(response!.id, id);
    }));

    test('Get custom metadata test', (() async {
      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final data = {
        'Body': {
          'GetMailboxMetadataResponse': {
            '_jsns': 'urn:zimbraMail',
            'meta': {
              'section': section,
              '_attrs': {
                key: value,
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getMailboxMetadata(SectionAttr());
      final meta = response!.metadata!;

      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);
    }));

    test('Get mini calendar test', (() async {
      final busyDate = faker.date.dateTime().toString();
      final id = faker.guid.guid();
      final code = faker.lorem.word();
      final errorMessage = faker.lorem.word();

      final data = {
        'Body': {
          'GetMiniCalResponse': {
            '_jsns': 'urn:zimbraMail',
            'date': [
              {'_content': busyDate}
            ],
            'error': [
              {
                'id': id,
                'code': code,
                '_content': errorMessage,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getMiniCal(0, 0);

      expect(response!.busyDates, [busyDate]);

      final error = response.errors.first;
      expect(error.id, id);
      expect(error.code, code);
      expect(error.errorMessage, errorMessage);
    }));

    test('Get modified items ids test', () async {
      final id1 = faker.randomGenerator.integer(100);
      final id2 = faker.randomGenerator.integer(100);
      final data = {
        'Body': {
          'GetModifiedItemsIDsResponse': {
            '_jsns': 'urn:zimbraMail',
            'ids': [
              {'_content': id1},
              {'_content': id2},
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getModifiedItemsIDs(0, 0);
      expect(response!.ids, [id1, id2]);
    });

    test('Get message metadata test', (() async {
      final id = faker.guid.guid();
      final autoSendTime = faker.randomGenerator.integer(100);
      final subject = faker.lorem.word();
      final fragment = faker.lorem.word();
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.internet.userName();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);
      final dateString = faker.date.dateTime().toString();
      final utcTime = faker.date.dateTime().toUtc().millisecond;

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final uri = faker.internet.uri('http');
      final contentType = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();

      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.internet.email();

      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final summary = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final uid = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final calItemFolder = faker.lorem.word();
      final isException = faker.randomGenerator.boolean();
      final url = faker.internet.httpsUrl();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'GetMsgMetadataResponse': {
            '_jsns': 'urn:zimbraAccount',
            'm': {
              'id': id,
              'autoSendTime': autoSendTime,
              'e': [
                {
                  'a': address,
                  'd': display,
                  'p': personal,
                  't': AddressType.from.name,
                  'isGroup': isGroup,
                  'exp': canExpandGroupMembers,
                }
              ],
              'su': subject,
              'fr': fragment,
              'inv': {
                'type': InviteType.appt.name,
                'tz': [
                  {
                    'id': id,
                    'stdoff': tzStdOffset,
                    'dayoff': tzDayOffset,
                    'standard': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'daylight': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'stdname': standardTZName,
                    'dayname': daylightTZName,
                  }
                ],
                'comp': {
                  'category': [
                    {'_content': category}
                  ],
                  'comment': [
                    {'_content': comment}
                  ],
                  'contact': [
                    {'_content': contact}
                  ],
                  'geo': {
                    'lat': latitude,
                    'lon': longitude,
                  },
                  'at': [
                    {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'cutype': cuType,
                      'role': role,
                      'ptst': partStat.name,
                      'rsvp': rsvp,
                      'member': member,
                      'delegatedTo': delegatedTo,
                      'delegatedFrom': delegatedFrom,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    }
                  ],
                  'alarm': [
                    {
                      'action': AlarmAction.display.name,
                      'trigger': {
                        'abs': {
                          'd': dateString,
                        },
                        'rel': {
                          'd': dateString,
                        },
                      },
                      'repeat': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'desc': {'_content': description},
                      'attach': {
                        'uri': uri,
                        'ct': contentType,
                        '_content': binaryB64Data,
                      },
                      'summary': {'_content': summary},
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    }
                  ],
                  'xprop': [
                    {
                      'name': name,
                      'value': value,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    }
                  ],
                  'fr': fragment,
                  'desc': {'_content': description},
                  'descHtml': {'_content': htmlDescription},
                  'or': {
                    'a': address,
                    'url': url,
                    'd': displayName,
                    'sentBy': sentBy,
                    'dir': dir,
                    'lang': language,
                    'xparam': [
                      {
                        'name': name,
                        'value': value,
                      }
                    ],
                  },
                  'recur': {
                    'add': [
                      {'add': []}
                    ],
                    'exclude': [
                      {'exclude': []}
                    ],
                    'except': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                        'add': {'add': []},
                        'exclude': {'exclude': []},
                      }
                    ],
                    'cancel': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                    'dates': [
                      {
                        'tz': timezone,
                        'dtval': [
                          {
                            's': {
                              'd': dateString,
                              'tz': timezone,
                              'u': utcTime,
                            },
                            'e': {
                              'd': dateString,
                              'tz': timezone,
                              'u': utcTime,
                            },
                            'dur': {
                              'neg': durationNegative,
                              'w': weeks,
                              'd': days,
                              'h': hours,
                              'm': minutes,
                              's': seconds,
                              'related': AlarmRelated.start.name,
                              'count': repeatCount,
                            },
                          }
                        ],
                      }
                    ],
                    'rule': [
                      {
                        'freq': Frequency.second.name,
                        'until': {
                          'd': dateString,
                        },
                        'count': {
                          'num': num,
                        },
                        'interval': {
                          'ival': ival,
                        },
                        'bysecond': {
                          'seclist': list,
                        },
                        'byminute': {
                          'minlist': list,
                        },
                        'byhour': {
                          'hrlist': list,
                        },
                        'byday': {
                          'wkday': [
                            {
                              'day': WeekDay.sunday.name,
                              'ordWk': ordWk,
                            }
                          ],
                        },
                        'bymonthday': {
                          'modaylist': list,
                        },
                        'byyearday': {
                          'yrdaylist': list,
                        },
                        'byweekno': {
                          'wklist': list,
                        },
                        'bymonth': {
                          'molist': list,
                        },
                        'bysetpos': {
                          'poslist': list,
                        },
                        'wkst': {
                          'day': WeekDay.sunday.name,
                        },
                        'rule-x-name': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                  'exceptId': {
                    'd': dateString,
                    'tz': timezone,
                    'rangeType': recurrenceRangeType,
                  },
                  's': {
                    'd': dateString,
                    'tz': timezone,
                    'u': utcTime,
                  },
                  'e': {
                    'd': dateString,
                    'tz': timezone,
                    'u': utcTime,
                  },
                  'dur': {
                    'neg': durationNegative,
                    'w': weeks,
                    'd': days,
                    'h': hours,
                    'm': minutes,
                    's': seconds,
                    'related': AlarmRelated.start.name,
                    'count': repeatCount,
                  },
                  'method': method,
                  'compNum': componentNum,
                  'rsvp': rsvp,
                  'priority': priority,
                  'name': name,
                  'loc': location,
                  'percentComplete': percentComplete,
                  'completed': completed,
                  'noBlob': noBlob,
                  'fba': FreeBusyStatus.free.name,
                  'fb': FreeBusyStatus.free.name,
                  'transp': Transparency.opaque.name,
                  'isOrg': isOrganizer,
                  'x_uid': xUid,
                  'uid': uid,
                  'seq': sequence,
                  'd': dateTime,
                  'calItemId': calItemId,
                  'apptId': deprecatedApptId,
                  'ciFolder': calItemFolder,
                  'status': InviteStatus.completed.name,
                  'class': InviteClass.public.name,
                  'url': url,
                  'ex': isException,
                  'ridZ': recurIdZ,
                  'allDay': isAllDay,
                  'draft': isDraft,
                  'neverSent': neverSent,
                  'changes': changes,
                },
                'replies': {
                  'reply': [
                    {
                      'rangeType': recurrenceRangeType,
                      'recurId': recurrenceId,
                      'seq': seq,
                      'd': date,
                      'at': attendee,
                      'sentBy': sentBy,
                      'ptst': partStat.name,
                      'tz': timezone,
                      'ridZ': recurIdZ,
                    }
                  ]
                },
              },
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
            'chat': {
              'id': id,
              'autoSendTime': autoSendTime,
              'su': subject,
              'fr': fragment,
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getMsgMetadata(IdsAttr(id));
      final chatMessage = response!.chatMessage!;
      final message = response.message!;

      expect(chatMessage, isA<MessageSummary>());
      expect(chatMessage, isA<ChatSummary>());
      expect(chatMessage.id, id);
      expect(chatMessage.autoSendTime, autoSendTime);
      expect(chatMessage.subject, subject);
      expect(chatMessage.fragment, fragment);
      expect(chatMessage.size, size);
      expect(chatMessage.date, date);
      expect(chatMessage.folder, folder);
      expect(chatMessage.conversationId, conversationId);
      expect(chatMessage.flags, flags);
      expect(chatMessage.tags, tags);
      expect(chatMessage.tagNames, tagNames);
      expect(chatMessage.revision, revision);
      expect(chatMessage.changeDate, changeDate);
      expect(chatMessage.modifiedSequence, modifiedSequence);

      expect(message.id, id);
      expect(message.autoSendTime, autoSendTime);
      expect(message.subject, subject);
      expect(message.fragment, fragment);
      expect(message.size, size);
      expect(message.date, date);
      expect(message.folder, folder);
      expect(message.conversationId, conversationId);
      expect(message.flags, flags);
      expect(message.tags, tags);
      expect(message.tagNames, tagNames);
      expect(message.revision, revision);
      expect(message.changeDate, changeDate);
      expect(message.modifiedSequence, modifiedSequence);

      final email = message.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final meta = message.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final invite = message.invite!;
      expect(invite.calItemType, InviteType.appt);

      final tz = invite.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standardTzOnset = tz.standardTzOnset!;
      expect(standardTzOnset.month, month);
      expect(standardTzOnset.hour, hour);
      expect(standardTzOnset.minute, minute);
      expect(standardTzOnset.second, second);
      expect(standardTzOnset.dayOfMonth, dayOfMonth);
      expect(standardTzOnset.week, week);
      expect(standardTzOnset.dayOfWeek, dayOfWeek);

      final daylightTzOnset = tz.daylightTzOnset!;
      expect(daylightTzOnset.month, month);
      expect(daylightTzOnset.hour, hour);
      expect(daylightTzOnset.minute, minute);
      expect(daylightTzOnset.second, second);
      expect(daylightTzOnset.dayOfMonth, dayOfMonth);
      expect(daylightTzOnset.week, week);
      expect(daylightTzOnset.dayOfWeek, dayOfWeek);

      final reply = invite.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final inviteComponent = invite.inviteComponent!;

      expect(inviteComponent.method, method);
      expect(inviteComponent.componentNum, componentNum);
      expect(inviteComponent.rsvp, rsvp);
      expect(inviteComponent.priority, priority);
      expect(inviteComponent.name, name);
      expect(inviteComponent.location, location);
      expect(inviteComponent.percentComplete, percentComplete);
      expect(inviteComponent.completed, completed);
      expect(inviteComponent.noBlob, noBlob);
      expect(inviteComponent.freeBusyActual, FreeBusyStatus.free);
      expect(inviteComponent.freeBusy, FreeBusyStatus.free);
      expect(inviteComponent.transparency, Transparency.opaque);
      expect(inviteComponent.isOrganizer, isOrganizer);
      expect(inviteComponent.xUid, xUid);
      expect(inviteComponent.uid, uid);
      expect(inviteComponent.sequence, sequence);
      expect(inviteComponent.dateTime, dateTime);
      expect(inviteComponent.calItemId, calItemId);
      expect(inviteComponent.deprecatedApptId, deprecatedApptId);
      expect(inviteComponent.calItemFolder, calItemFolder);
      expect(inviteComponent.status, InviteStatus.completed);
      expect(inviteComponent.calClass, InviteClass.public);
      expect(inviteComponent.url, url);
      expect(inviteComponent.isException, isException);
      expect(inviteComponent.recurIdZ, recurIdZ);
      expect(inviteComponent.isAllDay, isAllDay);
      expect(inviteComponent.isDraft, isDraft);
      expect(inviteComponent.neverSent, neverSent);
      expect(inviteComponent.changes, changes);

      expect(inviteComponent.fragment, fragment);
      expect(inviteComponent.description, description);
      expect(inviteComponent.htmlDescription, htmlDescription);

      expect(inviteComponent.categories.first, category);
      expect(inviteComponent.comments.first, comment);
      expect(inviteComponent.contacts.first, contact);

      final geo = inviteComponent.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final inviteAt = inviteComponent.attendees.first;
      expect(inviteAt.address, address);
      expect(inviteAt.url, url);
      expect(inviteAt.displayName, displayName);
      expect(inviteAt.sentBy, sentBy);
      expect(inviteAt.dir, dir);
      expect(inviteAt.language, language);
      expect(inviteAt.cuType, cuType);
      expect(inviteAt.role, role);
      expect(inviteAt.partStat, partStat);
      expect(inviteAt.rsvp, rsvp);
      expect(inviteAt.member, member);
      expect(inviteAt.delegatedTo, delegatedTo);
      expect(inviteAt.delegatedFrom, delegatedFrom);
      expect(inviteAt.xParams.first.name, name);
      expect(inviteAt.xParams.first.value, value);

      final alarm = inviteComponent.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final inviteXProp = inviteComponent.xProps.first;
      expect(inviteXProp.name, name);
      expect(inviteXProp.value, value);
      expect(inviteXProp.xParams.first.name, name);
      expect(inviteXProp.xParams.first.value, value);

      final organizer = inviteComponent.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = inviteComponent.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = inviteComponent.exceptionId!;
      expect(exceptionId.dateTime, dateString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = inviteComponent.dtStart!;
      expect(dtStart.dateTime, dateString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = inviteComponent.dtEnd!;
      expect(dtEnd.dateTime, dateString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = inviteComponent.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Get message test', (() async {
      final id = faker.guid.guid();
      final imapUid = faker.randomGenerator.integer(100);
      final calendarIntendedFor = faker.internet.email();
      final origId = faker.guid.guid();
      final identityId = faker.guid.guid();
      final draftAccountId = faker.guid.guid();
      final draftAutoSendTime = faker.randomGenerator.integer(100);
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final resentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final part = faker.lorem.word();
      final fragment = faker.lorem.word();
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();
      final inReplyTo = faker.internet.email();
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.lorem.word();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final url = faker.internet.httpsUrl();
      final path = faker.lorem.word();
      final section = faker.lorem.word();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final content = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentId = faker.guid.guid();
      final attachmentId = faker.guid.guid();
      final messageId = faker.guid.guid();
      final truncatedContent = faker.randomGenerator.boolean();
      final optional = faker.randomGenerator.boolean();
      final version = faker.randomGenerator.integer(100);

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();
      final recurrenceId = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();

      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final summary = faker.guid.guid();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final rsvp = faker.randomGenerator.boolean();
      final uri = faker.internet.uri('http');
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final sequence = faker.randomGenerator.integer(100);
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final uid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'GetMsgResponse': {
            '_jsns': 'urn:zimbraMail',
            'm': {
              'id': id,
              'i4uid': imapUid,
              'cif': calendarIntendedFor,
              'origid': origId,
              'rt': ReplyType.replied.name,
              'idnt': identityId,
              'forAcct': draftAccountId,
              'autoSendTime': draftAutoSendTime,
              'sd': sentDate,
              'rd': resentDate,
              'part': part,
              'fr': fragment,
              'e': [
                {
                  'a': address,
                  'd': display,
                  'p': personal,
                  't': AddressType.from.name,
                  'isGroup': isGroup,
                  'exp': canExpandGroupMembers,
                }
              ],
              'su': subject,
              'mid': messageIdHeader,
              'irt': inReplyTo,
              'inv': {
                'type': InviteType.appt.name,
                'tz': [
                  {
                    'id': id,
                    'stdoff': tzStdOffset,
                    'dayoff': tzDayOffset,
                    'standard': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'daylight': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'stdname': standardTZName,
                    'dayname': daylightTZName,
                  }
                ],
                'comp': [
                  {
                    'category': [
                      {'_content': category}
                    ],
                    'comment': [
                      {'_content': comment}
                    ],
                    'contact': [
                      {'_content': contact}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'alarm': [
                      {
                        'action': AlarmAction.display.name,
                        'trigger': {
                          'abs': {
                            'd': dateTimeString,
                          },
                          'rel': {
                            'd': dateTimeString,
                          },
                        },
                        'repeat': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': AlarmRelated.start.name,
                          'count': repeatCount,
                        },
                        'desc': {'_content': description},
                        'attach': {
                          'uri': uri,
                          'ct': contentType,
                          '_content': binaryB64Data,
                        },
                        'summary': {'_content': summary},
                        'at': [
                          {
                            'a': address,
                            'url': url,
                            'd': displayName,
                            'sentBy': sentBy,
                            'dir': dir,
                            'lang': language,
                            'cutype': cuType,
                            'role': role,
                            'ptst': partStat.name,
                            'rsvp': rsvp,
                            'member': member,
                            'delegatedTo': delegatedTo,
                            'delegatedFrom': delegatedFrom,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'xprop': [
                          {
                            'name': name,
                            'value': value,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'fr': fragment,
                    'desc': {'_content': description},
                    'descHtml': {'_content': htmlDescription},
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'recur': {
                      'add': [
                        {'add': {}}
                      ],
                      'exclude': [
                        {'exclude': {}}
                      ],
                      'except': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                          'add': {'add': []},
                          'exclude': {'exclude': []},
                        }
                      ],
                      'cancel': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ],
                      'dates': [
                        {
                          'tz': timezone,
                          'dtval': [
                            {
                              's': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'e': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'dur': {
                                'neg': durationNegative,
                                'w': weeks,
                                'd': days,
                                'h': hours,
                                'm': minutes,
                                's': seconds,
                                'related': AlarmRelated.start.name,
                                'count': repeatCount,
                              },
                            }
                          ],
                        }
                      ],
                      'rule': [
                        {
                          'freq': Frequency.second.name,
                          'until': {
                            'd': dateTimeString,
                          },
                          'count': {
                            'num': num,
                          },
                          'interval': {
                            'ival': ival,
                          },
                          'bysecond': {
                            'seclist': list,
                          },
                          'byminute': {
                            'minlist': list,
                          },
                          'byhour': {
                            'hrlist': list,
                          },
                          'byday': {
                            'wkday': [
                              {
                                'day': WeekDay.sunday.name,
                                'ordWk': ordWk,
                              }
                            ],
                          },
                          'bymonthday': {
                            'modaylist': list,
                          },
                          'byyearday': {
                            'yrdaylist': list,
                          },
                          'byweekno': {
                            'wklist': list,
                          },
                          'bymonth': {
                            'molist': list,
                          },
                          'bysetpos': {
                            'poslist': list,
                          },
                          'wkst': {
                            'day': WeekDay.sunday.name,
                          },
                          'rule-x-name': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    },
                    'exceptId': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'rangeType': recurrenceRangeType,
                    },
                    's': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'e': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'dur': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'method': method,
                    'compNum': componentNum,
                    'rsvp': rsvp,
                    'priority': priority,
                    'name': name,
                    'loc': location,
                    'percentComplete': percentComplete,
                    'completed': completed,
                    'noBlob': noBlob,
                    'fba': FreeBusyStatus.free.name,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'isOrg': isOrganizer,
                    'x_uid': xUid,
                    'uid': uid,
                    'seq': sequence,
                    'd': dateTime,
                    'calItemId': calItemId,
                    'apptId': deprecatedApptId,
                    'ciFolder': calItemFolder,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'url': url,
                    'ex': isException,
                    'ridZ': recurIdZ,
                    'allDay': isAllDay,
                    'draft': isDraft,
                    'neverSent': neverSent,
                    'changes': changes,
                  }
                ],
                'replies': {
                  'reply': [
                    {
                      'rangeType': recurrenceRangeType,
                      'recurId': recurrenceId,
                      'seq': seq,
                      'd': date,
                      'at': attendee,
                      'sentBy': sentBy,
                      'ptst': partStat.name,
                      'tz': timezone,
                      'ridZ': recurIdZ,
                    }
                  ]
                },
              },
              '_attrs': {
                key: value,
              },
              'mp': {
                'ct': contentType,
                'content': content,
                'ci': contentId,
                'attach': {
                  'aid': attachmentId,
                  'mp': [
                    {
                      'mid': messageId,
                      'part': part,
                      'optional': optional,
                    }
                  ],
                  'm': [
                    {
                      'id': id,
                      'optional': optional,
                    }
                  ],
                  'cn': [
                    {
                      'id': id,
                      'optional': optional,
                    }
                  ],
                  'doc': [
                    {
                      'path': path,
                      'id': id,
                      'ver': version,
                      'optional': optional,
                    }
                  ],
                },
                'mp': [
                  {
                    'ct': contentType,
                    'content': content,
                    'ci': contentId,
                  }
                ],
              },
              'shr': {
                'truncated': truncatedContent,
                'content': content,
              },
              'dlSubs': {
                'truncated': truncatedContent,
                'content': content,
              },
              'content': {
                'url': url,
                '_content': value,
              },
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getMsg(MsgSpec());
      final msg = response!.msg!;

      expect(msg.id, id);
      expect(msg.imapUid, imapUid);
      expect(msg.calendarIntendedFor, calendarIntendedFor);
      expect(msg.origId, origId);
      expect(msg.draftReplyType, ReplyType.replied);
      expect(msg.identityId, identityId);
      expect(msg.draftAccountId, draftAccountId);
      expect(msg.draftAutoSendTime, draftAutoSendTime);
      expect(msg.sentDate, sentDate);
      expect(msg.resentDate, resentDate);
      expect(msg.part, part);
      expect(msg.fragment, fragment);
      expect(msg.subject, subject);
      expect(msg.messageIdHeader, messageIdHeader);
      expect(msg.inReplyTo, inReplyTo);
      expect(msg.size, size);
      expect(msg.date, date);
      expect(msg.folder, folder);
      expect(msg.conversationId, conversationId);
      expect(msg.flags, flags);
      expect(msg.tags, tags);
      expect(msg.tagNames, tagNames);
      expect(msg.revision, revision);
      expect(msg.changeDate, changeDate);
      expect(msg.modifiedSequence, modifiedSequence);

      final msgMeta = msg.metadatas.first;
      expect(msgMeta.section, section);
      expect(msgMeta.keyValuePairs.first.key, key);
      expect(msgMeta.keyValuePairs.first.value, value);

      final email = msg.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final header = msg.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final mimePart = msg.mimePart!;
      expect(mimePart.contentType, contentType);
      expect(mimePart.content, content);
      expect(mimePart.contentId, contentId);
      expect(mimePart.mimeParts.first.contentType, contentType);
      expect(mimePart.mimeParts.first.content, content);
      expect(mimePart.mimeParts.first.contentId, contentId);

      final mpAttach = mimePart.attachments!;
      expect(mpAttach.attachmentId, attachmentId);

      final mpAttachment = mpAttach.mpAttachments.first;
      expect(mpAttachment.messageId, messageId);
      expect(mpAttachment.part, part);
      expect(mpAttachment.optional, optional);

      final msgAttachment = mpAttach.msgAttachments.first;
      expect(msgAttachment.id, id);
      expect(msgAttachment.optional, optional);

      final cnAttachment = mpAttach.cnAttachments.first;
      expect(cnAttachment.id, id);
      expect(cnAttachment.optional, optional);

      final docAttachment = mpAttach.docAttachments.first;
      expect(docAttachment.path, path);
      expect(docAttachment.id, id);
      expect(docAttachment.version, version);
      expect(docAttachment.optional, optional);

      final shrNotification = msg.shrNotification!;
      expect(shrNotification.content, content);
      expect(shrNotification.truncatedContent, truncatedContent);

      final dlSubsNotification = msg.dlSubsNotification!;
      expect(dlSubsNotification.content, content);
      expect(dlSubsNotification.truncatedContent, truncatedContent);

      final msgContent = msg.content!;
      expect(msgContent.url, url);
      expect(msgContent.value, value);

      final invite = msg.invite!;
      expect(invite.calItemType, InviteType.appt);

      final inviteTz = invite.timezones.first;
      expect(inviteTz.id, id);
      expect(inviteTz.tzStdOffset, tzStdOffset);
      expect(inviteTz.tzDayOffset, tzDayOffset);
      expect(inviteTz.standardTZName, standardTZName);
      expect(inviteTz.daylightTZName, daylightTZName);

      final tzStandard = inviteTz.standardTzOnset!;
      expect(tzStandard.month, month);
      expect(tzStandard.hour, hour);
      expect(tzStandard.minute, minute);
      expect(tzStandard.second, second);
      expect(tzStandard.dayOfMonth, dayOfMonth);
      expect(tzStandard.week, week);
      expect(tzStandard.dayOfWeek, dayOfWeek);

      final tzDaylight = inviteTz.daylightTzOnset!;
      expect(tzDaylight.month, month);
      expect(tzDaylight.hour, hour);
      expect(tzDaylight.minute, minute);
      expect(tzDaylight.second, second);
      expect(tzDaylight.dayOfMonth, dayOfMonth);
      expect(tzDaylight.week, week);
      expect(tzDaylight.dayOfWeek, dayOfWeek);

      final inviteReply = invite.calendarReplies.first;
      expect(inviteReply.recurrenceRangeType, recurrenceRangeType);
      expect(inviteReply.recurrenceRangeType, recurrenceRangeType);
      expect(inviteReply.recurrenceId, recurrenceId);
      expect(inviteReply.seq, seq);
      expect(inviteReply.date, date);
      expect(inviteReply.attendee, attendee);
      expect(inviteReply.sentBy, sentBy);
      expect(inviteReply.partStat, partStat);
      expect(inviteReply.timezone, timezone);
      expect(inviteReply.recurIdZ, recurIdZ);

      final inviteComponent = invite.inviteComponents.first;
      expect(inviteComponent.method, method);
      expect(inviteComponent.componentNum, componentNum);
      expect(inviteComponent.rsvp, rsvp);
      expect(inviteComponent.priority, priority);
      expect(inviteComponent.name, name);
      expect(inviteComponent.location, location);
      expect(inviteComponent.percentComplete, percentComplete);
      expect(inviteComponent.completed, completed);
      expect(inviteComponent.noBlob, noBlob);
      expect(inviteComponent.freeBusyActual, FreeBusyStatus.free);
      expect(inviteComponent.freeBusy, FreeBusyStatus.free);
      expect(inviteComponent.transparency, Transparency.opaque);
      expect(inviteComponent.isOrganizer, isOrganizer);
      expect(inviteComponent.xUid, xUid);
      expect(inviteComponent.uid, uid);
      expect(inviteComponent.sequence, sequence);
      expect(inviteComponent.dateTime, dateTime);
      expect(inviteComponent.calItemId, calItemId);
      expect(inviteComponent.deprecatedApptId, deprecatedApptId);
      expect(inviteComponent.calItemFolder, calItemFolder);
      expect(inviteComponent.status, InviteStatus.completed);
      expect(inviteComponent.calClass, InviteClass.public);
      expect(inviteComponent.url, url);
      expect(inviteComponent.isException, isException);
      expect(inviteComponent.recurIdZ, recurIdZ);
      expect(inviteComponent.isAllDay, isAllDay);
      expect(inviteComponent.isDraft, isDraft);
      expect(inviteComponent.neverSent, neverSent);
      expect(inviteComponent.changes, changes);

      expect(inviteComponent.fragment, fragment);
      expect(inviteComponent.description, description);
      expect(inviteComponent.htmlDescription, htmlDescription);

      expect(inviteComponent.categories.first, category);
      expect(inviteComponent.comments.first, comment);
      expect(inviteComponent.contacts.first, contact);

      final inviteGeo = inviteComponent.geo!;
      expect(inviteGeo.latitude, latitude);
      expect(inviteGeo.longitude, longitude);

      final inviteAt = inviteComponent.attendees.first;
      expect(inviteAt.address, address);
      expect(inviteAt.url, url);
      expect(inviteAt.displayName, displayName);
      expect(inviteAt.sentBy, sentBy);
      expect(inviteAt.dir, dir);
      expect(inviteAt.language, language);
      expect(inviteAt.cuType, cuType);
      expect(inviteAt.role, role);
      expect(inviteAt.partStat, partStat);
      expect(inviteAt.rsvp, rsvp);
      expect(inviteAt.member, member);
      expect(inviteAt.delegatedTo, delegatedTo);
      expect(inviteAt.delegatedFrom, delegatedFrom);
      expect(inviteAt.xParams.first.name, name);
      expect(inviteAt.xParams.first.value, value);

      final inviteAlarm = inviteComponent.alarms.first;
      expect(inviteAlarm.action, AlarmAction.display);
      expect(inviteAlarm.description, description);
      expect(inviteAlarm.summary, summary);
      expect(inviteAlarm.attach!.uri, uri);
      expect(inviteAlarm.attach!.contentType, contentType);
      expect(inviteAlarm.attach!.binaryB64Data, binaryB64Data);

      final inviteAlarmAt = inviteAlarm.attendees.first;
      expect(inviteAlarmAt.address, address);
      expect(inviteAlarmAt.url, url);
      expect(inviteAlarmAt.displayName, displayName);
      expect(inviteAlarmAt.sentBy, sentBy);
      expect(inviteAlarmAt.dir, dir);
      expect(inviteAlarmAt.language, language);
      expect(inviteAlarmAt.cuType, cuType);
      expect(inviteAlarmAt.role, role);
      expect(inviteAlarmAt.partStat, partStat);
      expect(inviteAlarmAt.rsvp, rsvp);
      expect(inviteAlarmAt.member, member);
      expect(inviteAlarmAt.delegatedTo, delegatedTo);
      expect(inviteAlarmAt.delegatedFrom, delegatedFrom);
      expect(inviteAlarmAt.xParams.first.name, name);
      expect(inviteAlarmAt.xParams.first.value, value);

      final inviteAlarmXProp = inviteAlarm.xProps.first;
      expect(inviteAlarmXProp.name, name);
      expect(inviteAlarmXProp.value, value);
      expect(inviteAlarmXProp.xParams.first.name, name);
      expect(inviteAlarmXProp.xParams.first.value, value);

      final inviteXProp = inviteComponent.xProps.first;
      expect(inviteXProp.name, name);
      expect(inviteXProp.value, value);
      expect(inviteXProp.xParams.first.name, name);
      expect(inviteXProp.xParams.first.value, value);

      final inviteOrganizer = inviteComponent.organizer!;
      expect(inviteOrganizer.address, address);
      expect(inviteOrganizer.url, url);
      expect(inviteOrganizer.displayName, displayName);
      expect(inviteOrganizer.sentBy, sentBy);
      expect(inviteOrganizer.dir, dir);
      expect(inviteOrganizer.language, language);
      expect(inviteOrganizer.xParams.first.name, name);
      expect(inviteOrganizer.xParams.first.value, value);

      final inviteRecurrence = inviteComponent.recurrence!;
      expect(inviteRecurrence.add.first, isA<AddRecurrenceInfo>());
      expect(inviteRecurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final inviteExcept = inviteRecurrence.except.first;
      expect(inviteExcept.recurrenceRangeType, recurrenceRangeType);
      expect(inviteExcept.recurrenceId, recurrenceId);
      expect(inviteExcept.timezone, timezone);
      expect(inviteExcept.recurIdZ, recurIdZ);
      expect(inviteExcept.add, isA<RecurrenceInfo>());
      expect(inviteExcept.exclude, isA<RecurrenceInfo>());

      final inviteCancel = inviteRecurrence.cancel.first;
      expect(inviteCancel.recurrenceRangeType, recurrenceRangeType);
      expect(inviteCancel.recurrenceId, recurrenceId);
      expect(inviteCancel.timezone, timezone);
      expect(inviteCancel.recurIdZ, recurIdZ);

      final inviteDates = inviteRecurrence.dates.first;
      expect(inviteDates.timezone, timezone);

      final inviteStartTime = inviteDates.dtVals.first.startTime!;
      expect(inviteStartTime.dateTime, dateTimeString);
      expect(inviteStartTime.timezone, timezone);
      expect(inviteStartTime.utcTime, utcTime);

      final inviteEndTime = inviteDates.dtVals.first.endTime!;
      expect(inviteEndTime.dateTime, dateTimeString);
      expect(inviteEndTime.timezone, timezone);
      expect(inviteEndTime.utcTime, utcTime);

      final dtDuration = inviteDates.dtVals.first.duration!;
      expect(dtDuration.durationNegative, durationNegative);
      expect(dtDuration.weeks, weeks);
      expect(dtDuration.days, days);
      expect(dtDuration.hours, hours);
      expect(dtDuration.minutes, minutes);
      expect(dtDuration.seconds, seconds);
      expect(dtDuration.related, AlarmRelated.start);
      expect(dtDuration.repeatCount, repeatCount);

      final inviteSimple = inviteRecurrence.simple.first;
      expect(inviteSimple.until!.dateTime, dateTimeString);
      expect(inviteSimple.count!.num, num);
      expect(inviteSimple.interval!.ival, ival);
      expect(inviteSimple.bySecond!.list, list);
      expect(inviteSimple.byMinute!.list, list);
      expect(inviteSimple.byHour!.list, list);
      expect(inviteSimple.byDay!.days.first.day, WeekDay.sunday);
      expect(inviteSimple.byDay!.days.first.ordWk, ordWk);
      expect(inviteSimple.byMonthDay!.list, list);
      expect(inviteSimple.byYearDay!.list, list);
      expect(inviteSimple.byWeekNo!.list, list);
      expect(inviteSimple.byMonth!.list, list);
      expect(inviteSimple.bySetPose!.list, list);
      expect(inviteSimple.weekStart!.day, WeekDay.sunday);
      expect(inviteSimple.xNames.first.name, name);
      expect(inviteSimple.xNames.first.value, value);

      final inviteExceptionId = inviteComponent.exceptionId!;
      expect(inviteExceptionId.dateTime, dateTimeString);
      expect(inviteExceptionId.timezone, timezone);
      expect(inviteExceptionId.recurrenceRangeType, recurrenceRangeType);

      final inviteDtStart = inviteComponent.dtStart!;
      expect(inviteDtStart.dateTime, dateTimeString);
      expect(inviteDtStart.timezone, timezone);
      expect(inviteDtStart.utcTime, utcTime);

      final inviteDtEnd = inviteComponent.dtEnd!;
      expect(inviteDtEnd.dateTime, dateTimeString);
      expect(inviteDtEnd.timezone, timezone);
      expect(inviteDtEnd.utcTime, utcTime);

      final inviteDuration = inviteComponent.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Get note test', (() async {
      final id = faker.guid.guid();
      final flags = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final revision = faker.randomGenerator.integer(100);
      final modifiedSequence = faker.randomGenerator.integer(100);
      final folder = faker.guid.guid();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final bounds = faker.lorem.word();
      final content = faker.lorem.word();
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final changeDate = faker.date.dateTime().minute;
      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final data = {
        'Body': {
          'GetNoteResponse': {
            '_jsns': 'urn:zimbraMail',
            'note': {
              'id': id,
              'rev': revision,
              'l': folder,
              'd': date,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'pos': bounds,
              'color': color,
              'rgb': rgb,
              'md': changeDate,
              'ms': modifiedSequence,
              'content': content,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getNote(Id());
      final note = response!.note!;

      expect(note.id, id);
      expect(note.revision, revision);
      expect(note.folder, folder);
      expect(note.date, date);
      expect(note.flags, flags);
      expect(note.tags, tags);
      expect(note.tagNames, tagNames);
      expect(note.bounds, bounds);
      expect(note.color, color);
      expect(note.rgb, rgb);
      expect(note.changeDate, changeDate);
      expect(note.modifiedSequence, modifiedSequence);
      expect(note.content, content);

      final meta = note.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);
    }));

    test('Get outgoing filter rules test', (() async {
      final name = faker.lorem.word();
      final value = faker.lorem.word();
      final active = faker.randomGenerator.boolean();
      final index = faker.randomGenerator.integer(100);
      final negative = faker.randomGenerator.boolean();
      final caseSensitive = faker.randomGenerator.boolean();
      final header = faker.lorem.word();
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final time = faker.date.dateTime().toString();
      final method = faker.lorem.word();
      final size = faker.lorem.word();

      final folder = faker.lorem.word();
      final copy = faker.randomGenerator.boolean();
      final tag = faker.lorem.word();
      final address = faker.internet.email();
      final content = faker.lorem.word();
      final subject = faker.lorem.word();
      final maxBodySize = faker.randomGenerator.integer(100);
      final origHeaders = faker.lorem.word();
      final from = faker.internet.email();
      final importance = faker.lorem.word();
      final options = faker.lorem.word();
      final message = faker.lorem.word();
      final last = faker.randomGenerator.boolean();
      final offset = faker.randomGenerator.integer(100);
      final countComparator = faker.randomGenerator.boolean();
      final valueComparator = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GetOutgoingFilterRulesResponse': {
            '_jsns': 'urn:zimbraMail',
            'filterRules': [
              {
                'filterRule': [
                  {
                    'name': name,
                    'active': active,
                    'filterVariables': [
                      {
                        'index': index,
                        'filterVariable': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'filterTests': [
                      {
                        'condition': FilterCondition.allof.name,
                        'addressBookTest': [
                          {
                            'header': header,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'addressTest': [
                          {
                            'header': header,
                            'part': AddressPart.all.name,
                            'stringComparison': StringComparison.contains.name,
                            'caseSensitive': caseSensitive,
                            'value': value,
                            'valueComparison': ValueComparison.equal.name,
                            'countComparison': CountComparison.equal.name,
                            'valueComparisonComparator': ComparisonComparator.asciiNumeric.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'envelopeTest': [
                          {
                            'header': header,
                            'part': AddressPart.all.name,
                            'stringComparison': StringComparison.contains.name,
                            'caseSensitive': caseSensitive,
                            'value': value,
                            'valueComparison': ValueComparison.equal.name,
                            'countComparison': CountComparison.equal.name,
                            'valueComparisonComparator': ComparisonComparator.asciiNumeric.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'attachmentTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'bodyTest': [
                          {
                            'value': value,
                            'caseSensitive': caseSensitive,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'bulkTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'contactRankingTest': [
                          {
                            'header': header,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'conversationTest': [
                          {
                            'where': WhereSetting.started.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'currentDayOfWeekTest': [
                          {
                            'value': value,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'currentTimeTest': [
                          {
                            'dateComparison': DateComparison.before.name,
                            'time': time,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'dateTest': [
                          {
                            'dateComparison': DateComparison.before.name,
                            'date': date,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'facebookTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'flaggedTest': [
                          {
                            'flagName': FilterFlagName.flagged.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'headerExistsTest': [
                          {
                            'header': header,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'headerTest': [
                          {
                            'header': header,
                            'stringComparison': StringComparison.contains.name,
                            'valueComparison': ValueComparison.equal.name,
                            'countComparison': CountComparison.equal.name,
                            'valueComparisonComparator': ComparisonComparator.asciiNumeric.name,
                            'value': value,
                            'caseSensitive': caseSensitive,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'importanceTest': [
                          {
                            'imp': Importance.normal.name,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'inviteTest': [
                          {
                            'method': [
                              {'_content': method}
                            ],
                            'index': index,
                            'negative': negative,
                          },
                        ],
                        'linkedinTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'listTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'meTest': [
                          {
                            'header': header,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'mimeHeaderTest': [
                          {
                            'header': header,
                            'stringComparison': StringComparison.contains.name,
                            'value': value,
                            'caseSensitive': caseSensitive,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'sizeTest': [
                          {
                            'numberComparison': NumberComparison.over.name,
                            's': size,
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'socialcastTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'trueTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'twitterTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'communityRequestsTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'communityContentTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                        'communityConnectionsTest': [
                          {
                            'index': index,
                            'negative': negative,
                          }
                        ],
                      }
                    ],
                    'filterActions': [
                      {
                        'filterVariables': [
                          {
                            'index': index,
                            'filterVariable': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'actionKeep': [
                          {
                            'index': index,
                          }
                        ],
                        'actionDiscard': [
                          {
                            'index': index,
                          }
                        ],
                        'actionFileInto': [
                          {
                            'folderPath': folder,
                            'copy': copy,
                            'index': index,
                          }
                        ],
                        'actionFlag': [
                          {
                            'flagName': FilterFlagName.flagged.name,
                            'index': index,
                          }
                        ],
                        'actionTag': [
                          {
                            'tagName': tag,
                            'index': index,
                          }
                        ],
                        'actionRedirect': [
                          {
                            'a': address,
                            'copy': copy,
                            'index': index,
                          }
                        ],
                        'actionReply': [
                          {
                            'content': {'_content': content},
                            'index': index,
                          }
                        ],
                        'actionNotify': [
                          {
                            'a': address,
                            'su': subject,
                            'maxBodySize': maxBodySize,
                            'content': {'_content': content},
                            'origHeaders': origHeaders,
                            'index': index,
                          }
                        ],
                        'actionRFCCompliantNotify': [
                          {
                            'from': from,
                            'importance': importance,
                            'options': options,
                            'message': message,
                            'method': {'_content': method},
                            'index': index,
                          }
                        ],
                        'actionStop': [
                          {
                            'index': index,
                          }
                        ],
                        'actionReject': [
                          {
                            '_content': content,
                            'index': index,
                          }
                        ],
                        'actionEreject': [
                          {
                            '_content': content,
                            'index': index,
                          }
                        ],
                        'actionLog': [
                          {
                            'level': LoggingLevel.info.name,
                            '_content': content,
                            'index': index,
                          }
                        ],
                        'actionAddheader': [
                          {
                            'headerName': {'_content': header},
                            'headerValue': {'_content': value},
                            'last': last,
                            'index': index,
                          }
                        ],
                        'actionDeleteheader': [
                          {
                            'last': last,
                            'offset': offset,
                            'test': {
                              'matchType': MatchType.value.name,
                              'countComparator': countComparator,
                              'valueComparator': valueComparator,
                              'relationalComparator': RelationalComparator.equal.name,
                              'comparator': ComparisonComparator.asciiNumeric.name,
                              'headerName': {'_content': header},
                              'headerValue': [
                                {'_content': value}
                              ],
                            },
                            'index': index,
                          }
                        ],
                        'actionReplaceheader': [
                          {
                            'newName': {'_content': name},
                            'newValue': {'_content': value},
                            'last': last,
                            'offset': offset,
                            'test': {
                              'matchType': MatchType.value.name,
                              'countComparator': countComparator,
                              'valueComparator': valueComparator,
                              'relationalComparator': RelationalComparator.equal.name,
                              'comparator': ComparisonComparator.asciiNumeric.name,
                              'headerName': {'_content': header},
                              'headerValue': [
                                {'_content': value}
                              ],
                            },
                            'index': index,
                          }
                        ],
                      }
                    ],
                    'nestedRule': {
                      'filterVariables': {
                        'index': index,
                        'filterVariable': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'filterTests': {
                        'condition': FilterCondition.allof.name,
                      },
                      'filterActions': {
                        'filterVariables': [
                          {
                            'index': index,
                            'filterVariable': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ]
                      },
                      'nestedRule': {'nestedRule': null},
                    },
                  }
                ]
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getOutgoingFilterRules();
      final filterRule = response!.filterRules.first;

      expect(filterRule.name, name);
      expect(filterRule.active, active);

      final filterVariables = filterRule.filterVariables!;
      expect(filterVariables.index, index);
      expect(filterVariables.variables.first.name, name);
      expect(filterVariables.variables.first.value, value);

      final filterTests = filterRule.filterTests!;
      expect(filterTests.condition, FilterCondition.allof);

      final addressBookTest = filterTests.addressBookTests.first;
      expect(addressBookTest.header, header);
      expect(addressBookTest.index, index);
      expect(addressBookTest.negative, negative);

      final addressTest = filterTests.addressTests.first;
      expect(addressTest.header, header);
      expect(addressTest.part, AddressPart.all);
      expect(addressTest.stringComparison, StringComparison.contains);
      expect(addressTest.caseSensitive, caseSensitive);
      expect(addressTest.value, value);
      expect(addressTest.valueComparison, ValueComparison.equal);
      expect(addressTest.countComparison, CountComparison.equal);
      expect(addressTest.valueComparisonComparator, ComparisonComparator.asciiNumeric);
      expect(addressTest.index, index);
      expect(addressTest.negative, negative);

      final envelopeTest = filterTests.envelopeTests.first;
      expect(envelopeTest.header, header);
      expect(envelopeTest.part, AddressPart.all);
      expect(envelopeTest.stringComparison, StringComparison.contains);
      expect(envelopeTest.caseSensitive, caseSensitive);
      expect(addressTest.value, value);
      expect(envelopeTest.valueComparison, ValueComparison.equal);
      expect(envelopeTest.countComparison, CountComparison.equal);
      expect(envelopeTest.valueComparisonComparator, ComparisonComparator.asciiNumeric);
      expect(envelopeTest.index, index);
      expect(envelopeTest.negative, negative);

      final attachmentTest = filterTests.attachmentTests.first;
      expect(attachmentTest.index, index);
      expect(attachmentTest.negative, negative);

      final bodyTest = filterTests.bodyTests.first;
      expect(bodyTest.value, value);
      expect(bodyTest.caseSensitive, caseSensitive);
      expect(bodyTest.index, index);
      expect(bodyTest.negative, negative);

      final bulkTest = filterTests.bulkTests.first;
      expect(bulkTest.index, index);
      expect(bulkTest.negative, negative);

      final contactRankingTest = filterTests.contactRankingTests.first;
      expect(contactRankingTest.header, header);
      expect(contactRankingTest.index, index);
      expect(contactRankingTest.negative, negative);

      final conversationTest = filterTests.conversationTests.first;
      expect(conversationTest.where, WhereSetting.started);
      expect(conversationTest.index, index);
      expect(conversationTest.negative, negative);

      final currentDayOfWeekTest = filterTests.currentDayOfWeekTests.first;
      expect(currentDayOfWeekTest.values, value);
      expect(currentDayOfWeekTest.index, index);
      expect(currentDayOfWeekTest.negative, negative);

      final currentTimeTest = filterTests.currentTimeTests.first;
      expect(currentTimeTest.dateComparison, DateComparison.before);
      expect(currentTimeTest.time, time);
      expect(currentTimeTest.index, index);
      expect(currentTimeTest.negative, negative);

      final dateTest = filterTests.dateTests.first;
      expect(dateTest.dateComparison, DateComparison.before);
      expect(dateTest.date, date);
      expect(dateTest.index, index);
      expect(dateTest.negative, negative);

      final facebookTest = filterTests.facebookTests.first;
      expect(facebookTest.index, index);
      expect(facebookTest.negative, negative);

      final flaggedTest = filterTests.flaggedTests.first;
      expect(flaggedTest.flag, FilterFlagName.flagged);
      expect(flaggedTest.index, index);
      expect(flaggedTest.negative, negative);

      final headerExistsTest = filterTests.headerExistsTests.first;
      expect(headerExistsTest.header, header);
      expect(headerExistsTest.index, index);
      expect(headerExistsTest.negative, negative);

      final headerTest = filterTests.headerTests.first;
      expect(headerTest.headers, header);
      expect(headerTest.stringComparison, StringComparison.contains);
      expect(headerTest.valueComparison, ValueComparison.equal);
      expect(headerTest.countComparison, CountComparison.equal);
      expect(headerTest.valueComparisonComparator, ComparisonComparator.asciiNumeric);
      expect(headerTest.value, value);
      expect(headerTest.caseSensitive, caseSensitive);
      expect(headerTest.index, index);
      expect(headerTest.negative, negative);

      final importanceTest = filterTests.importanceTests.first;
      expect(importanceTest.importance, Importance.normal);
      expect(importanceTest.index, index);
      expect(importanceTest.negative, negative);

      final inviteTest = filterTests.inviteTests.first;
      expect(inviteTest.methods.first, method);
      expect(inviteTest.index, index);
      expect(inviteTest.negative, negative);

      final linkedinTest = filterTests.linkedinTests.first;
      expect(linkedinTest.index, index);
      expect(linkedinTest.negative, negative);

      final listTest = filterTests.listTests.first;
      expect(listTest.index, index);
      expect(listTest.negative, negative);

      final meTest = filterTests.meTests.first;
      expect(meTest.header, header);
      expect(meTest.index, index);
      expect(meTest.negative, negative);

      final mimeHeaderTest = filterTests.mimeHeaderTests.first;
      expect(mimeHeaderTest.headers, header);
      expect(mimeHeaderTest.stringComparison, StringComparison.contains);
      expect(mimeHeaderTest.value, value);
      expect(mimeHeaderTest.caseSensitive, caseSensitive);
      expect(mimeHeaderTest.index, index);
      expect(mimeHeaderTest.negative, negative);

      final sizeTest = filterTests.sizeTests.first;
      expect(sizeTest.numberComparison, NumberComparison.over);
      expect(sizeTest.size, size);
      expect(sizeTest.index, index);
      expect(sizeTest.negative, negative);

      final socialcastTest = filterTests.socialcastTests.first;
      expect(socialcastTest.index, index);
      expect(socialcastTest.negative, negative);

      final trueTest = filterTests.trueTests.first;
      expect(trueTest.index, index);
      expect(trueTest.negative, negative);

      final twitterTest = filterTests.twitterTests.first;
      expect(twitterTest.index, index);
      expect(twitterTest.negative, negative);

      final communityRequestsTest = filterTests.communityRequestsTests.first;
      expect(communityRequestsTest.index, index);
      expect(communityRequestsTest.negative, negative);

      final communityContentTest = filterTests.communityContentTests.first;
      expect(communityContentTest.index, index);
      expect(communityContentTest.negative, negative);

      final communityConnectionsTest = filterTests.communityConnectionsTests.first;
      expect(communityConnectionsTest.index, index);
      expect(communityConnectionsTest.negative, negative);

      final filterActions = filterRule.filterActions!;
      final filterVars = filterActions.filterVariables.first;
      expect(filterVars.index, index);
      expect(filterVars.variables.first.name, name);
      expect(filterVars.variables.first.value, value);

      final actionKeep = filterActions.keepActions.first;
      expect(actionKeep.index, index);

      final actionDiscard = filterActions.discardActions.first;
      expect(actionDiscard.index, index);

      final actionFileInto = filterActions.fileIntoActions.first;
      expect(actionFileInto.folder, folder);
      expect(actionFileInto.copy, copy);
      expect(actionFileInto.index, index);

      final actionFlag = filterActions.flagActions.first;
      expect(actionFlag.flag, FilterFlagName.flagged);
      expect(actionFlag.index, index);

      final actionTag = filterActions.tagActions.first;
      expect(actionTag.tag, tag);
      expect(actionTag.index, index);

      final actionRedirect = filterActions.redirectActions.first;
      expect(actionRedirect.address, address);
      expect(actionRedirect.copy, copy);
      expect(actionRedirect.index, index);

      final actionReply = filterActions.replyActions.first;
      expect(actionReply.content, content);
      expect(actionReply.index, index);

      final actionNotify = filterActions.notifyActions.first;
      expect(actionNotify.address, address);
      expect(actionNotify.subject, subject);
      expect(actionNotify.maxBodySize, maxBodySize);
      expect(actionNotify.content, content);
      expect(actionNotify.origHeaders, origHeaders);
      expect(actionNotify.index, index);

      final actionRFC = filterActions.rfcCompliantNotifyActions.first;
      expect(actionRFC.from, from);
      expect(actionRFC.importance, importance);
      expect(actionRFC.options, options);
      expect(actionRFC.message, message);
      expect(actionRFC.method, method);
      expect(actionRFC.index, index);

      final actionStop = filterActions.stopActions.first;
      expect(actionStop.index, index);

      final actionReject = filterActions.rejectActions.first;
      expect(actionReject.content, content);
      expect(actionReject.index, index);

      final actionEreject = filterActions.erejectActions.first;
      expect(actionEreject.content, content);
      expect(actionEreject.index, index);

      final actionLog = filterActions.logActions.first;
      expect(actionLog.level, LoggingLevel.info);
      expect(actionLog.content, content);
      expect(actionLog.index, index);

      final actionAddheader = filterActions.addheaderActions.first;
      expect(actionAddheader.headerName, header);
      expect(actionAddheader.headerValue, value);
      expect(actionAddheader.last, last);
      expect(actionAddheader.index, index);

      final actionDeleteheader = filterActions.deleteheaderActions.first;
      expect(actionDeleteheader.last, last);
      expect(actionDeleteheader.offset, offset);
      expect(actionDeleteheader.index, index);

      final testDeleteheader = actionDeleteheader.test!;
      expect(testDeleteheader.matchType, MatchType.value);
      expect(testDeleteheader.countComparator, countComparator);
      expect(testDeleteheader.valueComparator, valueComparator);
      expect(testDeleteheader.relationalComparator, RelationalComparator.equal);
      expect(testDeleteheader.comparator, ComparisonComparator.asciiNumeric);
      expect(testDeleteheader.headerName, header);
      expect(testDeleteheader.headerValue.first, value);

      final actionReplaceheader = filterActions.replaceheaderActions.first;
      expect(actionReplaceheader.newName, name);
      expect(actionReplaceheader.newValue, value);
      expect(actionReplaceheader.last, last);
      expect(actionReplaceheader.offset, offset);
      expect(actionReplaceheader.index, index);

      final testReplaceheader = actionReplaceheader.test!;
      expect(testReplaceheader.matchType, MatchType.value);
      expect(testReplaceheader.countComparator, countComparator);
      expect(testReplaceheader.valueComparator, valueComparator);
      expect(testReplaceheader.relationalComparator, RelationalComparator.equal);
      expect(testReplaceheader.comparator, ComparisonComparator.asciiNumeric);
      expect(testReplaceheader.headerName, header);
      expect(testReplaceheader.headerValue.first, value);

      final nestedRule = filterRule.child!;
      expect(nestedRule.child, isNotNull);
      expect(nestedRule.child, isA<NestedRule>());

      final nestedFilterVars = nestedRule.filterVariables!;
      expect(nestedFilterVars.index, index);
      expect(nestedFilterVars.variables.first.name, name);
      expect(nestedFilterVars.variables.first.value, value);

      final nestedFilterTests = nestedRule.filterTests!;
      expect(nestedFilterTests.condition, FilterCondition.allof);

      final nestedFilterActions = nestedRule.filterActions!;
      final nestedFAFilterVars = nestedFilterActions.filterVariables.first;
      expect(nestedFAFilterVars.index, index);
      expect(nestedFAFilterVars.variables.first.name, name);
      expect(nestedFAFilterVars.variables.first.value, value);
    }));

    test('Get permissions test', (() async {
      final right = faker.lorem.word();
      final zimbraId = faker.guid.guid();
      final displayName = faker.person.name();
      final password = faker.internet.password();
      final accessKey = faker.internet.password();
      final deny = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GetPermissionResponse': {
            '_jsns': 'urn:zimbraMail',
            'ace': [
              {
                'gt': GranteeType.all.name,
                'right': right,
                'zid': zimbraId,
                'd': displayName,
                'pw': password,
                'key': accessKey,
                'deny': deny,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getPermission();
      final ace = response!.aces.first;

      expect(ace.granteeType, GranteeType.all);
      expect(ace.right, right);
      expect(ace.zimbraId, zimbraId);
      expect(ace.displayName, displayName);
      expect(ace.password, password);
      expect(ace.accessKey, accessKey);
      expect(ace.deny, deny);
    }));

    test('Get recurrence test', (() async {
      final id = faker.guid.guid();
      final name = faker.lorem.word();
      final value = faker.lorem.word();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final dateTimeString = faker.date.dateTime().toString();
      final timezone = faker.address.countryCode();
      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final utcTime = faker.date.dateTime().millisecondsSinceEpoch;
      final recurIdZ = faker.date.dateTime().toString();
      final recurrenceId = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final data = {
        'Body': {
          'GetRecurResponse': {
            '_jsns': 'urn:zimbraMail',
            'tz': {
              'id': id,
              'stdoff': tzStdOffset,
              'dayoff': tzDayOffset,
              'standard': {
                'mon': month,
                'hour': hour,
                'min': minute,
                'sec': second,
                'mday': dayOfMonth,
                'week': week,
                'wkday': dayOfWeek,
              },
              'daylight': {
                'mon': month,
                'hour': hour,
                'min': minute,
                'sec': second,
                'mday': dayOfMonth,
                'week': week,
                'wkday': dayOfWeek,
              },
              'stdname': standardTZName,
              'dayname': daylightTZName,
            },
            'comp': {
              'exceptId': {
                'd': dateTimeString,
                'tz': timezone,
                'rangeType': recurrenceRangeType,
              },
              's': {
                'd': dateTimeString,
                'tz': timezone,
                'u': utcTime,
              },
              'e': {
                'd': dateTimeString,
                'tz': timezone,
                'u': utcTime,
              },
              'dur': {
                'neg': durationNegative,
                'w': weeks,
                'd': days,
                'h': hours,
                'm': minutes,
                's': seconds,
                'related': AlarmRelated.start.name,
                'count': repeatCount,
              },
              'recur': {
                'add': [
                  {'add': {}}
                ],
                'exclude': [
                  {'exclude': {}}
                ],
                'except': [
                  {
                    'rangeType': recurrenceRangeType,
                    'recurId': recurrenceId,
                    'tz': timezone,
                    'ridZ': recurIdZ,
                    'add': {'add': []},
                    'exclude': {'exclude': []},
                  }
                ],
                'cancel': [
                  {
                    'rangeType': recurrenceRangeType,
                    'recurId': recurrenceId,
                    'tz': timezone,
                    'ridZ': recurIdZ,
                  }
                ],
                'dates': [
                  {
                    'tz': timezone,
                    'dtval': [
                      {
                        's': {
                          'd': dateTimeString,
                          'tz': timezone,
                          'u': utcTime,
                        },
                        'e': {
                          'd': dateTimeString,
                          'tz': timezone,
                          'u': utcTime,
                        },
                        'dur': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': AlarmRelated.start.name,
                          'count': repeatCount,
                        },
                      }
                    ],
                  }
                ],
                'rule': [
                  {
                    'freq': Frequency.second.name,
                    'until': {
                      'd': dateTimeString,
                    },
                    'count': {
                      'num': num,
                    },
                    'interval': {
                      'ival': ival,
                    },
                    'bysecond': {
                      'seclist': list,
                    },
                    'byminute': {
                      'minlist': list,
                    },
                    'byhour': {
                      'hrlist': list,
                    },
                    'byday': {
                      'wkday': [
                        {
                          'day': WeekDay.sunday.name,
                          'ordWk': ordWk,
                        }
                      ],
                    },
                    'bymonthday': {
                      'modaylist': list,
                    },
                    'byyearday': {
                      'yrdaylist': list,
                    },
                    'byweekno': {
                      'wklist': list,
                    },
                    'bymonth': {
                      'molist': list,
                    },
                    'bysetpos': {
                      'poslist': list,
                    },
                    'wkst': {
                      'day': WeekDay.sunday.name,
                    },
                    'rule-x-name': [
                      {
                        'name': name,
                        'value': value,
                      }
                    ],
                  }
                ],
              },
            },
            'cancel': {
              's': {
                'd': dateTimeString,
                'tz': timezone,
                'u': utcTime,
              },
              'e': {
                'd': dateTimeString,
                'tz': timezone,
                'u': utcTime,
              },
            },
            'except': {
              's': {
                'd': dateTimeString,
                'tz': timezone,
                'u': utcTime,
              },
              'e': {
                'd': dateTimeString,
                'tz': timezone,
                'u': utcTime,
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getRecur(id);

      final tz = response!.timezone!;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standardTzOnset = tz.standardTzOnset!;
      expect(standardTzOnset.month, month);
      expect(standardTzOnset.hour, hour);
      expect(standardTzOnset.minute, minute);
      expect(standardTzOnset.second, second);
      expect(standardTzOnset.dayOfMonth, dayOfMonth);
      expect(standardTzOnset.week, week);
      expect(standardTzOnset.dayOfWeek, dayOfWeek);

      final daylightTzOnset = tz.daylightTzOnset!;
      expect(daylightTzOnset.month, month);
      expect(daylightTzOnset.hour, hour);
      expect(daylightTzOnset.minute, minute);
      expect(daylightTzOnset.second, second);
      expect(daylightTzOnset.dayOfMonth, dayOfMonth);
      expect(daylightTzOnset.week, week);
      expect(daylightTzOnset.dayOfWeek, dayOfWeek);

      final inviteComponent = response.inviteComponent!;

      final exceptionId = inviteComponent.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final inviteDtStart = inviteComponent.dtStart!;
      expect(inviteDtStart.dateTime, dateTimeString);
      expect(inviteDtStart.timezone, timezone);
      expect(inviteDtStart.utcTime, utcTime);

      final inviteDtEnd = inviteComponent.dtEnd!;
      expect(inviteDtEnd.dateTime, dateTimeString);
      expect(inviteDtEnd.timezone, timezone);
      expect(inviteDtEnd.utcTime, utcTime);

      final inviteDuration = inviteComponent.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);

      final inviteRecurrence = inviteComponent.recurrence!;
      expect(inviteRecurrence.add.first, isA<AddRecurrenceInfo>());
      expect(inviteRecurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final inviteExcept = inviteRecurrence.except.first;
      expect(inviteExcept.recurrenceRangeType, recurrenceRangeType);
      expect(inviteExcept.recurrenceId, recurrenceId);
      expect(inviteExcept.timezone, timezone);
      expect(inviteExcept.recurIdZ, recurIdZ);
      expect(inviteExcept.add, isA<RecurrenceInfo>());
      expect(inviteExcept.exclude, isA<RecurrenceInfo>());

      final inviteCancel = inviteRecurrence.cancel.first;
      expect(inviteCancel.recurrenceRangeType, recurrenceRangeType);
      expect(inviteCancel.recurrenceId, recurrenceId);
      expect(inviteCancel.timezone, timezone);
      expect(inviteCancel.recurIdZ, recurIdZ);

      final inviteDates = inviteRecurrence.dates.first;
      expect(inviteDates.timezone, timezone);

      final inviteDateStartTime = inviteDates.dtVals.first.startTime!;
      expect(inviteDateStartTime.dateTime, dateTimeString);
      expect(inviteDateStartTime.timezone, timezone);
      expect(inviteDateStartTime.utcTime, utcTime);

      final inviteDateEndTime = inviteDates.dtVals.first.endTime!;
      expect(inviteDateEndTime.dateTime, dateTimeString);
      expect(inviteDateEndTime.timezone, timezone);
      expect(inviteDateEndTime.utcTime, utcTime);

      final inviteDateDuration = inviteDates.dtVals.first.duration!;
      expect(inviteDateDuration.durationNegative, durationNegative);
      expect(inviteDateDuration.weeks, weeks);
      expect(inviteDateDuration.days, days);
      expect(inviteDateDuration.hours, hours);
      expect(inviteDateDuration.minutes, minutes);
      expect(inviteDateDuration.seconds, seconds);
      expect(inviteDateDuration.related, AlarmRelated.start);
      expect(inviteDateDuration.repeatCount, repeatCount);

      final inviteSimple = inviteRecurrence.simple.first;
      expect(inviteSimple.until!.dateTime, dateTimeString);
      expect(inviteSimple.count!.num, num);
      expect(inviteSimple.interval!.ival, ival);
      expect(inviteSimple.bySecond!.list, list);
      expect(inviteSimple.byMinute!.list, list);
      expect(inviteSimple.byHour!.list, list);
      expect(inviteSimple.byDay!.days.first.day, WeekDay.sunday);
      expect(inviteSimple.byDay!.days.first.ordWk, ordWk);
      expect(inviteSimple.byMonthDay!.list, list);
      expect(inviteSimple.byYearDay!.list, list);
      expect(inviteSimple.byWeekNo!.list, list);
      expect(inviteSimple.byMonth!.list, list);
      expect(inviteSimple.bySetPose!.list, list);
      expect(inviteSimple.weekStart!.day, WeekDay.sunday);
      expect(inviteSimple.xNames.first.name, name);
      expect(inviteSimple.xNames.first.value, value);

      final cancelComponent = response.cancelComponent!;
      final cancelDtStart = cancelComponent.dtStart!;
      expect(cancelDtStart.dateTime, dateTimeString);
      expect(cancelDtStart.timezone, timezone);
      expect(cancelDtStart.utcTime, utcTime);

      final cancelDtEnd = cancelComponent.dtEnd!;
      expect(cancelDtEnd.dateTime, dateTimeString);
      expect(cancelDtEnd.timezone, timezone);
      expect(cancelDtEnd.utcTime, utcTime);

      final exceptComponent = response.exceptComponent!;
      final exceptDtStart = exceptComponent.dtStart!;
      expect(exceptDtStart.dateTime, dateTimeString);
      expect(exceptDtStart.timezone, timezone);
      expect(exceptDtStart.utcTime, utcTime);

      final exceptDtEnd = exceptComponent.dtEnd!;
      expect(exceptDtEnd.dateTime, dateTimeString);
      expect(exceptDtEnd.timezone, timezone);
      expect(exceptDtEnd.utcTime, utcTime);
    }));

    test('Get search folders test', (() async {
      final id = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final absoluteFolderPath = faker.lorem.word();
      final parentId = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unreadCount = faker.randomGenerator.integer(100);
      final imapUnreadCount = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().minute;
      final itemCount = faker.randomGenerator.integer(100);
      final imapItemCount = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final imapModifiedSequence = faker.randomGenerator.integer(100);
      final imapUidNext = faker.randomGenerator.integer(100);
      final url = faker.internet.httpsUrl();
      final activeSyncDisabled = faker.randomGenerator.boolean();
      final webOfflineSyncDays = faker.randomGenerator.integer(100);
      final perm = faker.lorem.word();
      final recursive = faker.randomGenerator.boolean();
      final restUrl = faker.internet.httpsUrl();
      final deletable = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final lifetime = faker.randomGenerator.integer(100).toString();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);

      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();

      final ownerEmail = faker.internet.email();
      final ownerAccountId = faker.guid.guid();
      final remoteFolderId = faker.randomGenerator.integer(100);
      final remoteUuid = faker.guid.guid();
      final remoteFolderName = faker.lorem.word();
      final reminderEnabled = faker.randomGenerator.boolean();
      final broken = faker.randomGenerator.boolean();

      final query = faker.lorem.word();
      final types = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'GetSearchFolderResponse': {
            '_jsns': 'urn:zimbraMail',
            'search': [
              {
                'id': id,
                'uuid': uuid,
                'name': name,
                'query': query,
                'sortBy': SearchSortBy.none.name,
                'types': types,
                'absFolderPath': absoluteFolderPath,
                'l': parentId,
                'luuid': folderUuid,
                'f': flags,
                'color': color,
                'rgb': rgb,
                'u': unreadCount,
                'i4u': imapUnreadCount,
                'view': ViewType.conversation.name,
                'rev': revision,
                'ms': modifiedSequence,
                'md': changeDate,
                'n': itemCount,
                'i4n': imapItemCount,
                's': totalSize,
                'i4ms': imapModifiedSequence,
                'i4next': imapUidNext,
                'url': url,
                'activesyncdisabled': activeSyncDisabled,
                'webOfflineSyncDays': webOfflineSyncDays,
                'perm': perm,
                'recursive': recursive,
                'rest': restUrl,
                'deletable': deletable,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'acl': {
                  'internalGrantExpiry': internalGrantExpiry,
                  'guestGrantExpiry': guestGrantExpiry,
                  'grant': [
                    {
                      'perm': perm,
                      'gt': GrantGranteeType.all.name,
                      'zid': granteeId,
                      'expiry': expiry,
                      'd': granteeName,
                      'pw': guestPassword,
                      'key': accessKey,
                    }
                  ],
                },
                'folder': [
                  {
                    'id': id,
                    'uuid': uuid,
                    'name': name,
                  }
                ],
                'link': [
                  {
                    'id': id,
                    'name': name,
                    'owner': ownerEmail,
                    'zid': ownerAccountId,
                    'rid': remoteFolderId,
                    'ruuid': remoteUuid,
                    'oname': remoteFolderName,
                    'reminder': reminderEnabled,
                    'broken': broken,
                  }
                ],
                'search': [
                  {
                    'id': id,
                    'name': name,
                    'query': query,
                    'sortBy': SearchSortBy.none.name,
                    'types': types,
                  }
                ],
                'retentionPolicy': [
                  {
                    'keep': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                    'purge': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                  }
                ],
              },
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getSearchFolder();
      final searchFolder = response!.searchFolders.first;

      expect(searchFolder.id, id);
      expect(searchFolder.uuid, uuid);
      expect(searchFolder.name, name);
      expect(searchFolder.query, query);
      expect(searchFolder.sortBy, SearchSortBy.none);
      expect(searchFolder.types, types);
      expect(searchFolder.absoluteFolderPath, absoluteFolderPath);
      expect(searchFolder.parentId, parentId);
      expect(searchFolder.folderUuid, folderUuid);
      expect(searchFolder.flags, flags);
      expect(searchFolder.color, color);
      expect(searchFolder.rgb, rgb);
      expect(searchFolder.unreadCount, unreadCount);
      expect(searchFolder.imapUnreadCount, imapUnreadCount);
      expect(searchFolder.view, ViewType.conversation);
      expect(searchFolder.revision, revision);
      expect(searchFolder.modifiedSequence, modifiedSequence);
      expect(searchFolder.changeDate, changeDate);
      expect(searchFolder.itemCount, itemCount);
      expect(searchFolder.imapItemCount, imapItemCount);
      expect(searchFolder.totalSize, totalSize);
      expect(searchFolder.imapModifiedSequence, imapModifiedSequence);
      expect(searchFolder.imapUidNext, imapUidNext);
      expect(searchFolder.url, url);
      expect(searchFolder.activeSyncDisabled, activeSyncDisabled);
      expect(searchFolder.webOfflineSyncDays, webOfflineSyncDays);
      expect(searchFolder.perm, perm);
      expect(searchFolder.recursive, recursive);
      expect(searchFolder.restUrl, restUrl);
      expect(searchFolder.deletable, deletable);

      final meta = searchFolder.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final acl = searchFolder.acl!;
      expect(acl.internalGrantExpiry, internalGrantExpiry);
      expect(acl.guestGrantExpiry, guestGrantExpiry);

      final grant = acl.grants.first;
      expect(grant.perm, perm);
      expect(grant.granteeType, GrantGranteeType.all);
      expect(grant.granteeId, granteeId);
      expect(grant.expiry, expiry);
      expect(grant.granteeName, granteeName);
      expect(grant.guestPassword, guestPassword);
      expect(grant.accessKey, accessKey);

      final subFolder = searchFolder.subFolders.first;
      expect(subFolder.id, id);
      expect(subFolder.uuid, uuid);
      expect(subFolder.name, name);
      expect(subFolder, isA<Folder>());

      final link = searchFolder.mountpoints.first;
      expect(link.id, id);
      expect(link.name, name);
      expect(link.ownerEmail, ownerEmail);
      expect(link.ownerAccountId, ownerAccountId);
      expect(link.remoteFolderId, remoteFolderId);
      expect(link.remoteUuid, remoteUuid);
      expect(link.remoteFolderName, remoteFolderName);
      expect(link.reminderEnabled, reminderEnabled);
      expect(link.broken, broken);
      expect(link, isA<Folder>());

      final search = searchFolder.searchFolders.first;
      expect(search.id, id);
      expect(search.name, name);
      expect(search.query, query);
      expect(search.sortBy, SearchSortBy.none);
      expect(search.types, types);
      expect(search, isA<Folder>());

      final retentionPolicy = searchFolder.retentionPolicy!;
      final keep = retentionPolicy.keep.first;
      final purge = retentionPolicy.purge.first;
      expect(keep.type, PolicyType.user);
      expect(keep.id, id);
      expect(keep.name, name);
      expect(keep.lifetime, lifetime);
      expect(purge.type, PolicyType.user);
      expect(purge.id, id);
      expect(purge.name, name);
      expect(purge.lifetime, lifetime);
    }));

    test('Get share notifications test', (() async {
      final id = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final email = faker.internet.email();
      final status = faker.lorem.word();
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final defaultView = faker.lorem.word();
      final rights = faker.lorem.word();

      final data = {
        'Body': {
          'GetShareNotificationsResponse': {
            '_jsns': 'urn:zimbraMail',
            'share': [
              {
                'status': status,
                'id': id,
                'd': date,
                'grantor': {
                  'id': id,
                  'email': email,
                  'name': name,
                },
                'link': {
                  'id': id,
                  'uuid': uuid,
                  'name': name,
                  'view': defaultView,
                  'perm': rights,
                },
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getShareNotifications();
      final share = response!.shares.first;

      expect(share.status, status);
      expect(share.id, id);
      expect(share.date, date);

      final grantor = share.grantor!;
      expect(grantor.id, id);
      expect(grantor.email, email);
      expect(grantor.name, name);

      final link = share.link!;
      expect(link.id, id);
      expect(link.uuid, uuid);
      expect(link.name, name);
      expect(link.defaultView, defaultView);
      expect(link.rights, rights);
    }));

    test('Get spell dictionaries test', (() async {
      final dictionary1 = faker.lorem.word();
      final dictionary2 = faker.lorem.word();

      final data = {
        'Body': {
          'GetSpellDictionariesResponse': {
            '_jsns': 'urn:zimbraMail',
            'dictionary': [
              {'_content': dictionary1},
              {'_content': dictionary2},
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getSpellDictionaries();
      expect(response!.dictionaries, [dictionary1, dictionary2]);
    }));

    test('Get system retention policy test', (() async {
      final id = faker.guid.guid();
      final name = faker.lorem.word();
      final lifetime = faker.lorem.word();

      final data = {
        'Body': {
          'GetSystemRetentionPolicyResponse': {
            '_jsns': 'urn:zimbraMail',
            'retentionPolicy': [
              {
                'keep': [
                  {
                    'policy': [
                      {
                        'type': PolicyType.system.name,
                        'id': id,
                        'name': name,
                        'lifetime': lifetime,
                      }
                    ]
                  }
                ],
                'purge': [
                  {
                    'policy': [
                      {
                        'type': PolicyType.system.name,
                        'id': id,
                        'name': name,
                        'lifetime': lifetime,
                      }
                    ]
                  }
                ],
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getSystemRetentionPolicy();
      final retentionPolicy = response!.retentionPolicy!;

      final keep = retentionPolicy.keep.first;
      expect(keep.id, id);
      expect(keep.name, name);
      expect(keep.lifetime, lifetime);
      expect(keep.type, PolicyType.system);

      final purge = retentionPolicy.purge.first;
      expect(purge.id, id);
      expect(purge.name, name);
      expect(purge.lifetime, lifetime);
      expect(purge.type, PolicyType.system);
    }));

    test('Get tag test', (() async {
      final id = faker.guid.guid();
      final name = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unread = faker.randomGenerator.integer(100);
      final count = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final lifetime = faker.randomGenerator.integer(100).toString();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final data = {
        'Body': {
          'GetTagResponse': {
            '_jsns': 'urn:zimbraMail',
            'tag': [
              {
                'id': id,
                'name': name,
                'color': color,
                'rgb': rgb,
                'u': unread,
                'n': count,
                'd': date,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'retentionPolicy': [
                  {
                    'keep': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                    'purge': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                  }
                ],
              },
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getTag();
      final tag = response!.tags.first;

      expect(tag.id, id);
      expect(tag.name, name);
      expect(tag.color, color);
      expect(tag.rgb, rgb);
      expect(tag.unread, unread);
      expect(tag.count, count);
      expect(tag.date, date);
      expect(tag.revision, revision);
      expect(tag.changeDate, changeDate);
      expect(tag.modifiedSequence, modifiedSequence);

      final meta = tag.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final retentionPolicy = tag.retentionPolicy!;
      final keep = retentionPolicy.keep.first;
      final purge = retentionPolicy.purge.first;
      expect(keep.type, PolicyType.user);
      expect(keep.id, id);
      expect(keep.name, name);
      expect(keep.lifetime, lifetime);
      expect(purge.type, PolicyType.user);
      expect(purge.id, id);
      expect(purge.name, name);
      expect(purge.lifetime, lifetime);
    }));

    test('Get task summaries test', (() async {
      final id = faker.guid.guid();
      final name = faker.lorem.word();
      final value = faker.lorem.word();
      final category = faker.lorem.word();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final summary = faker.lorem.word();

      final address = faker.internet.email();
      final url = faker.internet.httpsUrl();
      final displayName = faker.person.name();
      final sentBy = faker.internet.email();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();

      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final xUid = faker.guid.guid();
      final uid = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final folderId = faker.guid.guid();
      final size = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final duration = faker.randomGenerator.integer(100);
      final recurIdZ = faker.date.dateTime().toString();
      final tzOffset = faker.randomGenerator.integer(100);
      final taskPercentComplete = faker.lorem.word();
      final isRecurring = faker.randomGenerator.boolean();
      final hasExceptions = faker.randomGenerator.boolean();
      final isException = faker.randomGenerator.boolean();
      final priority = faker.lorem.word();
      final location = faker.lorem.word();
      final hasOtherAttendees = faker.randomGenerator.boolean();
      final hasAlarm = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final invId = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);
      final allDay = faker.randomGenerator.boolean();
      final draft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final taskDueDate = faker.randomGenerator.integer(100);
      final taskTzOffsetDue = faker.randomGenerator.integer(100);

      final nextAlarm = faker.date.dateTime().millisecondsSinceEpoch;
      final alarmInstanceStart = faker.date.dateTime().millisecondsSinceEpoch;
      final dateTimeString = faker.date.dateTime().toString();
      final startTime = faker.date.dateTime().millisecondsSinceEpoch;

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final uri = faker.internet.uri('http');
      final contentType = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final data = {
        'Body': {
          'GetTaskSummariesResponse': {
            '_jsns': 'urn:zimbraMail',
            'appt': [
              {
                'or': {
                  'a': address,
                  'url': url,
                  'd': displayName,
                  'sentBy': sentBy,
                  'dir': dir,
                  'lang': language,
                  'xparam': [
                    {
                      'name': name,
                      'value': value,
                    }
                  ],
                },
                'category': [
                  {'_content': category}
                ],
                'geo': {
                  'lat': latitude,
                  'lon': longitude,
                },
                'fr': fragment,
                'x_uid': xUid,
                'uid': uid,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'l': folderId,
                's': size,
                'md': changeDate,
                'ms': modifiedSequence,
                'rev': revision,
                'id': id,
                'dur': duration,
                'ptst': partStat.name,
                'ridZ': recurIdZ,
                'tzo': tzOffset,
                'fba': FreeBusyStatus.free.name,
                'percentComplete': taskPercentComplete,
                'recur': isRecurring,
                'hasEx': hasExceptions,
                'priority': priority,
                'fb': FreeBusyStatus.free.name,
                'transp': Transparency.opaque.name,
                'name': name,
                'loc': location,
                'otherAtt': hasOtherAttendees,
                'alarm': hasAlarm,
                'isOrg': isOrganizer,
                'invId': invId.toString(),
                'compNum': componentNum,
                'status': InviteStatus.completed.name,
                'class': InviteClass.public.name,
                'allDay': allDay,
                'draft': draft,
                'neverSent': neverSent,
                'dueDate': taskDueDate,
                'tzoDue': taskTzOffsetDue,
                'alarmData': {
                  'nextAlarm': nextAlarm,
                  'alarmInstStart': alarmInstanceStart,
                  'invId': invId,
                  'compNum': componentNum,
                  'name': name,
                  'loc': location,
                  'alarm': {
                    'action': AlarmAction.display.name,
                    'trigger': {
                      'abs': {
                        'd': dateTimeString,
                      },
                      'rel': {
                        'd': dateTimeString,
                      },
                    },
                    'repeat': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'desc': {'_content': description},
                    'attach': {
                      'uri': uri,
                      'ct': contentType,
                      '_content': binaryB64Data,
                    },
                    'summary': {'_content': summary},
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                },
                'inst': [
                  {
                    's': startTime,
                    'ex': isException,
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'category': [
                      {'_content': category}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'fr': fragment,
                    'd': duration,
                    'ptst': partStat.name,
                    'ridZ': recurIdZ,
                    'tzo': tzOffset,
                    'fba': FreeBusyStatus.free.name,
                    'percentComplete': taskPercentComplete,
                    'recur': isRecurring,
                    'hasEx': hasExceptions,
                    'priority': priority,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'name': name,
                    'loc': location,
                    'otherAtt': hasOtherAttendees,
                    'alarm': hasAlarm,
                    'isOrg': isOrganizer,
                    'invId': invId.toString(),
                    'compNum': componentNum,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'allDay': allDay,
                    'draft': draft,
                    'neverSent': neverSent,
                    'dueDate': taskDueDate,
                    'tzoDue': taskTzOffsetDue,
                  }
                ],
              }
            ],
            'task': [
              {
                'x_uid': xUid,
                'uid': uid,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'l': folderId,
                's': size,
                'md': changeDate,
                'ms': modifiedSequence,
                'rev': revision,
                'id': id,
                'dur': duration,
                'ptst': partStat.name,
                'ridZ': recurIdZ,
                'tzo': tzOffset,
                'fba': FreeBusyStatus.free.name,
                'percentComplete': taskPercentComplete,
                'recur': isRecurring,
                'hasEx': hasExceptions,
                'priority': priority,
                'fb': FreeBusyStatus.free.name,
                'transp': Transparency.opaque.name,
                'name': name,
                'loc': location,
                'otherAtt': hasOtherAttendees,
                'alarm': hasAlarm,
                'isOrg': isOrganizer,
                'invId': invId.toString(),
                'compNum': componentNum,
                'status': InviteStatus.completed.name,
                'class': InviteClass.public.name,
                'allDay': allDay,
                'draft': draft,
                'neverSent': neverSent,
                'dueDate': taskDueDate,
                'tzoDue': taskTzOffsetDue,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getTaskSummaries(0, 0);

      final appt = response!.apptEntries.first;
      expect(appt.fragment, fragment);
      expect(appt.xUid, xUid);
      expect(appt.uid, uid);
      expect(appt.flags, flags);
      expect(appt.tags, tags);
      expect(appt.tagNames, tagNames);
      expect(appt.folderId, folderId);
      expect(appt.size, size);
      expect(appt.changeDate, changeDate);
      expect(appt.modifiedSequence, modifiedSequence);
      expect(appt.revision, revision);
      expect(appt.id, id);
      expect(appt.partStat, partStat);
      expect(appt.recurIdZ, recurIdZ);
      expect(appt.tzOffset, tzOffset);
      expect(appt.freeBusyActual, FreeBusyStatus.free);
      expect(appt.taskPercentComplete, taskPercentComplete);
      expect(appt.isRecurring, isRecurring);
      expect(appt.hasExceptions, hasExceptions);
      expect(appt.priority, priority);
      expect(appt.freeBusyIntended, FreeBusyStatus.free);
      expect(appt.transparency, Transparency.opaque);
      expect(appt.name, name);
      expect(appt.location, location);
      expect(appt.hasOtherAttendees, hasOtherAttendees);
      expect(appt.hasAlarm, hasAlarm);
      expect(appt.isOrganizer, isOrganizer);
      expect(appt.invId, invId.toString());
      expect(appt.componentNum, componentNum);
      expect(appt.status, InviteStatus.completed);
      expect(appt.calClass, InviteClass.public);
      expect(appt.allDay, allDay);
      expect(appt.draft, draft);
      expect(appt.neverSent, neverSent);
      expect(appt.taskDueDate, taskDueDate);
      expect(appt.taskTzOffsetDue, taskTzOffsetDue);
      expect(appt.categories.first, category);

      final or = appt.organizer!;
      expect(or.address, address);
      expect(or.url, url);
      expect(or.displayName, displayName);
      expect(or.sentBy, sentBy);
      expect(or.dir, dir);
      expect(or.language, language);
      expect(or.xParams.first.name, name);
      expect(or.xParams.first.value, value);

      final geo = appt.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final inst = appt.instances.first;
      expect(inst.startTime, startTime);
      expect(inst.fragment, fragment);
      expect(inst.isException, isException);
      expect(inst.duration, duration);
      expect(inst.partStat, partStat);
      expect(inst.recurIdZ, recurIdZ);
      expect(inst.tzOffset, tzOffset);
      expect(inst.freeBusyActual, FreeBusyStatus.free);
      expect(inst.taskPercentComplete, taskPercentComplete);
      expect(inst.isRecurring, isRecurring);
      expect(inst.hasExceptions, hasExceptions);
      expect(inst.priority, priority);
      expect(inst.freeBusyIntended, FreeBusyStatus.free);
      expect(inst.transparency, Transparency.opaque);
      expect(inst.name, name);
      expect(inst.location, location);
      expect(inst.hasOtherAttendees, hasOtherAttendees);
      expect(inst.hasAlarm, hasAlarm);
      expect(inst.isOrganizer, isOrganizer);
      expect(inst.invId, invId.toString());
      expect(inst.componentNum, componentNum);
      expect(inst.status, InviteStatus.completed);
      expect(inst.calClass, InviteClass.public);
      expect(inst.allDay, allDay);
      expect(inst.draft, draft);
      expect(inst.neverSent, neverSent);
      expect(inst.taskDueDate, taskDueDate);
      expect(inst.taskTzOffsetDue, taskTzOffsetDue);
      expect(inst.categories.first, category);

      final orInst = inst.organizer!;
      expect(orInst.address, address);
      expect(orInst.url, url);
      expect(orInst.displayName, displayName);
      expect(orInst.sentBy, sentBy);
      expect(orInst.dir, dir);
      expect(orInst.language, language);
      expect(orInst.xParams.first.name, name);
      expect(orInst.xParams.first.value, value);

      final geoInst = inst.geo!;
      expect(geoInst.latitude, latitude);
      expect(geoInst.longitude, longitude);

      final alarmData = appt.alarmData!;
      expect(alarmData.nextAlarm, nextAlarm);
      expect(alarmData.alarmInstanceStart, alarmInstanceStart);
      expect(alarmData.invId, invId);
      expect(alarmData.componentNum, componentNum);
      expect(alarmData.name, name);
      expect(alarmData.location, location);

      final alarm = alarmData.alarm!;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);

      final trigger = alarm.trigger!;
      expect(trigger.absolute!.date, dateTimeString);
      expect(trigger.relative!.date, dateTimeString);

      final repeat = alarm.repeat!;
      expect(repeat.durationNegative, durationNegative);
      expect(repeat.weeks, weeks);
      expect(repeat.days, days);
      expect(repeat.hours, hours);
      expect(repeat.minutes, minutes);
      expect(repeat.seconds, seconds);
      expect(repeat.related, AlarmRelated.start);
      expect(repeat.repeatCount, repeatCount);

      final attach = alarm.attach!;
      expect(attach.uri, uri);
      expect(attach.contentType, contentType);
      expect(attach.binaryB64Data, binaryB64Data);

      final at = alarm.attendees.first;
      expect(at.address, address);
      expect(at.url, url);
      expect(at.displayName, displayName);
      expect(at.sentBy, sentBy);
      expect(at.dir, dir);
      expect(at.language, language);
      expect(at.cuType, cuType);
      expect(at.role, role);
      expect(at.partStat, partStat);
      expect(at.rsvp, rsvp);
      expect(at.member, member);
      expect(at.delegatedTo, delegatedTo);
      expect(at.delegatedFrom, delegatedFrom);
      expect(at.xParams.first.name, name);
      expect(at.xParams.first.value, value);

      final xprop = alarm.xProps.first;
      expect(xprop.name, name);
      expect(xprop.value, value);
      expect(xprop.xParams.first.name, name);
      expect(xprop.xParams.first.value, value);

      final task = response.taskEntries.first;
      expect(task, isA<LegacyCalendaringData>());
      expect(task.xUid, xUid);
      expect(task.uid, uid);
      expect(task.flags, flags);
      expect(task.tags, tags);
      expect(task.tagNames, tagNames);
      expect(task.folderId, folderId);
      expect(task.size, size);
      expect(task.changeDate, changeDate);
      expect(task.modifiedSequence, modifiedSequence);
      expect(task.revision, revision);
      expect(task.id, id);
      expect(task.partStat, partStat);
      expect(task.recurIdZ, recurIdZ);
      expect(task.tzOffset, tzOffset);
      expect(task.freeBusyActual, FreeBusyStatus.free);
      expect(task.taskPercentComplete, taskPercentComplete);
      expect(task.isRecurring, isRecurring);
      expect(task.hasExceptions, hasExceptions);
      expect(task.priority, priority);
      expect(task.freeBusyIntended, FreeBusyStatus.free);
      expect(task.transparency, Transparency.opaque);
      expect(task.name, name);
      expect(task.location, location);
      expect(task.hasOtherAttendees, hasOtherAttendees);
      expect(task.hasAlarm, hasAlarm);
      expect(task.isOrganizer, isOrganizer);
      expect(task.invId, invId.toString());
      expect(task.componentNum, componentNum);
      expect(task.status, InviteStatus.completed);
      expect(task.calClass, InviteClass.public);
      expect(task.allDay, allDay);
      expect(task.draft, draft);
      expect(task.neverSent, neverSent);
      expect(task.taskDueDate, taskDueDate);
      expect(task.taskTzOffsetDue, taskTzOffsetDue);
    }));

    test('Get task test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final section = faker.lorem.word();

      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final revision = faker.randomGenerator.integer(100);
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final nextAlarm = faker.date.dateTime().millisecondsSinceEpoch;
      final orphan = faker.randomGenerator.boolean();

      final sequence = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);
      final recurrenceId = faker.date.dateTime().toString();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final address = faker.internet.email();
      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final contentType = faker.lorem.word();
      final content = faker.lorem.word();
      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final part = faker.lorem.word();
      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GetTaskResponse': {
            '_jsns': 'urn:zimbraMail',
            'appt': {
              'f': flags,
              't': tags,
              'tn': tagNames,
              'uid': uid,
              'id': id,
              'rev': revision,
              's': size,
              'd': date,
              'l': folder,
              'md': changeDate,
              'ms': modifiedSequence,
              'nextAlarm': nextAlarm,
              'orphan': orphan,
              'inv': [
                {
                  'type': InviteType.appt.name,
                  'seq': sequence,
                  'id': id,
                  'compNum': componentNum,
                  'recurId': recurrenceId,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'comp': {
                    'category': [
                      {'_content': category}
                    ],
                    'comment': [
                      {'_content': comment}
                    ],
                    'contact': [
                      {'_content': contact}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'alarm': [
                      {
                        'action': AlarmAction.display.name,
                        'trigger': {
                          'abs': {
                            'd': dateTimeString,
                          },
                          'rel': {
                            'd': dateTimeString,
                          },
                        },
                        'repeat': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': AlarmRelated.start.name,
                          'count': repeatCount,
                        },
                        'desc': {'_content': description},
                        'attach': {
                          'uri': uri,
                          'ct': contentType,
                          '_content': binaryB64Data,
                        },
                        'summary': {'_content': summary},
                        'at': [
                          {
                            'a': address,
                            'url': url,
                            'd': displayName,
                            'sentBy': sentBy,
                            'dir': dir,
                            'lang': language,
                            'cutype': cuType,
                            'role': role,
                            'ptst': partStat.name,
                            'rsvp': rsvp,
                            'member': member,
                            'delegatedTo': delegatedTo,
                            'delegatedFrom': delegatedFrom,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'xprop': [
                          {
                            'name': name,
                            'value': value,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'fr': fragment,
                    'desc': {'_content': description},
                    'descHtml': {'_content': htmlDescription},
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'recur': {
                      'add': [
                        {'add': {}}
                      ],
                      'exclude': [
                        {'exclude': {}}
                      ],
                      'except': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                          'add': {'add': []},
                          'exclude': {'exclude': []},
                        }
                      ],
                      'cancel': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ],
                      'dates': [
                        {
                          'tz': timezone,
                          'dtval': [
                            {
                              's': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'e': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'dur': {
                                'neg': durationNegative,
                                'w': weeks,
                                'd': days,
                                'h': hours,
                                'm': minutes,
                                's': seconds,
                                'related': AlarmRelated.start.name,
                                'count': repeatCount,
                              },
                            }
                          ],
                        }
                      ],
                      'rule': [
                        {
                          'freq': Frequency.second.name,
                          'until': {
                            'd': dateTimeString,
                          },
                          'count': {
                            'num': num,
                          },
                          'interval': {
                            'ival': ival,
                          },
                          'bysecond': {
                            'seclist': list,
                          },
                          'byminute': {
                            'minlist': list,
                          },
                          'byhour': {
                            'hrlist': list,
                          },
                          'byday': {
                            'wkday': [
                              {
                                'day': WeekDay.sunday.name,
                                'ordWk': ordWk,
                              }
                            ],
                          },
                          'bymonthday': {
                            'modaylist': list,
                          },
                          'byyearday': {
                            'yrdaylist': list,
                          },
                          'byweekno': {
                            'wklist': list,
                          },
                          'bymonth': {
                            'molist': list,
                          },
                          'bysetpos': {
                            'poslist': list,
                          },
                          'wkst': {
                            'day': WeekDay.sunday.name,
                          },
                          'rule-x-name': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    },
                    'exceptId': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'rangeType': recurrenceRangeType,
                    },
                    's': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'e': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'dur': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'method': method,
                    'compNum': componentNum,
                    'rsvp': rsvp,
                    'priority': priority,
                    'name': name,
                    'loc': location,
                    'percentComplete': percentComplete,
                    'completed': completed,
                    'noBlob': noBlob,
                    'fba': FreeBusyStatus.free.name,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'isOrg': isOrganizer,
                    'x_uid': xUid,
                    'uid': uid,
                    'seq': sequence,
                    'd': dateTime,
                    'calItemId': calItemId,
                    'apptId': deprecatedApptId,
                    'ciFolder': calItemFolder,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'url': url,
                    'ex': isException,
                    'ridZ': recurIdZ,
                    'allDay': isAllDay,
                    'draft': isDraft,
                    'neverSent': neverSent,
                    'changes': changes,
                  },
                  'mp': [
                    {
                      'part': part,
                      'ct': contentType,
                      's': size,
                      'cd': contentDisposition,
                      'filename': contentFilename,
                      'ci': contentId,
                      'cl': location,
                      'body': body,
                      'truncated': truncatedContent,
                      'content': content,
                      'mp': [
                        {
                          'part': part,
                          'ct': contentType,
                          's': size,
                          'cd': contentDisposition,
                          'filename': contentFilename,
                          'ci': contentId,
                          'cl': location,
                          'body': body,
                          'truncated': truncatedContent,
                          'content': content,
                        }
                      ],
                    }
                  ],
                  'shr': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                  'dlSubs': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                }
              ],
              'replies': {
                'reply': [
                  {
                    'rangeType': recurrenceRangeType,
                    'recurId': recurrenceId,
                    'seq': sequence,
                    'd': date,
                    'at': attendee,
                    'sentBy': sentBy,
                    'ptst': partStat.name,
                    'tz': timezone,
                    'ridZ': recurIdZ,
                  }
                ]
              },
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
            'task': {
              'f': flags,
              't': tags,
              'tn': tagNames,
              'uid': uid,
              'id': id,
              'rev': revision,
              's': size,
              'd': date,
              'l': folder,
              'md': changeDate,
              'ms': modifiedSequence,
              'nextAlarm': nextAlarm,
              'orphan': orphan,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getTask();
      final appt = response!.appt!;

      expect(appt.flags, flags);
      expect(appt.tags, tags);
      expect(appt.tagNames, tagNames);
      expect(appt.uid, uid);
      expect(appt.id, id);
      expect(appt.revision, revision);
      expect(appt.size, size);
      expect(appt.date, date);
      expect(appt.folder, folder);
      expect(appt.changeDate, changeDate);
      expect(appt.modifiedSequence, modifiedSequence);
      expect(appt.nextAlarm, nextAlarm);
      expect(appt.orphan, orphan);

      final inv = appt.invites.first;
      expect(inv.calItemType, InviteType.appt);
      expect(inv.sequence, sequence);
      expect(inv.id, id);
      expect(inv.componentNum, componentNum);
      expect(inv.recurrenceId, recurrenceId);

      final invTz = inv.timezones.first;
      expect(invTz.id, id);
      expect(invTz.tzStdOffset, tzStdOffset);
      expect(invTz.tzDayOffset, tzDayOffset);
      expect(invTz.standardTZName, standardTZName);
      expect(invTz.daylightTZName, daylightTZName);

      final invTzStandard = invTz.standardTzOnset!;
      expect(invTzStandard.month, month);
      expect(invTzStandard.hour, hour);
      expect(invTzStandard.minute, minute);
      expect(invTzStandard.second, second);
      expect(invTzStandard.dayOfMonth, dayOfMonth);
      expect(invTzStandard.week, week);
      expect(invTzStandard.dayOfWeek, dayOfWeek);

      final invTzDaylight = invTz.daylightTzOnset!;
      expect(invTzDaylight.month, month);
      expect(invTzDaylight.hour, hour);
      expect(invTzDaylight.minute, minute);
      expect(invTzDaylight.second, second);
      expect(invTzDaylight.dayOfMonth, dayOfMonth);
      expect(invTzDaylight.week, week);
      expect(invTzDaylight.dayOfWeek, dayOfWeek);

      final partInfo = inv.partInfos.first;
      expect(partInfo.part, part);
      expect(partInfo.contentType, contentType);
      expect(partInfo.size, size);
      expect(partInfo.contentDisposition, contentDisposition);
      expect(partInfo.contentFilename, contentFilename);
      expect(partInfo.contentId, contentId);
      expect(partInfo.location, location);
      expect(partInfo.body, body);
      expect(partInfo.truncatedContent, truncatedContent);
      expect(partInfo.content, content);
      expect(partInfo.body, body);
      final mpPartInfo = partInfo.mimeParts.first;
      expect(mpPartInfo.part, part);
      expect(mpPartInfo.contentType, contentType);
      expect(mpPartInfo.size, size);
      expect(mpPartInfo.contentDisposition, contentDisposition);
      expect(mpPartInfo.contentFilename, contentFilename);
      expect(mpPartInfo.contentId, contentId);
      expect(mpPartInfo.location, location);
      expect(mpPartInfo.body, body);
      expect(mpPartInfo.truncatedContent, truncatedContent);
      expect(mpPartInfo.content, content);
      expect(mpPartInfo.body, body);

      final shr = inv.shareNotifications.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = inv.dlSubsNotifications.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final comp = inv.inviteComponent!;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);

      final reply = appt.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, sequence);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final meta = appt.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final task = response.task!;
      expect(task, isA<TaskItemInfo>());
      expect(task, isA<CalendarItemInfo>());
      expect(task.flags, flags);
      expect(task.tags, tags);
      expect(task.tagNames, tagNames);
      expect(task.uid, uid);
      expect(task.id, id);
      expect(task.revision, revision);
      expect(task.size, size);
      expect(task.date, date);
      expect(task.folder, folder);
      expect(task.changeDate, changeDate);
      expect(task.modifiedSequence, modifiedSequence);
      expect(task.nextAlarm, nextAlarm);
      expect(task.orphan, orphan);
    }));

    test('Get working hours test', (() async {
      final id = faker.guid.guid();
      final startTime = faker.date.dateTime().millisecondsSinceEpoch;
      final endTime = faker.date.dateTime().millisecondsSinceEpoch;
      final eventId = faker.guid.guid();
      final subject = faker.lorem.word();
      final location = faker.lorem.word();
      final isMeeting = faker.randomGenerator.boolean();
      final isRecurring = faker.randomGenerator.boolean();
      final isException = faker.randomGenerator.boolean();
      final isReminderSet = faker.randomGenerator.boolean();
      final isPrivate = faker.randomGenerator.boolean();
      final hasPermission = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GetWorkingHoursResponse': {
            '_jsns': 'urn:zimbraMail',
            'usr': [
              {
                'id': id,
                'f': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
                'b': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
                't': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
                'u': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
                'n': [
                  {
                    's': startTime,
                    'e': endTime,
                    'eventId': eventId,
                    'subject': subject,
                    'location': location,
                    'isMeeting': isMeeting,
                    'isRecurring': isRecurring,
                    'isException': isException,
                    'isReminderSet': isReminderSet,
                    'isPrivate': isPrivate,
                    'hasPermission': hasPermission,
                  }
                ],
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getWorkingHours(startTime, endTime);
      final usr = response!.freebusyUsers.first;

      expect(usr.id, id);

      final free = usr.freeSlots.first;
      expect(free.startTime, startTime);
      expect(free.endTime, endTime);
      expect(free.eventId, eventId);
      expect(free.subject, subject);
      expect(free.location, location);
      expect(free.isMeeting, isMeeting);
      expect(free.isRecurring, isRecurring);
      expect(free.isException, isException);
      expect(free.isReminderSet, isReminderSet);
      expect(free.isPrivate, isPrivate);
      expect(free.hasPermission, hasPermission);

      final busy = usr.busySlots.first;
      expect(busy.startTime, startTime);
      expect(busy.endTime, endTime);
      expect(busy.eventId, eventId);
      expect(busy.subject, subject);
      expect(busy.location, location);
      expect(busy.isMeeting, isMeeting);
      expect(busy.isRecurring, isRecurring);
      expect(busy.isException, isException);
      expect(busy.isReminderSet, isReminderSet);
      expect(busy.isPrivate, isPrivate);
      expect(busy.hasPermission, hasPermission);

      final tentative = usr.tentativeSlots.first;
      expect(tentative.startTime, startTime);
      expect(tentative.endTime, endTime);
      expect(tentative.eventId, eventId);
      expect(tentative.subject, subject);
      expect(tentative.location, location);
      expect(tentative.isMeeting, isMeeting);
      expect(tentative.isRecurring, isRecurring);
      expect(tentative.isException, isException);
      expect(tentative.isReminderSet, isReminderSet);
      expect(tentative.isPrivate, isPrivate);
      expect(tentative.hasPermission, hasPermission);

      final unavailable = usr.unavailableSlots.first;
      expect(unavailable.startTime, startTime);
      expect(unavailable.endTime, endTime);
      expect(unavailable.eventId, eventId);
      expect(unavailable.subject, subject);
      expect(unavailable.location, location);
      expect(unavailable.isMeeting, isMeeting);
      expect(unavailable.isRecurring, isRecurring);
      expect(unavailable.isException, isException);
      expect(unavailable.isReminderSet, isReminderSet);
      expect(unavailable.isPrivate, isPrivate);
      expect(unavailable.hasPermission, hasPermission);

      final nodata = usr.nodataSlots.first;
      expect(nodata.startTime, startTime);
      expect(nodata.endTime, endTime);
      expect(nodata.eventId, eventId);
      expect(nodata.subject, subject);
      expect(nodata.location, location);
      expect(nodata.isMeeting, isMeeting);
      expect(nodata.isRecurring, isRecurring);
      expect(nodata.isException, isException);
      expect(nodata.isReminderSet, isReminderSet);
      expect(nodata.isPrivate, isPrivate);
      expect(nodata.hasPermission, hasPermission);
    }));

    test('Get Yahoo auth token test', (() async {
      final failed = faker.randomGenerator.boolean();
      final data = {
        'Body': {
          'GetYahooAuthTokenResponse': {
            '_jsns': 'urn:zimbraMail',
            'failed': failed,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getYahooAuthToken(faker.internet.userName(), faker.internet.password());
      expect(response!.failed, failed);
    }));

    test('Get Yahoo cookie test', (() async {
      final error = faker.lorem.word();
      final crumb = faker.lorem.word();
      final y = faker.lorem.word();
      final t = faker.lorem.word();

      final data = {
        'Body': {
          'GetYahooCookieResponse': {
            '_jsns': 'urn:zimbraMail',
            'error': error,
            'crumb': crumb,
            'y': y,
            't': t,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.getYahooCookie(faker.internet.userName());

      expect(response!.error, error);
      expect(response.crumb, crumb);
      expect(response.y, y);
      expect(response.t, t);
    }));

    test('Grant permission test', (() async {
      final right = faker.lorem.word();
      final zimbraId = faker.guid.guid();
      final displayName = faker.person.name();
      final password = faker.internet.password();
      final accessKey = faker.internet.password();
      final deny = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'GrantPermissionResponse': {
            '_jsns': 'urn:zimbraMail',
            'ace': [
              {
                'gt': GranteeType.all.name,
                'right': right,
                'zid': zimbraId,
                'd': displayName,
                'pw': password,
                'key': accessKey,
                'deny': deny,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.grantPermission([]);
      final ace = response!.aces.first;

      expect(ace.granteeType, GranteeType.all);
      expect(ace.right, right);
      expect(ace.zimbraId, zimbraId);
      expect(ace.displayName, displayName);
      expect(ace.password, password);
      expect(ace.accessKey, accessKey);
      expect(ace.deny, deny);
    }));

    test('iCalendar reply test', (() async {
      final data = {
        'Body': {
          'ICalReplyResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.iCalReply(faker.lorem.word());
      expect(response, isNotNull);
      expect(response, isA<ICalReplyResponse>());
    }));

    test('IMAP copy test', (() async {
      final id = faker.randomGenerator.integer(100);
      final imapUid = faker.randomGenerator.integer(100);
      final data = {
        'Body': {
          'IMAPCopyResponse': {
            '_jsns': 'urn:zimbraMail',
            'item': [
              {
                'id': id,
                'i4uid': imapUid,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.imapCopy(faker.lorem.word(), MailItemType.message, 1);
      final item = response!.items.first;

      expect(item.id, id);
      expect(item.imapUid, imapUid);
    }));

    test('Import appointments test', (() async {
      final ids = [
        faker.randomGenerator.integer(100),
        faker.randomGenerator.integer(100),
        faker.randomGenerator.integer(100)
      ].join(',');
      final num = faker.randomGenerator.integer(100);
      final data = {
        'Body': {
          'ImportAppointmentsResponse': {
            '_jsns': 'urn:zimbraMail',
            'ids': ids,
            'n': num,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.importAppointments(ContentSpec());
      expect(response!.ids, ids);
      expect(response.num, num);
    }));

    test('Import contacts test', (() async {
      final listOfCreatedIds = [
        faker.randomGenerator.integer(100),
        faker.randomGenerator.integer(100),
        faker.randomGenerator.integer(100)
      ].join(',');
      final numImported = faker.randomGenerator.integer(100);
      final data = {
        'Body': {
          'ImportContactsResponse': {
            '_jsns': 'urn:zimbraMail',
            'cn': {
              'ids': listOfCreatedIds,
              'n': numImported,
            }
          }
        }
      };
      final api = mockApi(data);
      final response = await api.importContacts(Content());
      final contact = response!.contact!;
      expect(contact.listOfCreatedIds, listOfCreatedIds);
      expect(contact.numImported, numImported);
    }));

    test('Import data test', (() async {
      final data = {
        'Body': {
          'ImportDataResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.importData();
      expect(response, isNotNull);
      expect(response, isA<ImportDataResponse>());
    }));

    test('Invalidate reminder device test', (() async {
      final data = {
        'Body': {
          'InvalidateReminderDeviceResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.invalidateReminderDevice(faker.internet.email());
      expect(response, isNotNull);
      expect(response, isA<InvalidateReminderDeviceResponse>());
    }));

    test('Item action test', (() async {
      final id = faker.guid.guid();
      final operation = faker.randomGenerator.element(ConvAction.values).name;
      final nonExistentIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');
      final newlyCreatedIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');

      final data = {
        'Body': {
          'ItemActionResponse': {
            '_jsns': 'urn:zimbraMail',
            'action': {
              'id': id,
              'op': operation,
              'nei': nonExistentIds,
              'nci': newlyCreatedIds,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.itemAction(ActionSelector(id, operation));
      final action = response!.action!;

      expect(action.id, id);
      expect(action.operation, operation);
      expect(action.nonExistentIds, nonExistentIds);
      expect(action.newlyCreatedIds, newlyCreatedIds);
    }));

    test('List document revisions test', (() async {
      final id = faker.guid.guid();
      final email = faker.internet.email();
      final name = faker.person.name();

      final lockOwnerId = faker.guid.guid();
      final lockOwnerEmail = faker.internet.email();
      final lockOwnerTimestamp = faker.date.dateTime().toString();

      final uuid = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final revision = faker.randomGenerator.integer(100);
      final version = faker.randomGenerator.integer(100);
      final modifiedSequence = faker.randomGenerator.integer(100);
      final metadataVersion = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().minute;
      final perm = faker.lorem.word();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);

      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folderId = faker.guid.guid();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final description = faker.lorem.word();
      final contentType = faker.lorem.word();
      final size = faker.randomGenerator.integer(100);
      final fragment = faker.lorem.word();
      final descEnabled = faker.randomGenerator.boolean();
      final lastEditedBy = faker.lorem.word();
      final creator = faker.lorem.word();
      final createdDate = faker.date.dateTime().millisecondsSinceEpoch;

      final data = {
        'Body': {
          'ListDocumentRevisionsResponse': {
            '_jsns': 'urn:zimbraMail',
            'doc': [
              {
                'loid': lockOwnerId,
                'loe': lockOwnerEmail,
                'lt': lockOwnerTimestamp,
                'id': id,
                'uuid': uuid,
                'name': name,
                's': size,
                'd': date,
                'l': folderId,
                'luuid': folderUuid,
                'ms': modifiedSequence,
                'mdver': metadataVersion,
                'md': changeDate,
                'rev': revision,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'desc': description,
                'ct': contentType,
                'descEnabled': descEnabled,
                'ver': version,
                'leb': lastEditedBy,
                'cr': creator,
                'cd': createdDate,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'fr': fragment,
                'acl': {
                  'internalGrantExpiry': internalGrantExpiry,
                  'guestGrantExpiry': guestGrantExpiry,
                  'grant': [
                    {
                      'perm': perm,
                      'gt': GrantGranteeType.all.name,
                      'zid': granteeId,
                      'expiry': expiry,
                      'd': granteeName,
                      'pw': guestPassword,
                      'key': accessKey,
                    }
                  ],
                },
              }
            ],
            'user': [
              {
                'id': id,
                'email': email,
                'name': name,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.listDocumentRevisions(ListDocumentRevisionsSpec());

      final user = response!.users.first;
      expect(user.id, id);
      expect(user.email, email);
      expect(user.name, name);

      final doc = response.revisions.first;
      expect(doc.lockOwnerId, lockOwnerId);
      expect(doc.lockOwnerEmail, lockOwnerEmail);
      expect(doc.lockOwnerTimestamp, lockOwnerTimestamp);
      expect(doc.id, id);
      expect(doc.uuid, uuid);
      expect(doc.name, name);
      expect(doc.size, size);
      expect(doc.date, date);
      expect(doc.folderId, folderId);
      expect(doc.folderUuid, folderUuid);
      expect(doc.modifiedSequence, modifiedSequence);
      expect(doc.metadataVersion, metadataVersion);
      expect(doc.changeDate, changeDate);
      expect(doc.revision, revision);
      expect(doc.flags, flags);
      expect(doc.tags, tags);
      expect(doc.tagNames, tagNames);
      expect(doc.description, description);
      expect(doc.contentType, contentType);
      expect(doc.descEnabled, descEnabled);
      expect(doc.version, version);
      expect(doc.lastEditedBy, lastEditedBy);
      expect(doc.creator, creator);
      expect(doc.createdDate, createdDate);
      expect(doc.fragment, fragment);

      final docMeta = doc.metadatas.first;
      expect(docMeta.section, section);
      expect(docMeta.keyValuePairs.first.key, key);
      expect(docMeta.keyValuePairs.first.value, value);

      final docAcl = doc.acl!;
      expect(docAcl.internalGrantExpiry, internalGrantExpiry);
      expect(docAcl.guestGrantExpiry, guestGrantExpiry);

      final docGrant = docAcl.grants.first;
      expect(docGrant.perm, perm);
      expect(docGrant.granteeType, GrantGranteeType.all);
      expect(docGrant.granteeId, granteeId);
      expect(docGrant.expiry, expiry);
      expect(docGrant.granteeName, granteeName);
      expect(docGrant.guestPassword, guestPassword);
      expect(docGrant.accessKey, accessKey);
    }));

    test('List IMAP subscriptions test', (() async {
      final sub1 = faker.lorem.word();
      final sub2 = faker.lorem.word();
      final data = {
        'Body': {
          'ListIMAPSubscriptionsResponse': {
            '_jsns': 'urn:zimbraMail',
            'sub': [
              {'_content': sub1},
              {'_content': sub2},
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.listIMAPSubscriptions();
      expect(response!.subscriptions, [sub1, sub2]);
    }));

    test('Modify appointment test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final calInvId = faker.guid.guid();
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final revision = faker.randomGenerator.integer(100);

      final part = faker.lorem.word();
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.person.name();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final seq = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final content = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();
      final size = faker.randomGenerator.integer(100);
      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final section = faker.lorem.word();

      final data = {
        'Body': {
          'ModifyAppointmentResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'apptId': deprecatedApptId,
            'invId': calInvId,
            'ms': modifiedSequence,
            'rev': revision,
            'm': {'id': id},
            'echo': {
              'm': {
                'id': id,
                'part': part,
                'sd': sentDate,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'mid': messageIdHeader,
                'inv': {
                  'type': InviteType.appt.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                  },
                  'comp': [
                    {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    }
                  ],
                },
                '_attrs': {
                  key: value,
                },
                'mp': [
                  {
                    'part': part,
                    'ct': contentType,
                    's': size,
                    'cd': contentDisposition,
                    'filename': contentFilename,
                    'ci': contentId,
                    'cl': location,
                    'body': body,
                    'truncated': truncatedContent,
                    'content': content,
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'shr': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'dlSubs': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.modifyAppointment();

      expect(response!.calItemId, calItemId);
      expect(response.deprecatedApptId, deprecatedApptId);
      expect(response.calInvId, calInvId);
      expect(response.modifiedSequence, modifiedSequence);
      expect(response.msg!.id, id);

      final echo = response.echo!;
      final invite = echo.invite!;

      expect(invite.id, id);
      expect(invite.part, part);
      expect(invite.sentDate, sentDate);
      expect(invite.subject, subject);
      expect(invite.messageIdHeader, messageIdHeader);
      expect(invite.size, size);
      expect(invite.date, date);
      expect(invite.folder, folder);
      expect(invite.conversationId, conversationId);
      expect(invite.flags, flags);
      expect(invite.tags, tags);
      expect(invite.tagNames, tagNames);
      expect(invite.revision, revision);
      expect(invite.changeDate, changeDate);
      expect(invite.modifiedSequence, modifiedSequence);

      final email = invite.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final header = invite.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final mpContent = invite.mpContentElems.first;
      expect(mpContent.part, part);
      expect(mpContent.contentType, contentType);
      expect(mpContent.size, size);
      expect(mpContent.contentDisposition, contentDisposition);
      expect(mpContent.contentFilename, contentFilename);
      expect(mpContent.contentId, contentId);
      expect(mpContent.location, location);
      expect(mpContent.body, body);
      expect(mpContent.truncatedContent, truncatedContent);
      expect(mpContent.content, content);

      final mimePart = mpContent.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = invite.shrContentElems.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = invite.dlSubsContentElems.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final inv = invite.invite!;
      expect(inv.calItemType, InviteType.appt);

      final tz = inv.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = inv.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = inv.inviteComponents.first;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Modify contact test', (() async {
      final sortField = faker.lorem.word();
      final canExpand = faker.randomGenerator.boolean();
      final id = faker.guid.guid();
      final imapUid = faker.randomGenerator.integer(100);
      final folder = faker.lorem.word();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final changeDate = faker.date.dateTime().millisecond;
      final modifiedSequenceId = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final revisionId = faker.randomGenerator.integer(100);
      final fileAs = faker.lorem.word();
      final email = faker.internet.email();
      final email2 = faker.internet.email();
      final email3 = faker.internet.email();
      final type = faker.lorem.word();
      final dlist = faker.lorem.word();
      final reference = faker.lorem.word();
      final tooManyMembers = faker.randomGenerator.boolean();
      final memberOf = faker.internet.email();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final data = {
        'Body': {
          'ModifyContactResponse': {
            '_jsns': 'urn:zimbraMail',
            'cn': {
              'sf': sortField,
              'exp': canExpand,
              'id': id,
              'i4uid': imapUid,
              'l': folder,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'md': changeDate,
              'ms': modifiedSequenceId,
              'd': date,
              'rev': revisionId,
              'fileAsStr': fileAs,
              'email': email,
              'email2': email2,
              'email3': email3,
              'type': type,
              'dlist': dlist,
              'ref': reference,
              'tooManyMembers': tooManyMembers,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              '_attrs': {
                key: value,
              },
              'm': [
                {
                  'type': MemberType.contact.name,
                  '_content': value,
                  'cn': {
                    'sf': sortField,
                    'exp': canExpand,
                    'id': id,
                    'i4uid': imapUid,
                    'l': folder,
                    'f': flags,
                    't': tags,
                    'tn': tagNames,
                    'md': changeDate,
                    'ms': modifiedSequenceId,
                    'd': date,
                    'rev': revisionId,
                    'fileAsStr': fileAs,
                    'email': email,
                    'email2': email2,
                    'email3': email3,
                    'type': type,
                    'dlist': dlist,
                    'ref': reference,
                    'tooManyMembers': tooManyMembers,
                    'memberOf': {'_content': memberOf},
                  },
                }
              ],
              'memberOf': {'_content': memberOf},
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.modifyContact(ModifyContactSpec());
      final contact = response!.contact!;

      expect(contact.sortField, sortField);
      expect(contact.canExpand, canExpand);
      expect(contact.id, id);
      expect(contact.imapUid, imapUid);
      expect(contact.folder, folder);
      expect(contact.flags, flags);
      expect(contact.tags, tags);
      expect(contact.tagNames, tagNames);
      expect(contact.changeDate, changeDate);
      expect(contact.modifiedSequenceId, modifiedSequenceId);
      expect(contact.date, date);
      expect(contact.revisionId, revisionId);
      expect(contact.fileAs, fileAs);
      expect(contact.email, email);
      expect(contact.email2, email2);
      expect(contact.email3, email3);
      expect(contact.type, type);
      expect(contact.dlist, dlist);
      expect(contact.reference, reference);
      expect(contact.tooManyMembers, tooManyMembers);
      expect(contact.memberOf, memberOf);

      final meta = contact.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final attr = contact.attrs.first;
      expect(attr.key, key);
      expect(attr.value, value);

      final member = contact.contactGroupMembers.first;
      expect(member.type, MemberType.contact);
      expect(member.value, value);

      final cn = member.contact!;
      expect(cn.sortField, sortField);
      expect(cn.canExpand, canExpand);
      expect(cn.id, id);
      expect(cn.imapUid, imapUid);
      expect(cn.folder, folder);
      expect(cn.flags, flags);
      expect(cn.tags, tags);
      expect(cn.tagNames, tagNames);
      expect(cn.changeDate, changeDate);
      expect(cn.modifiedSequenceId, modifiedSequenceId);
      expect(cn.date, date);
      expect(cn.revisionId, revisionId);
      expect(cn.fileAs, fileAs);
      expect(cn.email, email);
      expect(cn.email2, email2);
      expect(cn.email3, email3);
      expect(cn.type, type);
      expect(cn.dlist, dlist);
      expect(cn.reference, reference);
      expect(cn.tooManyMembers, tooManyMembers);
      expect(cn.memberOf, memberOf);
    }));

    test('Modify data source test', (() async {
      final data = {
        'Body': {
          'ModifyDataSourceResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.modifyDataSource();
      expect(response, isNotNull);
      expect(response, isA<ModifyDataSourceResponse>());
    }));

    test('Modify filter rules test', (() async {
      final data = {
        'Body': {
          'ModifyFilterRulesResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.modifyFilterRules();
      expect(response, isNotNull);
      expect(response, isA<ModifyFilterRulesResponse>());
    }));

    test('Modify mailbox metadata test', (() async {
      final data = {
        'Body': {
          'ModifyMailboxMetadataResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.modifyMailboxMetadata(MailCustomMetadata());
      expect(response, isNotNull);
      expect(response, isA<ModifyMailboxMetadataResponse>());
    }));

    test('Modify outgoing filter rules test', (() async {
      final data = {
        'Body': {
          'ModifyOutgoingFilterRulesResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.modifyOutgoingFilterRules();
      expect(response, isNotNull);
      expect(response, isA<ModifyOutgoingFilterRulesResponse>());
    }));

    test('Modify profile image test', (() async {
      final itemId = faker.randomGenerator.integer(100);
      final data = {
        'Body': {
          'ModifyProfileImageResponse': {
            '_jsns': 'urn:zimbraMail',
            'itemId': itemId,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.modifyProfileImage();
      expect(response!.itemId, itemId);
    }));

    test('Modify search folder test', (() async {
      final id = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final absoluteFolderPath = faker.lorem.word();
      final parentId = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unreadCount = faker.randomGenerator.integer(100);
      final imapUnreadCount = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().minute;
      final itemCount = faker.randomGenerator.integer(100);
      final imapItemCount = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final imapModifiedSequence = faker.randomGenerator.integer(100);
      final imapUidNext = faker.randomGenerator.integer(100);
      final url = faker.internet.httpsUrl();
      final activeSyncDisabled = faker.randomGenerator.boolean();
      final webOfflineSyncDays = faker.randomGenerator.integer(100);
      final perm = faker.lorem.word();
      final recursive = faker.randomGenerator.boolean();
      final restUrl = faker.internet.httpsUrl();
      final deletable = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final lifetime = faker.randomGenerator.integer(100).toString();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);

      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();

      final ownerEmail = faker.internet.email();
      final ownerAccountId = faker.guid.guid();
      final remoteFolderId = faker.randomGenerator.integer(100);
      final remoteUuid = faker.guid.guid();
      final remoteFolderName = faker.lorem.word();
      final reminderEnabled = faker.randomGenerator.boolean();
      final broken = faker.randomGenerator.boolean();

      final query = faker.lorem.word();
      final types = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'ModifySearchFolderResponse': {
            '_jsns': 'urn:zimbraMail',
            'search': {
              'id': id,
              'uuid': uuid,
              'name': name,
              'query': query,
              'sortBy': SearchSortBy.none.name,
              'types': types,
              'absFolderPath': absoluteFolderPath,
              'l': parentId,
              'luuid': folderUuid,
              'f': flags,
              'color': color,
              'rgb': rgb,
              'u': unreadCount,
              'i4u': imapUnreadCount,
              'view': ViewType.conversation.name,
              'rev': revision,
              'ms': modifiedSequence,
              'md': changeDate,
              'n': itemCount,
              'i4n': imapItemCount,
              's': totalSize,
              'i4ms': imapModifiedSequence,
              'i4next': imapUidNext,
              'url': url,
              'activesyncdisabled': activeSyncDisabled,
              'webOfflineSyncDays': webOfflineSyncDays,
              'perm': perm,
              'recursive': recursive,
              'rest': restUrl,
              'deletable': deletable,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
              'acl': {
                'internalGrantExpiry': internalGrantExpiry,
                'guestGrantExpiry': guestGrantExpiry,
                'grant': [
                  {
                    'perm': perm,
                    'gt': GrantGranteeType.all.name,
                    'zid': granteeId,
                    'expiry': expiry,
                    'd': granteeName,
                    'pw': guestPassword,
                    'key': accessKey,
                  }
                ],
              },
              'folder': [
                {
                  'id': id,
                  'uuid': uuid,
                  'name': name,
                }
              ],
              'link': [
                {
                  'id': id,
                  'name': name,
                  'owner': ownerEmail,
                  'zid': ownerAccountId,
                  'rid': remoteFolderId,
                  'ruuid': remoteUuid,
                  'oname': remoteFolderName,
                  'reminder': reminderEnabled,
                  'broken': broken,
                }
              ],
              'search': [
                {
                  'id': id,
                  'name': name,
                  'query': query,
                  'sortBy': SearchSortBy.none.name,
                  'types': types,
                }
              ],
              'retentionPolicy': [
                {
                  'keep': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                  'purge': [
                    {
                      'policy': [
                        {
                          'type': PolicyType.user.name,
                          'id': id,
                          'name': name,
                          'lifetime': lifetime,
                        }
                      ],
                    }
                  ],
                }
              ],
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.modifySearchFolder(ModifySearchFolderSpec());

      final searchFolder = response!.searchFolder!;
      expect(searchFolder.id, id);
      expect(searchFolder.uuid, uuid);
      expect(searchFolder.name, name);
      expect(searchFolder.query, query);
      expect(searchFolder.sortBy, SearchSortBy.none);
      expect(searchFolder.types, types);
      expect(searchFolder.absoluteFolderPath, absoluteFolderPath);
      expect(searchFolder.parentId, parentId);
      expect(searchFolder.folderUuid, folderUuid);
      expect(searchFolder.flags, flags);
      expect(searchFolder.color, color);
      expect(searchFolder.rgb, rgb);
      expect(searchFolder.unreadCount, unreadCount);
      expect(searchFolder.imapUnreadCount, imapUnreadCount);
      expect(searchFolder.view, ViewType.conversation);
      expect(searchFolder.revision, revision);
      expect(searchFolder.modifiedSequence, modifiedSequence);
      expect(searchFolder.changeDate, changeDate);
      expect(searchFolder.itemCount, itemCount);
      expect(searchFolder.imapItemCount, imapItemCount);
      expect(searchFolder.totalSize, totalSize);
      expect(searchFolder.imapModifiedSequence, imapModifiedSequence);
      expect(searchFolder.imapUidNext, imapUidNext);
      expect(searchFolder.url, url);
      expect(searchFolder.activeSyncDisabled, activeSyncDisabled);
      expect(searchFolder.webOfflineSyncDays, webOfflineSyncDays);
      expect(searchFolder.perm, perm);
      expect(searchFolder.recursive, recursive);
      expect(searchFolder.restUrl, restUrl);
      expect(searchFolder.deletable, deletable);

      final meta = searchFolder.metadatas.first;
      expect(meta.section, section);
      expect(meta.keyValuePairs.first.key, key);
      expect(meta.keyValuePairs.first.value, value);

      final acl = searchFolder.acl!;
      expect(acl.internalGrantExpiry, internalGrantExpiry);
      expect(acl.guestGrantExpiry, guestGrantExpiry);

      final grant = acl.grants.first;
      expect(grant.perm, perm);
      expect(grant.granteeType, GrantGranteeType.all);
      expect(grant.granteeId, granteeId);
      expect(grant.expiry, expiry);
      expect(grant.granteeName, granteeName);
      expect(grant.guestPassword, guestPassword);
      expect(grant.accessKey, accessKey);

      final subFolder = searchFolder.subFolders.first;
      expect(subFolder.id, id);
      expect(subFolder.uuid, uuid);
      expect(subFolder.name, name);
      expect(subFolder, isA<Folder>());

      final link = searchFolder.mountpoints.first;
      expect(link.id, id);
      expect(link.name, name);
      expect(link.ownerEmail, ownerEmail);
      expect(link.ownerAccountId, ownerAccountId);
      expect(link.remoteFolderId, remoteFolderId);
      expect(link.remoteUuid, remoteUuid);
      expect(link.remoteFolderName, remoteFolderName);
      expect(link.reminderEnabled, reminderEnabled);
      expect(link.broken, broken);
      expect(link, isA<Folder>());

      final search = searchFolder.searchFolders.first;
      expect(search.id, id);
      expect(search.name, name);
      expect(search.query, query);
      expect(search.sortBy, SearchSortBy.none);
      expect(search.types, types);
      expect(search, isA<Folder>());

      final retentionPolicy = searchFolder.retentionPolicy!;
      final keep = retentionPolicy.keep.first;
      final purge = retentionPolicy.purge.first;
      expect(keep.type, PolicyType.user);
      expect(keep.id, id);
      expect(keep.name, name);
      expect(keep.lifetime, lifetime);
      expect(purge.type, PolicyType.user);
      expect(purge.id, id);
      expect(purge.name, name);
      expect(purge.lifetime, lifetime);
    }));

    test('Modify task test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final calInvId = faker.guid.guid();
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final revision = faker.randomGenerator.integer(100);

      final part = faker.lorem.word();
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.person.name();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final seq = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final content = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();
      final size = faker.randomGenerator.integer(100);
      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final section = faker.lorem.word();

      final data = {
        'Body': {
          'ModifyTaskResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'apptId': deprecatedApptId,
            'invId': calInvId,
            'ms': modifiedSequence,
            'rev': revision,
            'm': {'id': id},
            'echo': {
              'm': {
                'id': id,
                'part': part,
                'sd': sentDate,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'mid': messageIdHeader,
                'inv': {
                  'type': InviteType.appt.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                  },
                  'comp': [
                    {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    }
                  ],
                },
                '_attrs': {
                  key: value,
                },
                'mp': [
                  {
                    'part': part,
                    'ct': contentType,
                    's': size,
                    'cd': contentDisposition,
                    'filename': contentFilename,
                    'ci': contentId,
                    'cl': location,
                    'body': body,
                    'truncated': truncatedContent,
                    'content': content,
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'shr': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'dlSubs': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.modifyTask();

      expect(response!.calItemId, calItemId);
      expect(response.deprecatedApptId, deprecatedApptId);
      expect(response.calInvId, calInvId);
      expect(response.modifiedSequence, modifiedSequence);
      expect(response.msg!.id, id);

      final echo = response.echo!;
      final invite = echo.invite!;

      expect(invite.id, id);
      expect(invite.part, part);
      expect(invite.sentDate, sentDate);
      expect(invite.subject, subject);
      expect(invite.messageIdHeader, messageIdHeader);
      expect(invite.size, size);
      expect(invite.date, date);
      expect(invite.folder, folder);
      expect(invite.conversationId, conversationId);
      expect(invite.flags, flags);
      expect(invite.tags, tags);
      expect(invite.tagNames, tagNames);
      expect(invite.revision, revision);
      expect(invite.changeDate, changeDate);
      expect(invite.modifiedSequence, modifiedSequence);

      final email = invite.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final header = invite.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final mpContent = invite.mpContentElems.first;
      expect(mpContent.part, part);
      expect(mpContent.contentType, contentType);
      expect(mpContent.size, size);
      expect(mpContent.contentDisposition, contentDisposition);
      expect(mpContent.contentFilename, contentFilename);
      expect(mpContent.contentId, contentId);
      expect(mpContent.location, location);
      expect(mpContent.body, body);
      expect(mpContent.truncatedContent, truncatedContent);
      expect(mpContent.content, content);

      final mimePart = mpContent.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = invite.shrContentElems.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = invite.dlSubsContentElems.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final inv = invite.invite!;
      expect(inv.calItemType, InviteType.appt);

      final tz = inv.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = inv.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = inv.inviteComponents.first;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Msg action test', (() async {
      final id = faker.guid.guid();
      final operation = faker.randomGenerator.element(MsgAction.values).name;
      final nonExistentIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');
      final newlyCreatedIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');

      final data = {
        'Body': {
          'MsgActionResponse': {
            '_jsns': 'urn:zimbraMail',
            'action': {
              'id': id,
              'op': operation,
              'nei': nonExistentIds,
              'nci': newlyCreatedIds,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.msgAction(ActionSelector(id, operation));
      final action = response!.action!;

      expect(action.id, id);
      expect(action.operation, operation);
      expect(action.nonExistentIds, nonExistentIds);
      expect(action.newlyCreatedIds, newlyCreatedIds);
    }));

    test('No op test', (() async {
      final waitDisallowed = faker.randomGenerator.boolean();
      final data = {
        'Body': {
          'NoOpResponse': {
            '_jsns': 'urn:zimbraMail',
            'waitDisallowed': waitDisallowed,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.noOp();
      expect(response!.waitDisallowed, waitDisallowed);
    }));

    test('Note action test', (() async {
      final id = faker.guid.guid();
      final operation = faker.randomGenerator.element(ItemAction.values).name;
      final nonExistentIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');
      final newlyCreatedIds = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');

      final data = {
        'Body': {
          'NoteActionResponse': {
            '_jsns': 'urn:zimbraMail',
            'action': {
              'id': id,
              'op': operation,
              'nei': nonExistentIds,
              'nci': newlyCreatedIds,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.noteAction(NoteActionSelector(id, operation));
      final action = response!.action!;

      expect(action.id, id);
      expect(action.operation, operation);
      expect(action.nonExistentIds, nonExistentIds);
      expect(action.newlyCreatedIds, newlyCreatedIds);
    }));

    test('Open IMAP folder test', (() async {
      final id = faker.randomGenerator.integer(100);
      final imapUid = faker.randomGenerator.integer(100);
      final type = faker.lorem.word();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final hasMore = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'OpenIMAPFolderResponse': {
            '_jsns': 'urn:zimbraMail',
            'more': hasMore,
            'folder': [
              {
                'm': [
                  {
                    'id': id,
                    'i4uid': imapUid,
                    't': type,
                    'f': flags,
                    'tn': tags,
                  }
                ]
              }
            ],
            'cursor': {'id': id.toString()},
          }
        }
      };
      final api = mockApi(data);
      final response = await api.openIMAPFolder(faker.guid.guid(), faker.randomGenerator.integer(10));

      expect(response!.hasMore, hasMore);

      final msg = response.messages.first;
      expect(msg.id, id);
      expect(msg.imapUid, imapUid);
      expect(msg.type, type);
      expect(msg.flags, flags);
      expect(msg.tags, tags);

      final cursor = response.cursor!;
      expect(cursor.id, id.toString());
    }));

    test('Purge revision test', (() async {
      final data = {
        'Body': {
          'PurgeRevisionResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.purgeRevision(PurgeRevisionSpec(faker.guid.guid(), faker.randomGenerator.integer(10)));
      expect(response, isNotNull);
      expect(response, isA<PurgeRevisionResponse>());
    }));

    test('Ranking action test', (() async {
      final data = {
        'Body': {
          'RankingActionResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.rankingAction(RankingActionSpec());
      expect(response, isNotNull);
      expect(response, isA<RankingActionResponse>());
    }));

    test('Record IMAP session test', (() async {
      final lastItemId = faker.randomGenerator.integer(100);
      final folderUuid = faker.guid.guid();
      final data = {
        'Body': {
          'RecordIMAPSessionResponse': {
            '_jsns': 'urn:zimbraMail',
            'id': lastItemId,
            'luuid': folderUuid,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.recordIMAPSession(folderUuid);
      expect(response!.lastItemId, lastItemId);
      expect(response.folderUuid, folderUuid);
    }));

    test('Recover account test', (() async {
      final recoveryAccount = faker.internet.email();
      final recoveryAttemptsLeft = faker.randomGenerator.integer(100);
      final data = {
        'Body': {
          'RecoverAccountResponse': {
            '_jsns': 'urn:zimbraMail',
            'recoveryAccount': recoveryAccount,
            'recoveryAttemptsLeft': recoveryAttemptsLeft,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.recoverAccount(recoveryAccount, RecoverAccountOperation.sendRecoveryCode);
      expect(response!.recoveryAccount, recoveryAccount);
      expect(response.recoveryAttemptsLeft, recoveryAttemptsLeft);
    }));

    test('Remove attachments test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final subject = faker.lorem.word();
      final section = faker.lorem.word();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final num = faker.randomGenerator.integer(100);
      final flags = faker.lorem.word();
      final tags = faker.randomGenerator.amount((_) => random.integer(10), 10, min: 5).join(',');
      final tagNames = faker.randomGenerator.amount((_) => random.string(10), 10, min: 5).join(',');

      final imapUid = faker.randomGenerator.integer(100);
      final calendarIntendedFor = faker.lorem.word();
      final origId = faker.guid.guid();
      final identityId = faker.guid.guid();
      final draftAccountId = faker.guid.guid();
      final draftAutoSendTime = faker.randomGenerator.integer(100);
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final resentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final part = faker.lorem.word();
      final fragment = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();
      final inReplyTo = faker.internet.email();
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.lorem.word();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();
      final recurrenceId = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final contentType = faker.lorem.word();
      final content = faker.lorem.word();
      final summary = faker.guid.guid();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final componentNum = faker.randomGenerator.integer(100);
      final method = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.date.dateTime().millisecondsSinceEpoch;
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'RemoveAttachmentsResponse': {
            '_jsns': 'urn:zimbraMail',
            'm': {
              'id': id,
              'i4uid': imapUid,
              'cif': calendarIntendedFor,
              'origid': origId,
              'rt': ReplyType.replied.name,
              'idnt': identityId,
              'forAcct': draftAccountId,
              'autoSendTime': draftAutoSendTime,
              'sd': sentDate,
              'rd': resentDate,
              'part': part,
              'fr': fragment,
              'e': [
                {
                  'a': address,
                  'd': display,
                  'p': personal,
                  't': AddressType.from.name,
                  'isGroup': isGroup,
                  'exp': canExpandGroupMembers,
                }
              ],
              'su': subject,
              'mid': messageIdHeader,
              'irt': inReplyTo,
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
              'inv': {
                'type': InviteType.appt.name,
                'tz': [
                  {
                    'id': id,
                    'stdoff': tzStdOffset,
                    'dayoff': tzDayOffset,
                    'standard': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'daylight': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'stdname': standardTZName,
                    'dayname': daylightTZName,
                  }
                ],
                'comp': {
                  'category': [
                    {'_content': category}
                  ],
                  'comment': [
                    {'_content': comment}
                  ],
                  'contact': [
                    {'_content': contact}
                  ],
                  'geo': {
                    'lat': latitude,
                    'lon': longitude,
                  },
                  'at': [
                    {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'cutype': cuType,
                      'role': role,
                      'ptst': partStat.name,
                      'rsvp': rsvp,
                      'member': member,
                      'delegatedTo': delegatedTo,
                      'delegatedFrom': delegatedFrom,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    }
                  ],
                  'alarm': [
                    {
                      'action': AlarmAction.display.name,
                      'trigger': {
                        'abs': {
                          'd': dateTimeString,
                        },
                        'rel': {
                          'd': dateTimeString,
                        },
                      },
                      'repeat': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'desc': {'_content': description},
                      'attach': {
                        'uri': uri,
                        'ct': contentType,
                        '_content': binaryB64Data,
                      },
                      'summary': {'_content': summary},
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    }
                  ],
                  'xprop': [
                    {
                      'name': name,
                      'value': value,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    }
                  ],
                  'fr': fragment,
                  'desc': {'_content': description},
                  'descHtml': {'_content': htmlDescription},
                  'or': {
                    'a': address,
                    'url': url,
                    'd': displayName,
                    'sentBy': sentBy,
                    'dir': dir,
                    'lang': language,
                    'xparam': [
                      {
                        'name': name,
                        'value': value,
                      }
                    ],
                  },
                  'recur': {
                    'add': [
                      {'add': {}}
                    ],
                    'exclude': [
                      {'exclude': {}}
                    ],
                    'except': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                        'add': {'add': []},
                        'exclude': {'exclude': []},
                      }
                    ],
                    'cancel': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                    'dates': [
                      {
                        'tz': timezone,
                        'dtval': [
                          {
                            's': {
                              'd': dateTimeString,
                              'tz': timezone,
                              'u': utcTime,
                            },
                            'e': {
                              'd': dateTimeString,
                              'tz': timezone,
                              'u': utcTime,
                            },
                            'dur': {
                              'neg': durationNegative,
                              'w': weeks,
                              'd': days,
                              'h': hours,
                              'm': minutes,
                              's': seconds,
                              'related': AlarmRelated.start.name,
                              'count': repeatCount,
                            },
                          }
                        ],
                      }
                    ],
                    'rule': [
                      {
                        'freq': Frequency.second.name,
                        'until': {
                          'd': dateTimeString,
                        },
                        'count': {
                          'num': num,
                        },
                        'interval': {
                          'ival': ival,
                        },
                        'bysecond': {
                          'seclist': list,
                        },
                        'byminute': {
                          'minlist': list,
                        },
                        'byhour': {
                          'hrlist': list,
                        },
                        'byday': {
                          'wkday': [
                            {
                              'day': WeekDay.sunday.name,
                              'ordWk': ordWk,
                            }
                          ],
                        },
                        'bymonthday': {
                          'modaylist': list,
                        },
                        'byyearday': {
                          'yrdaylist': list,
                        },
                        'byweekno': {
                          'wklist': list,
                        },
                        'bymonth': {
                          'molist': list,
                        },
                        'bysetpos': {
                          'poslist': list,
                        },
                        'wkst': {
                          'day': WeekDay.sunday.name,
                        },
                        'rule-x-name': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                  'exceptId': {
                    'd': dateTimeString,
                    'tz': timezone,
                    'rangeType': recurrenceRangeType,
                  },
                  's': {
                    'd': dateTimeString,
                    'tz': timezone,
                    'u': utcTime,
                  },
                  'e': {
                    'd': dateTimeString,
                    'tz': timezone,
                    'u': utcTime,
                  },
                  'dur': {
                    'neg': durationNegative,
                    'w': weeks,
                    'd': days,
                    'h': hours,
                    'm': minutes,
                    's': seconds,
                    'related': AlarmRelated.start.name,
                    'count': repeatCount,
                  },
                  'method': method,
                  'compNum': componentNum,
                  'rsvp': rsvp,
                  'priority': priority,
                  'name': name,
                  'loc': location,
                  'percentComplete': percentComplete,
                  'completed': completed,
                  'noBlob': noBlob,
                  'fba': FreeBusyStatus.free.name,
                  'fb': FreeBusyStatus.free.name,
                  'transp': Transparency.opaque.name,
                  'isOrg': isOrganizer,
                  'x_uid': xUid,
                  'uid': uid,
                  'seq': sequence,
                  'd': dateTime,
                  'calItemId': calItemId,
                  'apptId': deprecatedApptId,
                  'ciFolder': calItemFolder,
                  'status': InviteStatus.completed.name,
                  'class': InviteClass.public.name,
                  'url': url,
                  'ex': isException,
                  'ridZ': recurIdZ,
                  'allDay': isAllDay,
                  'draft': isDraft,
                  'neverSent': neverSent,
                  'changes': changes,
                },
                'replies': {
                  'reply': [
                    {
                      'rangeType': recurrenceRangeType,
                      'recurId': recurrenceId,
                      'seq': seq,
                      'd': date,
                      'at': attendee,
                      'sentBy': sentBy,
                      'ptst': partStat.name,
                      'tz': timezone,
                      'ridZ': recurIdZ,
                    }
                  ]
                }
              },
              '_attrs': {
                key: value,
              },
              'mp': [
                {
                  'part': part,
                  'ct': contentType,
                  's': size,
                  'cd': contentDisposition,
                  'filename': contentFilename,
                  'ci': contentId,
                  'cl': location,
                  'body': body,
                  'truncated': truncatedContent,
                  'content': content,
                  'mp': [
                    {
                      'part': part,
                      'ct': contentType,
                      's': size,
                      'cd': contentDisposition,
                      'filename': contentFilename,
                      'ci': contentId,
                      'cl': location,
                      'body': body,
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                }
              ],
              'shr': [
                {
                  'truncated': truncatedContent,
                  'content': content,
                }
              ],
              'dlSubs': [
                {
                  'truncated': truncatedContent,
                  'content': content,
                }
              ],
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
            'chat': {
              'id': id,
              'i4uid': imapUid,
              'cif': calendarIntendedFor,
              'origid': origId,
              'rt': ReplyType.replied.name,
              'idnt': identityId,
              'forAcct': draftAccountId,
              'autoSendTime': draftAutoSendTime,
              'sd': sentDate,
              'rd': resentDate,
              'part': part,
              'fr': fragment,
              'su': subject,
              'mid': messageIdHeader,
              'irt': inReplyTo,
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.removeAttachments(MsgPartIds());

      final msg = response!.msgMessage!;
      expect(msg.id, id);
      expect(msg.imapUid, imapUid);
      expect(msg.calendarIntendedFor, calendarIntendedFor);
      expect(msg.origId, origId);
      expect(msg.draftReplyType, ReplyType.replied);
      expect(msg.identityId, identityId);
      expect(msg.draftAccountId, draftAccountId);
      expect(msg.draftAutoSendTime, draftAutoSendTime);
      expect(msg.sentDate, sentDate);
      expect(msg.resentDate, resentDate);
      expect(msg.part, part);
      expect(msg.fragment, fragment);
      expect(msg.subject, subject);
      expect(msg.messageIdHeader, messageIdHeader);
      expect(msg.inReplyTo, inReplyTo);
      expect(msg.size, size);
      expect(msg.date, date);
      expect(msg.folder, folder);
      expect(msg.conversationId, conversationId);
      expect(msg.flags, flags);
      expect(msg.tags, tags);
      expect(msg.tagNames, tagNames);
      expect(msg.revision, revision);
      expect(msg.changeDate, changeDate);
      expect(msg.modifiedSequence, modifiedSequence);

      final header = msg.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final partInfo = msg.partInfos.first;
      expect(partInfo.part, part);
      expect(partInfo.contentType, contentType);
      expect(partInfo.size, size);
      expect(partInfo.contentDisposition, contentDisposition);
      expect(partInfo.contentFilename, contentFilename);
      expect(partInfo.contentId, contentId);
      expect(partInfo.location, location);
      expect(partInfo.body, body);
      expect(partInfo.truncatedContent, truncatedContent);
      expect(partInfo.content, content);

      final mimePart = partInfo.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = msg.shareNotifications.first;
      expect(shr.content, content);
      expect(shr.truncatedContent, truncatedContent);

      final dlSubs = msg.dlSubsNotifications.first;
      expect(dlSubs.content, content);
      expect(dlSubs.truncatedContent, truncatedContent);

      final msgMeta = msg.metadatas.first;
      expect(msgMeta.section, section);
      expect(msgMeta.keyValuePairs.first.key, key);
      expect(msgMeta.keyValuePairs.first.value, value);

      final invite = msg.invite!;
      expect(invite.calItemType, InviteType.appt);

      final tz = invite.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = invite.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = invite.inviteComponent!;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);

      final chat = response.chatMessage!;
      expect(chat, isA<MessageInfo>());
      expect(chat.id, id);
      expect(chat.imapUid, imapUid);
      expect(chat.calendarIntendedFor, calendarIntendedFor);
      expect(chat.origId, origId);
      expect(chat.draftReplyType, ReplyType.replied);
      expect(chat.identityId, identityId);
      expect(chat.draftAccountId, draftAccountId);
      expect(chat.draftAutoSendTime, draftAutoSendTime);
      expect(chat.sentDate, sentDate);
      expect(chat.resentDate, resentDate);
      expect(chat.part, part);
      expect(chat.fragment, fragment);
      expect(chat.subject, subject);
      expect(chat.messageIdHeader, messageIdHeader);
      expect(chat.inReplyTo, inReplyTo);
      expect(chat.size, size);
      expect(chat.date, date);
      expect(chat.folder, folder);
      expect(chat.conversationId, conversationId);
      expect(chat.flags, flags);
      expect(chat.tags, tags);
      expect(chat.tagNames, tagNames);
      expect(chat.revision, revision);
      expect(chat.changeDate, changeDate);
      expect(chat.modifiedSequence, modifiedSequence);
    }));

    test('Reset recent message count test', (() async {
      final data = {
        'Body': {
          'ResetRecentMessageCountResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.resetRecentMessageCount();
      expect(response, isNotNull);
      expect(response, isA<ResetRecentMessageCountResponse>());
    }));

    test('Restore contacts test', (() async {
      final data = {
        'Body': {
          'RestoreContactsResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.restoreContacts(faker.lorem.word());
      expect(response, isNotNull);
      expect(response, isA<RestoreContactsResponse>());
    }));

    test('Revoke permission test', (() async {
      final right = faker.lorem.word();
      final zimbraId = faker.guid.guid();
      final displayName = faker.person.name();
      final password = faker.internet.password();
      final accessKey = faker.internet.password();
      final deny = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'RevokePermissionResponse': {
            '_jsns': 'urn:zimbraMail',
            'ace': [
              {
                'gt': GranteeType.all.name,
                'right': right,
                'zid': zimbraId,
                'd': displayName,
                'pw': password,
                'key': accessKey,
                'deny': deny,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.revokePermission();
      final ace = response!.aces.first;

      expect(ace.granteeType, GranteeType.all);
      expect(ace.right, right);
      expect(ace.zimbraId, zimbraId);
      expect(ace.displayName, displayName);
      expect(ace.password, password);
      expect(ace.accessKey, accessKey);
      expect(ace.deny, deny);
    }));

    test('Save document test', (() async {
      final id = faker.guid.guid();
      final version = faker.randomGenerator.integer(100);
      final name = faker.lorem.word();

      final data = {
        'Body': {
          'SaveDocumentResponse': {
            '_jsns': 'urn:zimbraMail',
            'doc': {
              'id': id,
              'ver': version,
              'name': name,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.saveDocument(DocumentSpec());
      final doc = response!.doc!;

      expect(doc.id, id);
      expect(doc.version, version);
      expect(doc.name, name);
    }));

    test('Save draft test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final subject = faker.lorem.word();
      final section = faker.lorem.word();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final num = faker.randomGenerator.integer(100);
      final flags = faker.lorem.word();
      final tags = faker.randomGenerator.amount((_) => random.integer(10), 10, min: 5).join(',');
      final tagNames = faker.randomGenerator.amount((_) => random.string(10), 10, min: 5).join(',');

      final imapUid = faker.randomGenerator.integer(100);
      final calendarIntendedFor = faker.lorem.word();
      final origId = faker.guid.guid();
      final identityId = faker.guid.guid();
      final draftAccountId = faker.guid.guid();
      final draftAutoSendTime = faker.randomGenerator.integer(100);
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final resentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final part = faker.lorem.word();
      final fragment = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();
      final inReplyTo = faker.internet.email();
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.lorem.word();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();
      final recurrenceId = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final contentType = faker.lorem.word();
      final content = faker.lorem.word();
      final summary = faker.guid.guid();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final componentNum = faker.randomGenerator.integer(100);
      final method = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.date.dateTime().millisecondsSinceEpoch;
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();

      final data = {
        'Body': {
          'SaveDraftResponse': {
            '_jsns': 'urn:zimbraMail',
            'm': {
              'id': id,
              'i4uid': imapUid,
              'cif': calendarIntendedFor,
              'origid': origId,
              'rt': ReplyType.replied.name,
              'idnt': identityId,
              'forAcct': draftAccountId,
              'autoSendTime': draftAutoSendTime,
              'sd': sentDate,
              'rd': resentDate,
              'part': part,
              'fr': fragment,
              'e': [
                {
                  'a': address,
                  'd': display,
                  'p': personal,
                  't': AddressType.from.name,
                  'isGroup': isGroup,
                  'exp': canExpandGroupMembers,
                }
              ],
              'su': subject,
              'mid': messageIdHeader,
              'irt': inReplyTo,
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
              'inv': {
                'type': InviteType.appt.name,
                'tz': [
                  {
                    'id': id,
                    'stdoff': tzStdOffset,
                    'dayoff': tzDayOffset,
                    'standard': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'daylight': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'stdname': standardTZName,
                    'dayname': daylightTZName,
                  }
                ],
                'comp': {
                  'category': [
                    {'_content': category}
                  ],
                  'comment': [
                    {'_content': comment}
                  ],
                  'contact': [
                    {'_content': contact}
                  ],
                  'geo': {
                    'lat': latitude,
                    'lon': longitude,
                  },
                  'at': [
                    {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'cutype': cuType,
                      'role': role,
                      'ptst': partStat.name,
                      'rsvp': rsvp,
                      'member': member,
                      'delegatedTo': delegatedTo,
                      'delegatedFrom': delegatedFrom,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    }
                  ],
                  'alarm': [
                    {
                      'action': AlarmAction.display.name,
                      'trigger': {
                        'abs': {
                          'd': dateTimeString,
                        },
                        'rel': {
                          'd': dateTimeString,
                        },
                      },
                      'repeat': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'desc': {'_content': description},
                      'attach': {
                        'uri': uri,
                        'ct': contentType,
                        '_content': binaryB64Data,
                      },
                      'summary': {'_content': summary},
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    }
                  ],
                  'xprop': [
                    {
                      'name': name,
                      'value': value,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    }
                  ],
                  'fr': fragment,
                  'desc': {'_content': description},
                  'descHtml': {'_content': htmlDescription},
                  'or': {
                    'a': address,
                    'url': url,
                    'd': displayName,
                    'sentBy': sentBy,
                    'dir': dir,
                    'lang': language,
                    'xparam': [
                      {
                        'name': name,
                        'value': value,
                      }
                    ],
                  },
                  'recur': {
                    'add': [
                      {'add': {}}
                    ],
                    'exclude': [
                      {'exclude': {}}
                    ],
                    'except': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                        'add': {'add': []},
                        'exclude': {'exclude': []},
                      }
                    ],
                    'cancel': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                    'dates': [
                      {
                        'tz': timezone,
                        'dtval': [
                          {
                            's': {
                              'd': dateTimeString,
                              'tz': timezone,
                              'u': utcTime,
                            },
                            'e': {
                              'd': dateTimeString,
                              'tz': timezone,
                              'u': utcTime,
                            },
                            'dur': {
                              'neg': durationNegative,
                              'w': weeks,
                              'd': days,
                              'h': hours,
                              'm': minutes,
                              's': seconds,
                              'related': AlarmRelated.start.name,
                              'count': repeatCount,
                            },
                          }
                        ],
                      }
                    ],
                    'rule': [
                      {
                        'freq': Frequency.second.name,
                        'until': {
                          'd': dateTimeString,
                        },
                        'count': {
                          'num': num,
                        },
                        'interval': {
                          'ival': ival,
                        },
                        'bysecond': {
                          'seclist': list,
                        },
                        'byminute': {
                          'minlist': list,
                        },
                        'byhour': {
                          'hrlist': list,
                        },
                        'byday': {
                          'wkday': [
                            {
                              'day': WeekDay.sunday.name,
                              'ordWk': ordWk,
                            }
                          ],
                        },
                        'bymonthday': {
                          'modaylist': list,
                        },
                        'byyearday': {
                          'yrdaylist': list,
                        },
                        'byweekno': {
                          'wklist': list,
                        },
                        'bymonth': {
                          'molist': list,
                        },
                        'bysetpos': {
                          'poslist': list,
                        },
                        'wkst': {
                          'day': WeekDay.sunday.name,
                        },
                        'rule-x-name': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                  'exceptId': {
                    'd': dateTimeString,
                    'tz': timezone,
                    'rangeType': recurrenceRangeType,
                  },
                  's': {
                    'd': dateTimeString,
                    'tz': timezone,
                    'u': utcTime,
                  },
                  'e': {
                    'd': dateTimeString,
                    'tz': timezone,
                    'u': utcTime,
                  },
                  'dur': {
                    'neg': durationNegative,
                    'w': weeks,
                    'd': days,
                    'h': hours,
                    'm': minutes,
                    's': seconds,
                    'related': AlarmRelated.start.name,
                    'count': repeatCount,
                  },
                  'method': method,
                  'compNum': componentNum,
                  'rsvp': rsvp,
                  'priority': priority,
                  'name': name,
                  'loc': location,
                  'percentComplete': percentComplete,
                  'completed': completed,
                  'noBlob': noBlob,
                  'fba': FreeBusyStatus.free.name,
                  'fb': FreeBusyStatus.free.name,
                  'transp': Transparency.opaque.name,
                  'isOrg': isOrganizer,
                  'x_uid': xUid,
                  'uid': uid,
                  'seq': sequence,
                  'd': dateTime,
                  'calItemId': calItemId,
                  'apptId': deprecatedApptId,
                  'ciFolder': calItemFolder,
                  'status': InviteStatus.completed.name,
                  'class': InviteClass.public.name,
                  'url': url,
                  'ex': isException,
                  'ridZ': recurIdZ,
                  'allDay': isAllDay,
                  'draft': isDraft,
                  'neverSent': neverSent,
                  'changes': changes,
                },
                'replies': {
                  'reply': [
                    {
                      'rangeType': recurrenceRangeType,
                      'recurId': recurrenceId,
                      'seq': seq,
                      'd': date,
                      'at': attendee,
                      'sentBy': sentBy,
                      'ptst': partStat.name,
                      'tz': timezone,
                      'ridZ': recurIdZ,
                    }
                  ]
                }
              },
              '_attrs': {
                key: value,
              },
              'mp': [
                {
                  'part': part,
                  'ct': contentType,
                  's': size,
                  'cd': contentDisposition,
                  'filename': contentFilename,
                  'ci': contentId,
                  'cl': location,
                  'body': body,
                  'truncated': truncatedContent,
                  'content': content,
                  'mp': [
                    {
                      'part': part,
                      'ct': contentType,
                      's': size,
                      'cd': contentDisposition,
                      'filename': contentFilename,
                      'ci': contentId,
                      'cl': location,
                      'body': body,
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                }
              ],
              'shr': [
                {
                  'truncated': truncatedContent,
                  'content': content,
                }
              ],
              'dlSubs': [
                {
                  'truncated': truncatedContent,
                  'content': content,
                }
              ],
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
            'chat': {
              'id': id,
              'i4uid': imapUid,
              'cif': calendarIntendedFor,
              'origid': origId,
              'rt': ReplyType.replied.name,
              'idnt': identityId,
              'forAcct': draftAccountId,
              'autoSendTime': draftAutoSendTime,
              'sd': sentDate,
              'rd': resentDate,
              'part': part,
              'fr': fragment,
              'su': subject,
              'mid': messageIdHeader,
              'irt': inReplyTo,
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.saveDraft(SaveDraftMsg());

      final msg = response!.msgMessage!;
      expect(msg.id, id);
      expect(msg.imapUid, imapUid);
      expect(msg.calendarIntendedFor, calendarIntendedFor);
      expect(msg.origId, origId);
      expect(msg.draftReplyType, ReplyType.replied);
      expect(msg.identityId, identityId);
      expect(msg.draftAccountId, draftAccountId);
      expect(msg.draftAutoSendTime, draftAutoSendTime);
      expect(msg.sentDate, sentDate);
      expect(msg.resentDate, resentDate);
      expect(msg.part, part);
      expect(msg.fragment, fragment);
      expect(msg.subject, subject);
      expect(msg.messageIdHeader, messageIdHeader);
      expect(msg.inReplyTo, inReplyTo);
      expect(msg.size, size);
      expect(msg.date, date);
      expect(msg.folder, folder);
      expect(msg.conversationId, conversationId);
      expect(msg.flags, flags);
      expect(msg.tags, tags);
      expect(msg.tagNames, tagNames);
      expect(msg.revision, revision);
      expect(msg.changeDate, changeDate);
      expect(msg.modifiedSequence, modifiedSequence);

      final header = msg.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final partInfo = msg.partInfos.first;
      expect(partInfo.part, part);
      expect(partInfo.contentType, contentType);
      expect(partInfo.size, size);
      expect(partInfo.contentDisposition, contentDisposition);
      expect(partInfo.contentFilename, contentFilename);
      expect(partInfo.contentId, contentId);
      expect(partInfo.location, location);
      expect(partInfo.body, body);
      expect(partInfo.truncatedContent, truncatedContent);
      expect(partInfo.content, content);

      final mimePart = partInfo.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = msg.shareNotifications.first;
      expect(shr.content, content);
      expect(shr.truncatedContent, truncatedContent);

      final dlSubs = msg.dlSubsNotifications.first;
      expect(dlSubs.content, content);
      expect(dlSubs.truncatedContent, truncatedContent);

      final msgMeta = msg.metadatas.first;
      expect(msgMeta.section, section);
      expect(msgMeta.keyValuePairs.first.key, key);
      expect(msgMeta.keyValuePairs.first.value, value);

      final invite = msg.invite!;
      expect(invite.calItemType, InviteType.appt);

      final tz = invite.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = invite.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = invite.inviteComponent!;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);

      final chat = response.chatMessage!;
      expect(chat, isA<MessageInfo>());
      expect(chat.id, id);
      expect(chat.imapUid, imapUid);
      expect(chat.calendarIntendedFor, calendarIntendedFor);
      expect(chat.origId, origId);
      expect(chat.draftReplyType, ReplyType.replied);
      expect(chat.identityId, identityId);
      expect(chat.draftAccountId, draftAccountId);
      expect(chat.draftAutoSendTime, draftAutoSendTime);
      expect(chat.sentDate, sentDate);
      expect(chat.resentDate, resentDate);
      expect(chat.part, part);
      expect(chat.fragment, fragment);
      expect(chat.subject, subject);
      expect(chat.messageIdHeader, messageIdHeader);
      expect(chat.inReplyTo, inReplyTo);
      expect(chat.size, size);
      expect(chat.date, date);
      expect(chat.folder, folder);
      expect(chat.conversationId, conversationId);
      expect(chat.flags, flags);
      expect(chat.tags, tags);
      expect(chat.tagNames, tagNames);
      expect(chat.revision, revision);
      expect(chat.changeDate, changeDate);
      expect(chat.modifiedSequence, modifiedSequence);
    }));

    test('Save IMAP subscriptions test', (() async {
      final data = {
        'Body': {
          'SaveIMAPSubscriptionsResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.saveIMAPSubscriptions([]);
      expect(response, isNotNull);
      expect(response, isA<SaveIMAPSubscriptionsResponse>());
    }));

    test('Search action test', (() async {
      final data = {
        'Body': {
          'SearchActionResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.searchAction(SearchRequest(), BulkAction());
      expect(response, isNotNull);
      expect(response, isA<SearchActionResponse>());
    }));

    test('Search conversation test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();

      final sortBy = faker.randomGenerator.element(SearchSortBy.values);
      final queryOffset = faker.randomGenerator.integer(100);
      final queryMore = faker.randomGenerator.boolean();

      final num = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();

      final sortField = faker.lorem.word();
      final contentMatched = faker.randomGenerator.boolean();
      final imapUid = faker.randomGenerator.integer(100);
      final part = faker.lorem.word();
      final calendarIntendedFor = faker.lorem.word();
      final origId = faker.guid.guid();
      final draftReplyType = faker.randomGenerator.element(ReplyType.values);
      final identityId = faker.guid.guid();
      final draftAccountId = faker.guid.guid();
      final draftAutoSendTime = faker.date.dateTime().millisecondsSinceEpoch;
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final resentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final fragment = faker.lorem.word();
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.lorem.word();
      final addressType = faker.randomGenerator.element(AddressType.values);
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();
      final inReplyTo = faker.internet.email();
      final calItemType = faker.randomGenerator.element(InviteType.values);

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();
      final recurrenceId = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final contentType = faker.lorem.word();
      final content = faker.lorem.word();
      final summary = faker.guid.guid();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);
      final section = faker.lorem.word();

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final componentNum = faker.randomGenerator.integer(100);
      final method = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.date.dateTime().millisecondsSinceEpoch;
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();

      final suggestedQueryString = faker.lorem.word();
      final wildcardString = faker.lorem.word();
      final expanded = faker.randomGenerator.boolean();
      final numExpanded = faker.randomGenerator.integer(100);

      final data = {
        'Body': {
          'SearchConvResponse': {
            '_jsns': 'urn:zimbraMail',
            'sortBy': sortBy.name,
            'offset': queryOffset,
            'more': queryMore,
            'c': {
              'id': id,
              'n': num,
              'total': totalSize,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'm': [
                {
                  'sf': sortField,
                  'cm': contentMatched,
                  'hp': [
                    {
                      'part': part,
                    }
                  ],
                  'id': id,
                  'i4uid': imapUid,
                  'cif': calendarIntendedFor,
                  'origid': origId,
                  'rt': draftReplyType.name,
                  'idnt': identityId,
                  'forAcct': draftAccountId,
                  'autoSendTime': draftAutoSendTime,
                  'sd': sentDate,
                  'rd': resentDate,
                  'part': part,
                  'fr': fragment,
                  'e': [
                    {
                      'a': address,
                      'd': display,
                      'p': personal,
                      't': addressType.name,
                      'isGroup': isGroup,
                      'exp': canExpandGroupMembers,
                    }
                  ],
                  'su': subject,
                  'mid': messageIdHeader,
                  'irt': inReplyTo,
                  's': size,
                  'd': date,
                  'l': folder,
                  'cid': conversationId,
                  'f': flags,
                  't': tags,
                  'tn': tagNames,
                  'rev': revision,
                  'md': changeDate,
                  'ms': modifiedSequence,
                  'inv': {
                    'type': calItemType.name,
                    'tz': [
                      {
                        'id': id,
                        'stdoff': tzStdOffset,
                        'dayoff': tzDayOffset,
                        'standard': {
                          'mon': month,
                          'hour': hour,
                          'min': minute,
                          'sec': second,
                          'mday': dayOfMonth,
                          'week': week,
                          'wkday': dayOfWeek,
                        },
                        'daylight': {
                          'mon': month,
                          'hour': hour,
                          'min': minute,
                          'sec': second,
                          'mday': dayOfMonth,
                          'week': week,
                          'wkday': dayOfWeek,
                        },
                        'stdname': standardTZName,
                        'dayname': daylightTZName,
                      }
                    ],
                    'comp': {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    },
                    'replies': {
                      'reply': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'seq': seq,
                          'd': date,
                          'at': attendee,
                          'sentBy': sentBy,
                          'ptst': partStat.name,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ]
                    }
                  },
                  '_attrs': {
                    key: value,
                  },
                  'mp': [
                    {
                      'part': part,
                      'ct': contentType,
                      's': size,
                      'cd': contentDisposition,
                      'filename': contentFilename,
                      'ci': contentId,
                      'cl': location,
                      'body': body,
                      'truncated': truncatedContent,
                      'content': content,
                      'mp': [
                        {
                          'part': part,
                          'ct': contentType,
                          's': size,
                          'cd': contentDisposition,
                          'filename': contentFilename,
                          'ci': contentId,
                          'cl': location,
                          'body': body,
                          'truncated': truncatedContent,
                          'content': content,
                        }
                      ],
                    }
                  ],
                  'shr': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                  'dlSubs': [
                    {
                      'truncated': truncatedContent,
                      'content': content,
                    }
                  ],
                  'meta': [
                    {
                      'section': section,
                      '_attrs': {
                        key: value,
                      },
                    }
                  ],
                }
              ],
              'info': [
                {
                  'suggest': [
                    {
                      '_content': suggestedQueryString,
                    }
                  ],
                  'wildcard': [
                    {
                      'str': wildcardString,
                      'expanded': expanded,
                      'numExpanded': numExpanded,
                    }
                  ],
                }
              ],
            },
            'm': [
              {
                'sf': sortField,
                'cm': contentMatched,
                'hp': [
                  {
                    'part': part,
                  }
                ],
                'id': id,
                'i4uid': imapUid,
                'cif': calendarIntendedFor,
                'origid': origId,
                'rt': draftReplyType.name,
                'idnt': identityId,
                'forAcct': draftAccountId,
                'autoSendTime': draftAutoSendTime,
                'sd': sentDate,
                'rd': resentDate,
                'part': part,
                'fr': fragment,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': addressType.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'mid': messageIdHeader,
                'irt': inReplyTo,
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'inv': {
                  'type': calItemType.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'comp': {
                    'category': [
                      {'_content': category}
                    ],
                    'comment': [
                      {'_content': comment}
                    ],
                    'contact': [
                      {'_content': contact}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'alarm': [
                      {
                        'action': AlarmAction.display.name,
                        'trigger': {
                          'abs': {
                            'd': dateTimeString,
                          },
                          'rel': {
                            'd': dateTimeString,
                          },
                        },
                        'repeat': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': AlarmRelated.start.name,
                          'count': repeatCount,
                        },
                        'desc': {'_content': description},
                        'attach': {
                          'uri': uri,
                          'ct': contentType,
                          '_content': binaryB64Data,
                        },
                        'summary': {'_content': summary},
                        'at': [
                          {
                            'a': address,
                            'url': url,
                            'd': displayName,
                            'sentBy': sentBy,
                            'dir': dir,
                            'lang': language,
                            'cutype': cuType,
                            'role': role,
                            'ptst': partStat.name,
                            'rsvp': rsvp,
                            'member': member,
                            'delegatedTo': delegatedTo,
                            'delegatedFrom': delegatedFrom,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'xprop': [
                          {
                            'name': name,
                            'value': value,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'fr': fragment,
                    'desc': {'_content': description},
                    'descHtml': {'_content': htmlDescription},
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'recur': {
                      'add': [
                        {'add': {}}
                      ],
                      'exclude': [
                        {'exclude': {}}
                      ],
                      'except': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                          'add': {'add': []},
                          'exclude': {'exclude': []},
                        }
                      ],
                      'cancel': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ],
                      'dates': [
                        {
                          'tz': timezone,
                          'dtval': [
                            {
                              's': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'e': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'dur': {
                                'neg': durationNegative,
                                'w': weeks,
                                'd': days,
                                'h': hours,
                                'm': minutes,
                                's': seconds,
                                'related': AlarmRelated.start.name,
                                'count': repeatCount,
                              },
                            }
                          ],
                        }
                      ],
                      'rule': [
                        {
                          'freq': Frequency.second.name,
                          'until': {
                            'd': dateTimeString,
                          },
                          'count': {
                            'num': num,
                          },
                          'interval': {
                            'ival': ival,
                          },
                          'bysecond': {
                            'seclist': list,
                          },
                          'byminute': {
                            'minlist': list,
                          },
                          'byhour': {
                            'hrlist': list,
                          },
                          'byday': {
                            'wkday': [
                              {
                                'day': WeekDay.sunday.name,
                                'ordWk': ordWk,
                              }
                            ],
                          },
                          'bymonthday': {
                            'modaylist': list,
                          },
                          'byyearday': {
                            'yrdaylist': list,
                          },
                          'byweekno': {
                            'wklist': list,
                          },
                          'bymonth': {
                            'molist': list,
                          },
                          'bysetpos': {
                            'poslist': list,
                          },
                          'wkst': {
                            'day': WeekDay.sunday.name,
                          },
                          'rule-x-name': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    },
                    'exceptId': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'rangeType': recurrenceRangeType,
                    },
                    's': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'e': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'dur': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'method': method,
                    'compNum': componentNum,
                    'rsvp': rsvp,
                    'priority': priority,
                    'name': name,
                    'loc': location,
                    'percentComplete': percentComplete,
                    'completed': completed,
                    'noBlob': noBlob,
                    'fba': FreeBusyStatus.free.name,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'isOrg': isOrganizer,
                    'x_uid': xUid,
                    'uid': uid,
                    'seq': sequence,
                    'd': dateTime,
                    'calItemId': calItemId,
                    'apptId': deprecatedApptId,
                    'ciFolder': calItemFolder,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'url': url,
                    'ex': isException,
                    'ridZ': recurIdZ,
                    'allDay': isAllDay,
                    'draft': isDraft,
                    'neverSent': neverSent,
                    'changes': changes,
                  },
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ]
                  }
                },
                '_attrs': {
                  key: value,
                },
                'mp': [
                  {
                    'part': part,
                    'ct': contentType,
                    's': size,
                    'cd': contentDisposition,
                    'filename': contentFilename,
                    'ci': contentId,
                    'cl': location,
                    'body': body,
                    'truncated': truncatedContent,
                    'content': content,
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'shr': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'dlSubs': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              }
            ],
            'info': [
              {
                'suggest': [
                  {
                    '_content': suggestedQueryString,
                  }
                ],
                'wildcard': [
                  {
                    'str': wildcardString,
                    'expanded': expanded,
                    'numExpanded': numExpanded,
                  }
                ],
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.searchConv(id);

      expect(response!.sortBy, sortBy);
      expect(response.queryOffset, queryOffset);
      expect(response.queryMore, queryMore);

      final conversation = response.conversation!;
      expect(conversation.id, id);
      expect(conversation.num, num);
      expect(conversation.totalSize, totalSize);
      expect(conversation.flags, flags);
      expect(conversation.tags, tags);
      expect(conversation.tagNames, tagNames);

      final convMsg = conversation.messages.first;
      expect(convMsg.sortField, sortField);
      expect(convMsg.id, id);
      expect(convMsg.imapUid, imapUid);
      expect(convMsg.calendarIntendedFor, calendarIntendedFor);
      expect(convMsg.origId, origId);
      expect(convMsg.draftReplyType, draftReplyType);
      expect(convMsg.identityId, identityId);
      expect(convMsg.draftAccountId, draftAccountId);
      expect(convMsg.draftAutoSendTime, draftAutoSendTime);
      expect(convMsg.sentDate, sentDate);
      expect(convMsg.resentDate, resentDate);
      expect(convMsg.part, part);
      expect(convMsg.fragment, fragment);
      expect(convMsg.subject, subject);
      expect(convMsg.messageIdHeader, messageIdHeader);
      expect(convMsg.inReplyTo, inReplyTo);
      expect(convMsg.size, size);
      expect(convMsg.date, date);
      expect(convMsg.folder, folder);
      expect(convMsg.conversationId, conversationId);
      expect(convMsg.flags, flags);
      expect(convMsg.tags, tags);
      expect(convMsg.tagNames, tagNames);
      expect(convMsg.revision, revision);
      expect(convMsg.changeDate, changeDate);
      expect(convMsg.modifiedSequence, modifiedSequence);

      final convHeader = convMsg.headers.first;
      expect(convHeader.key, key);
      expect(convHeader.value, value);

      final convMsgPart = convMsg.messagePartHits.first;
      expect(convMsgPart.part, part);

      final convMsgEmail = convMsg.emails.first;
      expect(convMsgEmail.address, address);
      expect(convMsgEmail.display, display);
      expect(convMsgEmail.personal, personal);
      expect(convMsgEmail.addressType, addressType);
      expect(convMsgEmail.isGroup, isGroup);
      expect(convMsgEmail.canExpandGroupMembers, canExpandGroupMembers);

      final convPartInfo = convMsg.partInfos.first;
      expect(convPartInfo.part, part);
      expect(convPartInfo.contentType, contentType);
      expect(convPartInfo.size, size);
      expect(convPartInfo.contentDisposition, contentDisposition);
      expect(convPartInfo.contentFilename, contentFilename);
      expect(convPartInfo.contentId, contentId);
      expect(convPartInfo.location, location);
      expect(convPartInfo.body, body);
      expect(convPartInfo.truncatedContent, truncatedContent);
      expect(convPartInfo.content, content);

      final convMimePart = convPartInfo.mimeParts.first;
      expect(convMimePart.part, part);
      expect(convMimePart.contentType, contentType);
      expect(convMimePart.size, size);
      expect(convMimePart.contentDisposition, contentDisposition);
      expect(convMimePart.contentFilename, contentFilename);
      expect(convMimePart.contentId, contentId);
      expect(convMimePart.location, location);
      expect(convMimePart.body, body);
      expect(convMimePart.truncatedContent, truncatedContent);
      expect(convMimePart.content, content);

      final convShr = convMsg.shareNotifications.first;
      expect(convShr.content, content);
      expect(convShr.truncatedContent, truncatedContent);

      final convDlSubs = convMsg.dlSubsNotifications.first;
      expect(convDlSubs.content, content);
      expect(convDlSubs.truncatedContent, truncatedContent);

      final convMsgMeta = convMsg.metadatas.first;
      expect(convMsgMeta.section, section);
      expect(convMsgMeta.keyValuePairs.first.key, key);
      expect(convMsgMeta.keyValuePairs.first.value, value);

      final convMsgInvite = convMsg.invite!;
      expect(convMsgInvite.calItemType, calItemType);

      final convTz = convMsgInvite.timezones.first;
      expect(convTz.id, id);
      expect(convTz.tzStdOffset, tzStdOffset);
      expect(convTz.tzDayOffset, tzDayOffset);
      expect(convTz.standardTZName, standardTZName);
      expect(convTz.daylightTZName, daylightTZName);

      final convStandard = convTz.standardTzOnset!;
      expect(convStandard.month, month);
      expect(convStandard.hour, hour);
      expect(convStandard.minute, minute);
      expect(convStandard.second, second);
      expect(convStandard.dayOfMonth, dayOfMonth);
      expect(convStandard.week, week);
      expect(convStandard.dayOfWeek, dayOfWeek);

      final convDaylight = convTz.daylightTzOnset!;
      expect(convDaylight.month, month);
      expect(convDaylight.hour, hour);
      expect(convDaylight.minute, minute);
      expect(convDaylight.second, second);
      expect(convDaylight.dayOfMonth, dayOfMonth);
      expect(convDaylight.week, week);
      expect(convDaylight.dayOfWeek, dayOfWeek);

      final convMsgReply = convMsgInvite.calendarReplies.first;
      expect(convMsgReply.recurrenceRangeType, recurrenceRangeType);
      expect(convMsgReply.recurrenceId, recurrenceId);
      expect(convMsgReply.seq, seq);
      expect(convMsgReply.date, date);
      expect(convMsgReply.attendee, attendee);
      expect(convMsgReply.sentBy, sentBy);
      expect(convMsgReply.partStat, partStat);
      expect(convMsgReply.timezone, timezone);
      expect(convMsgReply.recurIdZ, recurIdZ);

      final convMsgComp = convMsgInvite.inviteComponent!;
      expect(convMsgComp.method, method);
      expect(convMsgComp.componentNum, componentNum);
      expect(convMsgComp.rsvp, rsvp);
      expect(convMsgComp.priority, priority);
      expect(convMsgComp.name, name);
      expect(convMsgComp.location, location);
      expect(convMsgComp.percentComplete, percentComplete);
      expect(convMsgComp.completed, completed);
      expect(convMsgComp.noBlob, noBlob);
      expect(convMsgComp.freeBusyActual, FreeBusyStatus.free);
      expect(convMsgComp.freeBusy, FreeBusyStatus.free);
      expect(convMsgComp.transparency, Transparency.opaque);
      expect(convMsgComp.isOrganizer, isOrganizer);
      expect(convMsgComp.xUid, xUid);
      expect(convMsgComp.uid, uid);
      expect(convMsgComp.sequence, sequence);
      expect(convMsgComp.dateTime, dateTime);
      expect(convMsgComp.calItemId, calItemId);
      expect(convMsgComp.deprecatedApptId, deprecatedApptId);
      expect(convMsgComp.calItemFolder, calItemFolder);
      expect(convMsgComp.status, InviteStatus.completed);
      expect(convMsgComp.calClass, InviteClass.public);
      expect(convMsgComp.url, url);
      expect(convMsgComp.isException, isException);
      expect(convMsgComp.recurIdZ, recurIdZ);
      expect(convMsgComp.isAllDay, isAllDay);
      expect(convMsgComp.isDraft, isDraft);
      expect(convMsgComp.neverSent, neverSent);
      expect(convMsgComp.changes, changes);

      expect(convMsgComp.fragment, fragment);
      expect(convMsgComp.description, description);
      expect(convMsgComp.htmlDescription, htmlDescription);

      expect(convMsgComp.categories.first, category);
      expect(convMsgComp.comments.first, comment);
      expect(convMsgComp.contacts.first, contact);

      final convMsgGeo = convMsgComp.geo!;
      expect(convMsgGeo.latitude, latitude);
      expect(convMsgGeo.longitude, longitude);

      final convMsgCompAt = convMsgComp.attendees.first;
      expect(convMsgCompAt.address, address);
      expect(convMsgCompAt.url, url);
      expect(convMsgCompAt.displayName, displayName);
      expect(convMsgCompAt.sentBy, sentBy);
      expect(convMsgCompAt.dir, dir);
      expect(convMsgCompAt.language, language);
      expect(convMsgCompAt.cuType, cuType);
      expect(convMsgCompAt.role, role);
      expect(convMsgCompAt.partStat, partStat);
      expect(convMsgCompAt.rsvp, rsvp);
      expect(convMsgCompAt.member, member);
      expect(convMsgCompAt.delegatedTo, delegatedTo);
      expect(convMsgCompAt.delegatedFrom, delegatedFrom);
      expect(convMsgCompAt.xParams.first.name, name);
      expect(convMsgCompAt.xParams.first.value, value);

      final convMsgAlarm = convMsgComp.alarms.first;
      expect(convMsgAlarm.action, AlarmAction.display);
      expect(convMsgAlarm.description, description);
      expect(convMsgAlarm.summary, summary);
      expect(convMsgAlarm.attach!.uri, uri);
      expect(convMsgAlarm.attach!.contentType, contentType);
      expect(convMsgAlarm.attach!.binaryB64Data, binaryB64Data);

      final convMsgAlarmAt = convMsgAlarm.attendees.first;
      expect(convMsgAlarmAt.address, address);
      expect(convMsgAlarmAt.url, url);
      expect(convMsgAlarmAt.displayName, displayName);
      expect(convMsgAlarmAt.sentBy, sentBy);
      expect(convMsgAlarmAt.dir, dir);
      expect(convMsgAlarmAt.language, language);
      expect(convMsgAlarmAt.cuType, cuType);
      expect(convMsgAlarmAt.role, role);
      expect(convMsgAlarmAt.partStat, partStat);
      expect(convMsgAlarmAt.rsvp, rsvp);
      expect(convMsgAlarmAt.member, member);
      expect(convMsgAlarmAt.delegatedTo, delegatedTo);
      expect(convMsgAlarmAt.delegatedFrom, delegatedFrom);
      expect(convMsgAlarmAt.xParams.first.name, name);
      expect(convMsgAlarmAt.xParams.first.value, value);

      final convMsgAlarmXProp = convMsgAlarm.xProps.first;
      expect(convMsgAlarmXProp.name, name);
      expect(convMsgAlarmXProp.value, value);
      expect(convMsgAlarmXProp.xParams.first.name, name);
      expect(convMsgAlarmXProp.xParams.first.value, value);

      final convMsgCompXProp = convMsgComp.xProps.first;
      expect(convMsgCompXProp.name, name);
      expect(convMsgCompXProp.value, value);
      expect(convMsgCompXProp.xParams.first.name, name);
      expect(convMsgCompXProp.xParams.first.value, value);

      final convMsgOrganizer = convMsgComp.organizer!;
      expect(convMsgOrganizer.address, address);
      expect(convMsgOrganizer.url, url);
      expect(convMsgOrganizer.displayName, displayName);
      expect(convMsgOrganizer.sentBy, sentBy);
      expect(convMsgOrganizer.dir, dir);
      expect(convMsgOrganizer.language, language);
      expect(convMsgOrganizer.xParams.first.name, name);
      expect(convMsgOrganizer.xParams.first.value, value);

      final convMsgRecurrence = convMsgComp.recurrence!;
      expect(convMsgRecurrence.add.first, isA<AddRecurrenceInfo>());
      expect(convMsgRecurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final convMsgExcept = convMsgRecurrence.except.first;
      expect(convMsgExcept.recurrenceRangeType, recurrenceRangeType);
      expect(convMsgExcept.recurrenceId, recurrenceId);
      expect(convMsgExcept.timezone, timezone);
      expect(convMsgExcept.recurIdZ, recurIdZ);
      expect(convMsgExcept.add, isA<RecurrenceInfo>());
      expect(convMsgExcept.exclude, isA<RecurrenceInfo>());

      final convMsgCancel = convMsgRecurrence.cancel.first;
      expect(convMsgCancel.recurrenceRangeType, recurrenceRangeType);
      expect(convMsgCancel.recurrenceId, recurrenceId);
      expect(convMsgCancel.timezone, timezone);
      expect(convMsgCancel.recurIdZ, recurIdZ);

      final convMsgDates = convMsgRecurrence.dates.first;
      expect(convMsgDates.timezone, timezone);

      final convMsgStartTime = convMsgDates.dtVals.first.startTime!;
      expect(convMsgStartTime.dateTime, dateTimeString);
      expect(convMsgStartTime.timezone, timezone);
      expect(convMsgStartTime.utcTime, utcTime);

      final convMsgEndTime = convMsgDates.dtVals.first.endTime!;
      expect(convMsgEndTime.dateTime, dateTimeString);
      expect(convMsgEndTime.timezone, timezone);
      expect(convMsgEndTime.utcTime, utcTime);

      final convMsgDuration = convMsgDates.dtVals.first.duration!;
      expect(convMsgDuration.durationNegative, durationNegative);
      expect(convMsgDuration.weeks, weeks);
      expect(convMsgDuration.days, days);
      expect(convMsgDuration.hours, hours);
      expect(convMsgDuration.minutes, minutes);
      expect(convMsgDuration.seconds, seconds);
      expect(convMsgDuration.related, AlarmRelated.start);
      expect(convMsgDuration.repeatCount, repeatCount);

      final convMsgSimple = convMsgRecurrence.simple.first;
      expect(convMsgSimple.until!.dateTime, dateTimeString);
      expect(convMsgSimple.count!.num, num);
      expect(convMsgSimple.interval!.ival, ival);
      expect(convMsgSimple.bySecond!.list, list);
      expect(convMsgSimple.byMinute!.list, list);
      expect(convMsgSimple.byHour!.list, list);
      expect(convMsgSimple.byDay!.days.first.day, WeekDay.sunday);
      expect(convMsgSimple.byDay!.days.first.ordWk, ordWk);
      expect(convMsgSimple.byMonthDay!.list, list);
      expect(convMsgSimple.byYearDay!.list, list);
      expect(convMsgSimple.byWeekNo!.list, list);
      expect(convMsgSimple.byMonth!.list, list);
      expect(convMsgSimple.bySetPose!.list, list);
      expect(convMsgSimple.weekStart!.day, WeekDay.sunday);
      expect(convMsgSimple.xNames.first.name, name);
      expect(convMsgSimple.xNames.first.value, value);

      final convMsgExceptionId = convMsgComp.exceptionId!;
      expect(convMsgExceptionId.dateTime, dateTimeString);
      expect(convMsgExceptionId.timezone, timezone);
      expect(convMsgExceptionId.recurrenceRangeType, recurrenceRangeType);

      final convMsgDtStart = convMsgComp.dtStart!;
      expect(convMsgDtStart.dateTime, dateTimeString);
      expect(convMsgDtStart.timezone, timezone);
      expect(convMsgDtStart.utcTime, utcTime);

      final convMsgDtEnd = convMsgComp.dtEnd!;
      expect(convMsgDtEnd.dateTime, dateTimeString);
      expect(convMsgDtEnd.timezone, timezone);
      expect(convMsgDtEnd.utcTime, utcTime);

      final convMsgInviteDuration = convMsgComp.duration!;
      expect(convMsgInviteDuration.durationNegative, durationNegative);
      expect(convMsgInviteDuration.weeks, weeks);
      expect(convMsgInviteDuration.days, days);
      expect(convMsgInviteDuration.hours, hours);
      expect(convMsgInviteDuration.minutes, minutes);
      expect(convMsgInviteDuration.seconds, seconds);
      expect(convMsgInviteDuration.related, AlarmRelated.start);
      expect(convMsgInviteDuration.repeatCount, repeatCount);

      final convQueryInfo = conversation.queryInfo!;
      expect(convQueryInfo.suggests.first.suggestedQueryString, suggestedQueryString);
      expect(convQueryInfo.wildcards.first.wildcardString, wildcardString);
      expect(convQueryInfo.wildcards.first.expanded, expanded);
      expect(convQueryInfo.wildcards.first.numExpanded, numExpanded);

      final resMsg = response.messages.first;
      expect(resMsg.sortField, sortField);
      expect(resMsg.id, id);
      expect(resMsg.imapUid, imapUid);
      expect(resMsg.calendarIntendedFor, calendarIntendedFor);
      expect(resMsg.origId, origId);
      expect(resMsg.draftReplyType, draftReplyType);
      expect(resMsg.identityId, identityId);
      expect(resMsg.draftAccountId, draftAccountId);
      expect(resMsg.draftAutoSendTime, draftAutoSendTime);
      expect(resMsg.sentDate, sentDate);
      expect(resMsg.resentDate, resentDate);
      expect(resMsg.part, part);
      expect(resMsg.fragment, fragment);
      expect(resMsg.subject, subject);
      expect(resMsg.messageIdHeader, messageIdHeader);
      expect(resMsg.inReplyTo, inReplyTo);
      expect(resMsg.size, size);
      expect(resMsg.date, date);
      expect(resMsg.folder, folder);
      expect(resMsg.conversationId, conversationId);
      expect(resMsg.flags, flags);
      expect(resMsg.tags, tags);
      expect(resMsg.tagNames, tagNames);
      expect(resMsg.revision, revision);
      expect(resMsg.changeDate, changeDate);
      expect(resMsg.modifiedSequence, modifiedSequence);

      final resMsgHeader = resMsg.headers.first;
      expect(resMsgHeader.key, key);
      expect(resMsgHeader.value, value);

      final resMsgPart = resMsg.messagePartHits.first;
      expect(resMsgPart.part, part);

      final resMsgEmail = resMsg.emails.first;
      expect(resMsgEmail.address, address);
      expect(resMsgEmail.display, display);
      expect(resMsgEmail.personal, personal);
      expect(resMsgEmail.addressType, addressType);
      expect(resMsgEmail.isGroup, isGroup);
      expect(resMsgEmail.canExpandGroupMembers, canExpandGroupMembers);

      final resMsgPartInfo = resMsg.partInfos.first;
      expect(resMsgPartInfo.part, part);
      expect(resMsgPartInfo.contentType, contentType);
      expect(resMsgPartInfo.size, size);
      expect(resMsgPartInfo.contentDisposition, contentDisposition);
      expect(resMsgPartInfo.contentFilename, contentFilename);
      expect(resMsgPartInfo.contentId, contentId);
      expect(resMsgPartInfo.location, location);
      expect(resMsgPartInfo.body, body);
      expect(resMsgPartInfo.truncatedContent, truncatedContent);
      expect(resMsgPartInfo.content, content);

      final resMsgMimePart = resMsgPartInfo.mimeParts.first;
      expect(resMsgMimePart.part, part);
      expect(resMsgMimePart.contentType, contentType);
      expect(resMsgMimePart.size, size);
      expect(resMsgMimePart.contentDisposition, contentDisposition);
      expect(resMsgMimePart.contentFilename, contentFilename);
      expect(resMsgMimePart.contentId, contentId);
      expect(resMsgMimePart.location, location);
      expect(resMsgMimePart.body, body);
      expect(resMsgMimePart.truncatedContent, truncatedContent);
      expect(resMsgMimePart.content, content);

      final resMsgShr = resMsg.shareNotifications.first;
      expect(resMsgShr.content, content);
      expect(resMsgShr.truncatedContent, truncatedContent);

      final resMsgDlSubs = resMsg.dlSubsNotifications.first;
      expect(resMsgDlSubs.content, content);
      expect(resMsgDlSubs.truncatedContent, truncatedContent);

      final resMsgMeta = resMsg.metadatas.first;
      expect(resMsgMeta.section, section);
      expect(resMsgMeta.keyValuePairs.first.key, key);
      expect(resMsgMeta.keyValuePairs.first.value, value);

      final resMsgInvite = resMsg.invite!;
      expect(resMsgInvite.calItemType, calItemType);

      final resMsgTz = resMsgInvite.timezones.first;
      expect(resMsgTz.id, id);
      expect(resMsgTz.tzStdOffset, tzStdOffset);
      expect(resMsgTz.tzDayOffset, tzDayOffset);
      expect(resMsgTz.standardTZName, standardTZName);
      expect(resMsgTz.daylightTZName, daylightTZName);

      final resMsgStandard = resMsgTz.standardTzOnset!;
      expect(resMsgStandard.month, month);
      expect(resMsgStandard.hour, hour);
      expect(resMsgStandard.minute, minute);
      expect(resMsgStandard.second, second);
      expect(resMsgStandard.dayOfMonth, dayOfMonth);
      expect(resMsgStandard.week, week);
      expect(resMsgStandard.dayOfWeek, dayOfWeek);

      final resMsgDaylight = resMsgTz.daylightTzOnset!;
      expect(resMsgDaylight.month, month);
      expect(resMsgDaylight.hour, hour);
      expect(resMsgDaylight.minute, minute);
      expect(resMsgDaylight.second, second);
      expect(resMsgDaylight.dayOfMonth, dayOfMonth);
      expect(resMsgDaylight.week, week);
      expect(resMsgDaylight.dayOfWeek, dayOfWeek);

      final resMsgReply = resMsgInvite.calendarReplies.first;
      expect(resMsgReply.recurrenceRangeType, recurrenceRangeType);
      expect(resMsgReply.recurrenceId, recurrenceId);
      expect(resMsgReply.seq, seq);
      expect(resMsgReply.date, date);
      expect(resMsgReply.attendee, attendee);
      expect(resMsgReply.sentBy, sentBy);
      expect(resMsgReply.partStat, partStat);
      expect(resMsgReply.timezone, timezone);
      expect(resMsgReply.recurIdZ, recurIdZ);

      final resMsgComp = resMsgInvite.inviteComponent!;
      expect(resMsgComp.method, method);
      expect(resMsgComp.componentNum, componentNum);
      expect(resMsgComp.rsvp, rsvp);
      expect(resMsgComp.priority, priority);
      expect(resMsgComp.name, name);
      expect(resMsgComp.location, location);
      expect(resMsgComp.percentComplete, percentComplete);
      expect(resMsgComp.completed, completed);
      expect(resMsgComp.noBlob, noBlob);
      expect(resMsgComp.freeBusyActual, FreeBusyStatus.free);
      expect(resMsgComp.freeBusy, FreeBusyStatus.free);
      expect(resMsgComp.transparency, Transparency.opaque);
      expect(resMsgComp.isOrganizer, isOrganizer);
      expect(resMsgComp.xUid, xUid);
      expect(resMsgComp.uid, uid);
      expect(resMsgComp.sequence, sequence);
      expect(resMsgComp.dateTime, dateTime);
      expect(resMsgComp.calItemId, calItemId);
      expect(resMsgComp.deprecatedApptId, deprecatedApptId);
      expect(resMsgComp.calItemFolder, calItemFolder);
      expect(resMsgComp.status, InviteStatus.completed);
      expect(resMsgComp.calClass, InviteClass.public);
      expect(resMsgComp.url, url);
      expect(resMsgComp.isException, isException);
      expect(resMsgComp.recurIdZ, recurIdZ);
      expect(resMsgComp.isAllDay, isAllDay);
      expect(resMsgComp.isDraft, isDraft);
      expect(resMsgComp.neverSent, neverSent);
      expect(resMsgComp.changes, changes);
      expect(resMsgComp.fragment, fragment);
      expect(resMsgComp.description, description);
      expect(resMsgComp.htmlDescription, htmlDescription);
      expect(resMsgComp.categories.first, category);
      expect(resMsgComp.comments.first, comment);
      expect(resMsgComp.contacts.first, contact);

      final resMsgGeo = resMsgComp.geo!;
      expect(resMsgGeo.latitude, latitude);
      expect(resMsgGeo.longitude, longitude);

      final resMsgCompAt = resMsgComp.attendees.first;
      expect(resMsgCompAt.address, address);
      expect(resMsgCompAt.url, url);
      expect(resMsgCompAt.displayName, displayName);
      expect(resMsgCompAt.sentBy, sentBy);
      expect(resMsgCompAt.dir, dir);
      expect(resMsgCompAt.language, language);
      expect(resMsgCompAt.cuType, cuType);
      expect(resMsgCompAt.role, role);
      expect(resMsgCompAt.partStat, partStat);
      expect(resMsgCompAt.rsvp, rsvp);
      expect(resMsgCompAt.member, member);
      expect(resMsgCompAt.delegatedTo, delegatedTo);
      expect(resMsgCompAt.delegatedFrom, delegatedFrom);
      expect(resMsgCompAt.xParams.first.name, name);
      expect(resMsgCompAt.xParams.first.value, value);

      final resMsgAlarm = resMsgComp.alarms.first;
      expect(resMsgAlarm.action, AlarmAction.display);
      expect(resMsgAlarm.description, description);
      expect(resMsgAlarm.summary, summary);
      expect(resMsgAlarm.attach!.uri, uri);
      expect(resMsgAlarm.attach!.contentType, contentType);
      expect(resMsgAlarm.attach!.binaryB64Data, binaryB64Data);

      final resMsgAlarmAt = resMsgAlarm.attendees.first;
      expect(resMsgAlarmAt.address, address);
      expect(resMsgAlarmAt.url, url);
      expect(resMsgAlarmAt.displayName, displayName);
      expect(resMsgAlarmAt.sentBy, sentBy);
      expect(resMsgAlarmAt.dir, dir);
      expect(resMsgAlarmAt.language, language);
      expect(resMsgAlarmAt.cuType, cuType);
      expect(resMsgAlarmAt.role, role);
      expect(resMsgAlarmAt.partStat, partStat);
      expect(resMsgAlarmAt.rsvp, rsvp);
      expect(resMsgAlarmAt.member, member);
      expect(resMsgAlarmAt.delegatedTo, delegatedTo);
      expect(resMsgAlarmAt.delegatedFrom, delegatedFrom);
      expect(resMsgAlarmAt.xParams.first.name, name);
      expect(resMsgAlarmAt.xParams.first.value, value);

      final resMsgAlarmXProp = resMsgAlarm.xProps.first;
      expect(resMsgAlarmXProp.name, name);
      expect(resMsgAlarmXProp.value, value);
      expect(resMsgAlarmXProp.xParams.first.name, name);
      expect(resMsgAlarmXProp.xParams.first.value, value);

      final resMsgCompXProp = resMsgComp.xProps.first;
      expect(resMsgCompXProp.name, name);
      expect(resMsgCompXProp.value, value);
      expect(resMsgCompXProp.xParams.first.name, name);
      expect(resMsgCompXProp.xParams.first.value, value);

      final resMsgOrganizer = resMsgComp.organizer!;
      expect(resMsgOrganizer.address, address);
      expect(resMsgOrganizer.url, url);
      expect(resMsgOrganizer.displayName, displayName);
      expect(resMsgOrganizer.sentBy, sentBy);
      expect(resMsgOrganizer.dir, dir);
      expect(resMsgOrganizer.language, language);
      expect(resMsgOrganizer.xParams.first.name, name);
      expect(resMsgOrganizer.xParams.first.value, value);

      final resMsgRecurrence = resMsgComp.recurrence!;
      expect(resMsgRecurrence.add.first, isA<AddRecurrenceInfo>());
      expect(resMsgRecurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final resMsgExcept = resMsgRecurrence.except.first;
      expect(resMsgExcept.recurrenceRangeType, recurrenceRangeType);
      expect(resMsgExcept.recurrenceId, recurrenceId);
      expect(resMsgExcept.timezone, timezone);
      expect(resMsgExcept.recurIdZ, recurIdZ);
      expect(resMsgExcept.add, isA<RecurrenceInfo>());
      expect(resMsgExcept.exclude, isA<RecurrenceInfo>());

      final resMsgCancel = resMsgRecurrence.cancel.first;
      expect(resMsgCancel.recurrenceRangeType, recurrenceRangeType);
      expect(resMsgCancel.recurrenceId, recurrenceId);
      expect(resMsgCancel.timezone, timezone);
      expect(resMsgCancel.recurIdZ, recurIdZ);

      final resMsgDates = resMsgRecurrence.dates.first;
      expect(resMsgDates.timezone, timezone);

      final resMsgStartTime = resMsgDates.dtVals.first.startTime!;
      expect(resMsgStartTime.dateTime, dateTimeString);
      expect(resMsgStartTime.timezone, timezone);
      expect(resMsgStartTime.utcTime, utcTime);

      final resMsgEndTime = resMsgDates.dtVals.first.endTime!;
      expect(resMsgEndTime.dateTime, dateTimeString);
      expect(resMsgEndTime.timezone, timezone);
      expect(resMsgEndTime.utcTime, utcTime);

      final resMsgDuration = resMsgDates.dtVals.first.duration!;
      expect(resMsgDuration.durationNegative, durationNegative);
      expect(resMsgDuration.weeks, weeks);
      expect(resMsgDuration.days, days);
      expect(resMsgDuration.hours, hours);
      expect(resMsgDuration.minutes, minutes);
      expect(resMsgDuration.seconds, seconds);
      expect(resMsgDuration.related, AlarmRelated.start);
      expect(resMsgDuration.repeatCount, repeatCount);

      final resMsgSimple = resMsgRecurrence.simple.first;
      expect(resMsgSimple.until!.dateTime, dateTimeString);
      expect(resMsgSimple.count!.num, num);
      expect(resMsgSimple.interval!.ival, ival);
      expect(resMsgSimple.bySecond!.list, list);
      expect(resMsgSimple.byMinute!.list, list);
      expect(resMsgSimple.byHour!.list, list);
      expect(resMsgSimple.byDay!.days.first.day, WeekDay.sunday);
      expect(resMsgSimple.byDay!.days.first.ordWk, ordWk);
      expect(resMsgSimple.byMonthDay!.list, list);
      expect(resMsgSimple.byYearDay!.list, list);
      expect(resMsgSimple.byWeekNo!.list, list);
      expect(resMsgSimple.byMonth!.list, list);
      expect(resMsgSimple.bySetPose!.list, list);
      expect(resMsgSimple.weekStart!.day, WeekDay.sunday);
      expect(resMsgSimple.xNames.first.name, name);
      expect(resMsgSimple.xNames.first.value, value);

      final resMsgExceptionId = resMsgComp.exceptionId!;
      expect(resMsgExceptionId.dateTime, dateTimeString);
      expect(resMsgExceptionId.timezone, timezone);
      expect(resMsgExceptionId.recurrenceRangeType, recurrenceRangeType);

      final resMsgDtStart = resMsgComp.dtStart!;
      expect(resMsgDtStart.dateTime, dateTimeString);
      expect(resMsgDtStart.timezone, timezone);
      expect(resMsgDtStart.utcTime, utcTime);

      final resMsgDtEnd = resMsgComp.dtEnd!;
      expect(resMsgDtEnd.dateTime, dateTimeString);
      expect(resMsgDtEnd.timezone, timezone);
      expect(resMsgDtEnd.utcTime, utcTime);

      final resMsgInviteDuration = resMsgComp.duration!;
      expect(resMsgInviteDuration.durationNegative, durationNegative);
      expect(resMsgInviteDuration.weeks, weeks);
      expect(resMsgInviteDuration.days, days);
      expect(resMsgInviteDuration.hours, hours);
      expect(resMsgInviteDuration.minutes, minutes);
      expect(resMsgInviteDuration.seconds, seconds);
      expect(resMsgInviteDuration.related, AlarmRelated.start);
      expect(resMsgInviteDuration.repeatCount, repeatCount);

      final resMsgQueryInfo = response.queryInfo!;
      expect(resMsgQueryInfo.suggests.first.suggestedQueryString, suggestedQueryString);
      expect(resMsgQueryInfo.wildcards.first.wildcardString, wildcardString);
      expect(resMsgQueryInfo.wildcards.first.expanded, expanded);
      expect(resMsgQueryInfo.wildcards.first.numExpanded, numExpanded);
    }));

    test('Search test', (() async {
      final id = faker.guid.guid();
      final uid = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final section = faker.lorem.word();

      final sortBy = faker.randomGenerator.element(SearchSortBy.values);
      final queryOffset = faker.randomGenerator.integer(100);
      final queryMore = faker.randomGenerator.boolean();
      final totalSize = faker.randomGenerator.integer(100);

      final sortField = faker.lorem.word();
      final size = faker.randomGenerator.integer(100);
      final folderId = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final bounds = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final autoSendTime = faker.date.dateTime().millisecondsSinceEpoch;
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final numMsg = faker.randomGenerator.integer(100);
      final numUnread = faker.randomGenerator.integer(100);
      final elided = faker.randomGenerator.boolean();
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final subject = faker.lorem.word();
      final fragment = faker.lorem.word();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.lorem.word();
      final addressType = faker.randomGenerator.element(AddressType.values);
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final num = faker.randomGenerator.integer(100);

      final contentMatched = faker.randomGenerator.boolean();
      final nextAlarm = faker.randomGenerator.integer(100);
      final alarmInstanceStart = faker.date.dateTime().millisecondsSinceEpoch;
      final imapUid = faker.randomGenerator.integer(100);
      final part = faker.lorem.word();
      final calendarIntendedFor = faker.lorem.word();
      final origId = faker.guid.guid();
      final draftReplyType = faker.randomGenerator.element(ReplyType.values);
      final identityId = faker.guid.guid();
      final draftAccountId = faker.guid.guid();
      final draftAutoSendTime = faker.date.dateTime().millisecondsSinceEpoch;
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final resentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final messageIdHeader = faker.guid.guid();
      final folder = faker.guid.guid();
      final conversationId = faker.randomGenerator.integer(100);
      final messageId = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);
      final metadataVersion = faker.randomGenerator.integer(100);
      final version = faker.randomGenerator.integer(100);

      final inReplyTo = faker.internet.email();
      final calItemType = faker.randomGenerator.element(InviteType.values);

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();
      final recurrenceId = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);
      final tzOffset = faker.randomGenerator.integer(100);
      final taskPercentComplete = faker.lorem.word();
      final isRecurring = faker.randomGenerator.boolean();
      final hasExceptions = faker.randomGenerator.boolean();
      final hasOtherAttendees = faker.randomGenerator.boolean();
      final hasAlarm = faker.randomGenerator.boolean();
      final invId = faker.randomGenerator.integer(100);
      final allDay = faker.randomGenerator.boolean();
      final draft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final taskDueDate = faker.date.dateTime().millisecondsSinceEpoch;
      final taskTzOffsetDue = faker.randomGenerator.integer(100);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final contentType = faker.lorem.word();
      final content = faker.lorem.word();
      final contentName = faker.lorem.word();
      final summary = faker.guid.guid();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final componentNum = faker.randomGenerator.integer(100);
      final method = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.date.dateTime().millisecondsSinceEpoch;
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final startTime = faker.date.dateTime().millisecondsSinceEpoch;
      final duration = faker.randomGenerator.integer(100);
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();

      final canExpand = faker.randomGenerator.boolean();
      final modifiedSequenceId = faker.randomGenerator.integer(100);
      final revisionId = faker.randomGenerator.integer(100);
      final fileAs = faker.lorem.word();
      final email = faker.internet.email();
      final email2 = faker.internet.email();
      final email3 = faker.internet.email();
      final type = faker.lorem.word();
      final dlist = faker.lorem.word();
      final reference = faker.lorem.word();
      final tooManyMembers = faker.randomGenerator.boolean();
      final memberOf = faker.internet.email();

      final descEnabled = faker.randomGenerator.boolean();
      final lastEditedBy = faker.lorem.word();
      final creator = faker.lorem.word();
      final createdDate = faker.date.dateTime().millisecondsSinceEpoch;
      final lockOwnerId = faker.guid.guid();
      final lockOwnerEmail = faker.internet.email();
      final lockOwnerTimestamp = faker.date.dateTime().toString();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);
      final perm = faker.lorem.word();
      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();

      final suggestedQueryString = faker.lorem.word();
      final wildcardString = faker.lorem.word();
      final expanded = faker.randomGenerator.boolean();
      final numExpanded = faker.randomGenerator.integer(100);

      final data = {
        'Body': {
          'SearchResponse': {
            '_jsns': 'urn:zimbraMail',
            'sortBy': sortBy.name,
            'offset': queryOffset,
            'more': queryMore,
            'total': totalSize,
            'hit': [
              {
                'id': id,
                'sf': sortField,
              }
            ],
            'c': [
              {
                'sf': sortField,
                'm': [
                  {
                    'id': id,
                    's': size.toString(),
                    'l': folderId,
                    'f': flags,
                    'autoSendTime': autoSendTime,
                    'd': date.toString(),
                  }
                ],
                'id': id,
                'n': numMsg,
                'u': numUnread,
                'total': totalSize,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'd': date,
                'elided': elided,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'su': subject,
                'fr': fragment,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': addressType.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
              }
            ],
            'm': [
              {
                'sf': sortField,
                'cm': contentMatched,
                'hp': [
                  {
                    'part': part,
                  }
                ],
                'id': id,
                'i4uid': imapUid,
                'cif': calendarIntendedFor,
                'origid': origId,
                'rt': draftReplyType.name,
                'idnt': identityId,
                'forAcct': draftAccountId,
                'autoSendTime': draftAutoSendTime,
                'sd': sentDate,
                'rd': resentDate,
                'part': part,
                'fr': fragment,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': addressType.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'mid': messageIdHeader,
                'irt': inReplyTo,
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId.toString(),
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'inv': {
                  'type': calItemType.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'comp': {
                    'category': [
                      {'_content': category}
                    ],
                    'comment': [
                      {'_content': comment}
                    ],
                    'contact': [
                      {'_content': contact}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'alarm': [
                      {
                        'action': AlarmAction.display.name,
                        'trigger': {
                          'abs': {
                            'd': dateTimeString,
                          },
                          'rel': {
                            'd': dateTimeString,
                          },
                        },
                        'repeat': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': AlarmRelated.start.name,
                          'count': repeatCount,
                        },
                        'desc': {'_content': description},
                        'attach': {
                          'uri': uri,
                          'ct': contentType,
                          '_content': binaryB64Data,
                        },
                        'summary': {'_content': summary},
                        'at': [
                          {
                            'a': address,
                            'url': url,
                            'd': displayName,
                            'sentBy': sentBy,
                            'dir': dir,
                            'lang': language,
                            'cutype': cuType,
                            'role': role,
                            'ptst': partStat.name,
                            'rsvp': rsvp,
                            'member': member,
                            'delegatedTo': delegatedTo,
                            'delegatedFrom': delegatedFrom,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'xprop': [
                          {
                            'name': name,
                            'value': value,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'fr': fragment,
                    'desc': {'_content': description},
                    'descHtml': {'_content': htmlDescription},
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'recur': {
                      'add': [
                        {'add': {}}
                      ],
                      'exclude': [
                        {'exclude': {}}
                      ],
                      'except': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                          'add': {'add': []},
                          'exclude': {'exclude': []},
                        }
                      ],
                      'cancel': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ],
                      'dates': [
                        {
                          'tz': timezone,
                          'dtval': [
                            {
                              's': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'e': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'dur': {
                                'neg': durationNegative,
                                'w': weeks,
                                'd': days,
                                'h': hours,
                                'm': minutes,
                                's': seconds,
                                'related': AlarmRelated.start.name,
                                'count': repeatCount,
                              },
                            }
                          ],
                        }
                      ],
                      'rule': [
                        {
                          'freq': Frequency.second.name,
                          'until': {
                            'd': dateTimeString,
                          },
                          'count': {
                            'num': num,
                          },
                          'interval': {
                            'ival': ival,
                          },
                          'bysecond': {
                            'seclist': list,
                          },
                          'byminute': {
                            'minlist': list,
                          },
                          'byhour': {
                            'hrlist': list,
                          },
                          'byday': {
                            'wkday': [
                              {
                                'day': WeekDay.sunday.name,
                                'ordWk': ordWk,
                              }
                            ],
                          },
                          'bymonthday': {
                            'modaylist': list,
                          },
                          'byyearday': {
                            'yrdaylist': list,
                          },
                          'byweekno': {
                            'wklist': list,
                          },
                          'bymonth': {
                            'molist': list,
                          },
                          'bysetpos': {
                            'poslist': list,
                          },
                          'wkst': {
                            'day': WeekDay.sunday.name,
                          },
                          'rule-x-name': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    },
                    'exceptId': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'rangeType': recurrenceRangeType,
                    },
                    's': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'e': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'dur': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'method': method,
                    'compNum': componentNum,
                    'rsvp': rsvp,
                    'priority': priority,
                    'name': name,
                    'loc': location,
                    'percentComplete': percentComplete,
                    'completed': completed,
                    'noBlob': noBlob,
                    'fba': FreeBusyStatus.free.name,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'isOrg': isOrganizer,
                    'x_uid': xUid,
                    'uid': uid,
                    'seq': sequence,
                    'd': dateTime,
                    'calItemId': calItemId,
                    'apptId': deprecatedApptId,
                    'ciFolder': calItemFolder,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'url': url,
                    'ex': isException,
                    'ridZ': recurIdZ,
                    'allDay': isAllDay,
                    'draft': isDraft,
                    'neverSent': neverSent,
                    'changes': changes,
                  },
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ]
                  }
                },
                '_attrs': {
                  key: value,
                },
                'mp': [
                  {
                    'part': part,
                    'ct': contentType,
                    's': size,
                    'cd': contentDisposition,
                    'filename': contentFilename,
                    'ci': contentId,
                    'cl': location,
                    'body': body,
                    'truncated': truncatedContent,
                    'content': content,
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'shr': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'dlSubs': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              }
            ],
            'chat': [
              {
                'sf': sortField,
                'cm': contentMatched,
                'id': id,
                'i4uid': imapUid,
                'cif': calendarIntendedFor,
                'origid': origId,
                'rt': draftReplyType.name,
                'idnt': identityId,
                'forAcct': draftAccountId,
                'autoSendTime': draftAutoSendTime,
                'sd': sentDate,
                'rd': resentDate,
                'part': part,
                'fr': fragment,
                'su': subject,
                'mid': messageIdHeader,
                'irt': inReplyTo,
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId.toString(),
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
              }
            ],
            'mp': [
              {
                'id': id,
                'sf': sortField,
                's': size,
                'd': date,
                'cid': conversationId,
                'mid': messageId,
                'ct': contentType,
                'name': contentName,
                'part': part,
                'e': {
                  'a': address,
                  'd': display,
                  'p': personal,
                  't': addressType.name,
                  'isGroup': isGroup,
                  'exp': canExpandGroupMembers,
                },
                'su': subject,
              }
            ],
            'cn': [
              {
                'sf': sortField,
                'exp': canExpand,
                'id': id,
                'i4uid': imapUid,
                'l': folder,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'md': changeDate,
                'ms': modifiedSequenceId,
                'd': date,
                'rev': revisionId,
                'fileAsStr': fileAs,
                'email': email,
                'email2': email2,
                'email3': email3,
                'type': type,
                'dlist': dlist,
                'ref': reference,
                'tooManyMembers': tooManyMembers,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                '_attrs': {
                  key: value,
                },
                'm': [
                  {
                    'type': MemberType.contact.name,
                    '_content': value,
                    'cn': {
                      'sf': sortField,
                      'exp': canExpand,
                      'id': id,
                      'i4uid': imapUid,
                      'l': folder,
                      'f': flags,
                      't': tags,
                      'tn': tagNames,
                      'md': changeDate,
                      'ms': modifiedSequenceId,
                      'd': date,
                      'rev': revisionId,
                      'fileAsStr': fileAs,
                      'email': email,
                      'email2': email2,
                      'email3': email3,
                      'type': type,
                      'dlist': dlist,
                      'ref': reference,
                      'tooManyMembers': tooManyMembers,
                      'memberOf': {'_content': memberOf},
                    },
                  }
                ],
                'memberOf': {'_content': memberOf},
              }
            ],
            'note': [
              {
                'sf': sortField,
                'id': id,
                'rev': revision,
                'l': folder,
                'd': date,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'pos': bounds,
                'color': color,
                'rgb': rgb,
                'md': changeDate,
                'ms': modifiedSequence,
                'content': content,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              }
            ],
            'doc': [
              {
                'sf': sortField,
                'loid': lockOwnerId,
                'loe': lockOwnerEmail,
                'lt': lockOwnerTimestamp,
                'id': id,
                'uuid': uuid,
                'name': name,
                's': size,
                'd': date,
                'l': folderId,
                'luuid': folderUuid,
                'ms': modifiedSequence,
                'mdver': metadataVersion,
                'md': changeDate,
                'rev': revision,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'desc': description,
                'ct': contentType,
                'descEnabled': descEnabled,
                'ver': version,
                'leb': lastEditedBy,
                'cr': creator,
                'cd': createdDate,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'fr': fragment,
                'acl': {
                  'internalGrantExpiry': internalGrantExpiry,
                  'guestGrantExpiry': guestGrantExpiry,
                  'grant': [
                    {
                      'perm': perm,
                      'gt': GrantGranteeType.all.name,
                      'zid': granteeId,
                      'expiry': expiry,
                      'd': granteeName,
                      'pw': guestPassword,
                      'key': accessKey,
                    }
                  ],
                },
              }
            ],
            'w': [
              {
                'sf': sortField,
                'id': id,
                'uuid': uuid,
                'name': name,
                's': size,
                'd': date,
                'l': folderId,
                'luuid': folderUuid,
                'ms': modifiedSequence,
                'mdver': metadataVersion,
                'md': changeDate,
                'rev': revision,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'desc': description,
                'ct': contentType,
                'descEnabled': descEnabled,
                'ver': version,
                'leb': lastEditedBy,
                'cr': creator,
                'cd': createdDate,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'fr': fragment,
                'acl': {
                  'internalGrantExpiry': internalGrantExpiry,
                  'guestGrantExpiry': guestGrantExpiry,
                  'grant': [
                    {
                      'perm': perm,
                      'gt': GrantGranteeType.all.name,
                      'zid': granteeId,
                      'expiry': expiry,
                      'd': granteeName,
                      'pw': guestPassword,
                      'key': accessKey,
                    }
                  ],
                },
              }
            ],
            'appt': [
              {
                'sf': sortField,
                'd': date,
                'cm': contentMatched,
                'nextAlarm': nextAlarm,
                'or': {
                  'a': address,
                  'url': url,
                  'd': displayName,
                  'sentBy': sentBy,
                  'dir': dir,
                  'lang': language,
                  'xparam': [
                    {
                      'name': name,
                      'value': value,
                    }
                  ],
                },
                'category': [
                  {'_content': category}
                ],
                'geo': {
                  'lat': latitude,
                  'lon': longitude,
                },
                'fr': fragment,
                'inst': [
                  {
                    's': startTime,
                    'ex': isException,
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'category': [
                      {'_content': category}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'fr': fragment,
                    'dur': duration,
                    'ptst': partStat.name,
                    'ridZ': recurIdZ,
                    'tzo': tzOffset,
                    'fba': FreeBusyStatus.free.name,
                    'percentComplete': taskPercentComplete,
                    'recur': isRecurring,
                    'hasEx': hasExceptions,
                    'priority': priority,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'name': name,
                    'loc': location,
                    'otherAtt': hasOtherAttendees,
                    'alarm': hasAlarm,
                    'isOrg': isOrganizer,
                    'invId': invId.toString(),
                    'compNum': componentNum,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'allDay': allDay,
                    'draft': draft,
                    'neverSent': neverSent,
                    'dueDate': taskDueDate,
                    'tzoDue': taskTzOffsetDue,
                  }
                ],
                'alarmData': {
                  'nextAlarm': nextAlarm,
                  'alarmInstStart': alarmInstanceStart,
                  'invId': invId,
                  'compNum': componentNum,
                  'name': name,
                  'loc': location,
                  'alarm': {
                    'action': AlarmAction.display.name,
                    'trigger': {
                      'abs': {
                        'd': dateTimeString,
                      },
                      'rel': {
                        'd': dateTimeString,
                      },
                    },
                    'repeat': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'desc': {'_content': description},
                    'attach': {
                      'uri': uri,
                      'ct': contentType,
                      '_content': binaryB64Data,
                    },
                    'summary': {'_content': summary},
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                },
                'inv': [
                  {
                    'type': calItemType.name,
                    'seq': sequence,
                    'id': id,
                    'compNum': componentNum,
                    'recurId': recurrenceId,
                    'tz': [
                      {
                        'id': id,
                        'stdoff': tzStdOffset,
                        'dayoff': tzDayOffset,
                        'standard': {
                          'mon': month,
                          'hour': hour,
                          'min': minute,
                          'sec': second,
                          'mday': dayOfMonth,
                          'week': week,
                          'wkday': dayOfWeek,
                        },
                        'daylight': {
                          'mon': month,
                          'hour': hour,
                          'min': minute,
                          'sec': second,
                          'mday': dayOfMonth,
                          'week': week,
                          'wkday': dayOfWeek,
                        },
                        'stdname': standardTZName,
                        'dayname': daylightTZName,
                      }
                    ],
                    'comp': {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': []}
                        ],
                        'exclude': [
                          {'exclude': []}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    },
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                        'mp': [
                          {
                            'part': part,
                            'ct': contentType,
                            's': size,
                            'cd': contentDisposition,
                            'filename': contentFilename,
                            'ci': contentId,
                            'cl': location,
                            'body': body,
                            'truncated': truncatedContent,
                            'content': content,
                          }
                        ],
                      }
                    ],
                    'shr': [
                      {
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                    'dlSubs': [
                      {
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'replies': {
                  'reply': [
                    {
                      'rangeType': recurrenceRangeType,
                      'recurId': recurrenceId,
                      'at': attendee,
                      'sentBy': sentBy,
                      'ptst': partStat.name,
                      'seq': sequence,
                      'd': date,
                      'tz': timezone,
                      'ridZ': recurIdZ,
                    }
                  ]
                },
                'x_uid': xUid,
                'uid': uid,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'l': folderId,
                's': size,
                'md': changeDate,
                'ms': modifiedSequence,
                'rev': revision,
                'id': id,
                'dur': duration,
                'ptst': partStat.name,
                'ridZ': recurIdZ,
                'tzo': tzOffset,
                'fba': FreeBusyStatus.free.name,
                'percentComplete': taskPercentComplete,
                'recur': isRecurring,
                'hasEx': hasExceptions,
                'priority': priority,
                'fb': FreeBusyStatus.free.name,
                'transp': Transparency.opaque.name,
                'name': name,
                'loc': location,
                'otherAtt': hasOtherAttendees,
                'alarm': hasAlarm,
                'isOrg': isOrganizer,
                'invId': invId.toString(),
                'compNum': componentNum,
                'status': InviteStatus.completed.name,
                'class': InviteClass.public.name,
                'allDay': allDay,
                'draft': draft,
                'neverSent': neverSent,
                'dueDate': taskDueDate,
                'tzoDue': taskTzOffsetDue,
              }
            ],
            'task': [
              {
                'sf': sortField,
                'd': date,
                'cm': contentMatched,
                'nextAlarm': nextAlarm,
                'fr': fragment,
                'x_uid': xUid,
                'uid': uid,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'l': folderId,
                's': size,
                'md': changeDate,
                'ms': modifiedSequence,
                'rev': revision,
                'id': id,
                'dur': duration,
                'ptst': partStat.name,
                'ridZ': recurIdZ,
                'tzo': tzOffset,
                'fba': FreeBusyStatus.free.name,
                'percentComplete': taskPercentComplete,
                'recur': isRecurring,
                'hasEx': hasExceptions,
                'priority': priority,
                'fb': FreeBusyStatus.free.name,
                'transp': Transparency.opaque.name,
                'name': name,
                'loc': location,
                'otherAtt': hasOtherAttendees,
                'alarm': hasAlarm,
                'isOrg': isOrganizer,
                'invId': invId.toString(),
                'compNum': componentNum,
                'status': InviteStatus.completed.name,
                'class': InviteClass.public.name,
                'allDay': allDay,
                'draft': draft,
                'neverSent': neverSent,
                'dueDate': taskDueDate,
                'tzoDue': taskTzOffsetDue,
              }
            ],
            'info': [
              {
                'suggest': [
                  {
                    '_content': suggestedQueryString,
                  }
                ],
                'wildcard': [
                  {
                    'str': wildcardString,
                    'expanded': expanded,
                    'numExpanded': numExpanded,
                  }
                ],
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.search();

      expect(response!.sortBy, sortBy);
      expect(response.queryOffset, queryOffset);
      expect(response.queryMore, queryMore);
      expect(response.totalSize, totalSize);

      final simpleHit = response.simpleHits.first;
      expect(simpleHit.sortField, sortField);
      expect(simpleHit.id, id);

      final convHit = response.conversationHits.first;
      expect(convHit.sortField, sortField);
      expect(convHit.id, id);
      expect(convHit.numMsg, numMsg);
      expect(convHit.numUnread, numUnread);
      expect(convHit.totalSize, totalSize);
      expect(convHit.flags, flags);
      expect(convHit.tags, tags);
      expect(convHit.tagNames, tagNames);
      expect(convHit.date, date);
      expect(convHit.elided, elided);
      expect(convHit.changeDate, changeDate);
      expect(convHit.modifiedSequence, modifiedSequence);
      expect(convHit.subject, subject);
      expect(convHit.fragment, fragment);

      final convHitMsg = convHit.messageHits.first;
      expect(convHitMsg.id, id);
      expect(convHitMsg.size, size);
      expect(convHitMsg.folderId, folderId);
      expect(convHitMsg.flags, flags);
      expect(convHitMsg.autoSendTime, autoSendTime);
      expect(convHitMsg.date, date);

      final convHitMeta = convHit.metadatas.first;
      expect(convHitMeta.section, section);
      expect(convHitMeta.keyValuePairs.first.key, key);
      expect(convHitMeta.keyValuePairs.first.value, value);

      final convHitEmail = convHit.emails.first;
      expect(convHitEmail.address, address);
      expect(convHitEmail.display, display);
      expect(convHitEmail.personal, personal);
      expect(convHitEmail.addressType, addressType);
      expect(convHitEmail.isGroup, isGroup);
      expect(convHitEmail.canExpandGroupMembers, canExpandGroupMembers);

      final msgHit = response.messageHits.first;
      expect(msgHit.sortField, sortField);
      expect(msgHit.contentMatched, contentMatched);
      expect(msgHit.id, id);
      expect(msgHit.imapUid, imapUid);
      expect(msgHit.calendarIntendedFor, calendarIntendedFor);
      expect(msgHit.origId, origId);
      expect(msgHit.draftReplyType, draftReplyType);
      expect(msgHit.identityId, identityId);
      expect(msgHit.draftAccountId, draftAccountId);
      expect(msgHit.draftAutoSendTime, draftAutoSendTime);
      expect(msgHit.sentDate, sentDate);
      expect(msgHit.resentDate, resentDate);
      expect(msgHit.part, part);
      expect(msgHit.fragment, fragment);
      expect(msgHit.subject, subject);
      expect(msgHit.messageIdHeader, messageIdHeader);
      expect(msgHit.inReplyTo, inReplyTo);
      expect(msgHit.size, size);
      expect(msgHit.date, date);
      expect(msgHit.folder, folder);
      expect(msgHit.conversationId, conversationId.toString());
      expect(msgHit.flags, flags);
      expect(msgHit.tags, tags);
      expect(msgHit.tagNames, tagNames);
      expect(msgHit.revision, revision);
      expect(msgHit.changeDate, changeDate);
      expect(msgHit.modifiedSequence, modifiedSequence);

      final msgHitPart = msgHit.messagePartHits.first;
      expect(msgHitPart.part, part);

      final msgHitEmail = msgHit.emails.first;
      expect(msgHitEmail.address, address);
      expect(msgHitEmail.display, display);
      expect(msgHitEmail.personal, personal);
      expect(msgHitEmail.addressType, addressType);
      expect(msgHitEmail.isGroup, isGroup);
      expect(msgHitEmail.canExpandGroupMembers, canExpandGroupMembers);

      final msgHitHeader = msgHit.headers.first;
      expect(msgHitHeader.key, key);
      expect(msgHitHeader.value, value);

      final msgHitPartInfo = msgHit.partInfos.first;
      expect(msgHitPartInfo.part, part);
      expect(msgHitPartInfo.contentType, contentType);
      expect(msgHitPartInfo.size, size);
      expect(msgHitPartInfo.contentDisposition, contentDisposition);
      expect(msgHitPartInfo.contentFilename, contentFilename);
      expect(msgHitPartInfo.contentId, contentId);
      expect(msgHitPartInfo.location, location);
      expect(msgHitPartInfo.body, body);
      expect(msgHitPartInfo.truncatedContent, truncatedContent);
      expect(msgHitPartInfo.content, content);

      final msgHitMimePart = msgHitPartInfo.mimeParts.first;
      expect(msgHitMimePart.part, part);
      expect(msgHitMimePart.contentType, contentType);
      expect(msgHitMimePart.size, size);
      expect(msgHitMimePart.contentDisposition, contentDisposition);
      expect(msgHitMimePart.contentFilename, contentFilename);
      expect(msgHitMimePart.contentId, contentId);
      expect(msgHitMimePart.location, location);
      expect(msgHitMimePart.body, body);
      expect(msgHitMimePart.truncatedContent, truncatedContent);
      expect(msgHitMimePart.content, content);

      final msgHitShr = msgHit.shareNotifications.first;
      expect(msgHitShr.content, content);
      expect(msgHitShr.truncatedContent, truncatedContent);

      final msgHitDlSubs = msgHit.dlSubsNotifications.first;
      expect(msgHitDlSubs.content, content);
      expect(msgHitDlSubs.truncatedContent, truncatedContent);

      final msgHitMsgMeta = msgHit.metadatas.first;
      expect(msgHitMsgMeta.section, section);
      expect(msgHitMsgMeta.keyValuePairs.first.key, key);
      expect(msgHitMsgMeta.keyValuePairs.first.value, value);

      final msgHitInvite = msgHit.invite!;
      expect(msgHitInvite.calItemType, calItemType);

      final msgHitTz = msgHitInvite.timezones.first;
      expect(msgHitTz.id, id);
      expect(msgHitTz.tzStdOffset, tzStdOffset);
      expect(msgHitTz.tzDayOffset, tzDayOffset);
      expect(msgHitTz.standardTZName, standardTZName);
      expect(msgHitTz.daylightTZName, daylightTZName);

      final msgHitStandard = msgHitTz.standardTzOnset!;
      expect(msgHitStandard.month, month);
      expect(msgHitStandard.hour, hour);
      expect(msgHitStandard.minute, minute);
      expect(msgHitStandard.second, second);
      expect(msgHitStandard.dayOfMonth, dayOfMonth);
      expect(msgHitStandard.week, week);
      expect(msgHitStandard.dayOfWeek, dayOfWeek);

      final msgHitDaylight = msgHitTz.daylightTzOnset!;
      expect(msgHitDaylight.month, month);
      expect(msgHitDaylight.hour, hour);
      expect(msgHitDaylight.minute, minute);
      expect(msgHitDaylight.second, second);
      expect(msgHitDaylight.dayOfMonth, dayOfMonth);
      expect(msgHitDaylight.week, week);
      expect(msgHitDaylight.dayOfWeek, dayOfWeek);

      final msgHitReply = msgHitInvite.calendarReplies.first;
      expect(msgHitReply.recurrenceRangeType, recurrenceRangeType);
      expect(msgHitReply.recurrenceId, recurrenceId);
      expect(msgHitReply.seq, seq);
      expect(msgHitReply.date, date);
      expect(msgHitReply.attendee, attendee);
      expect(msgHitReply.sentBy, sentBy);
      expect(msgHitReply.partStat, partStat);
      expect(msgHitReply.timezone, timezone);
      expect(msgHitReply.recurIdZ, recurIdZ);

      final msgHitComp = msgHitInvite.inviteComponent!;
      expect(msgHitComp.method, method);
      expect(msgHitComp.componentNum, componentNum);
      expect(msgHitComp.rsvp, rsvp);
      expect(msgHitComp.priority, priority);
      expect(msgHitComp.name, name);
      expect(msgHitComp.location, location);
      expect(msgHitComp.percentComplete, percentComplete);
      expect(msgHitComp.completed, completed);
      expect(msgHitComp.noBlob, noBlob);
      expect(msgHitComp.freeBusyActual, FreeBusyStatus.free);
      expect(msgHitComp.freeBusy, FreeBusyStatus.free);
      expect(msgHitComp.transparency, Transparency.opaque);
      expect(msgHitComp.isOrganizer, isOrganizer);
      expect(msgHitComp.xUid, xUid);
      expect(msgHitComp.uid, uid);
      expect(msgHitComp.sequence, sequence);
      expect(msgHitComp.dateTime, dateTime);
      expect(msgHitComp.calItemId, calItemId);
      expect(msgHitComp.deprecatedApptId, deprecatedApptId);
      expect(msgHitComp.calItemFolder, calItemFolder);
      expect(msgHitComp.status, InviteStatus.completed);
      expect(msgHitComp.calClass, InviteClass.public);
      expect(msgHitComp.url, url);
      expect(msgHitComp.isException, isException);
      expect(msgHitComp.recurIdZ, recurIdZ);
      expect(msgHitComp.isAllDay, isAllDay);
      expect(msgHitComp.isDraft, isDraft);
      expect(msgHitComp.neverSent, neverSent);
      expect(msgHitComp.changes, changes);
      expect(msgHitComp.fragment, fragment);
      expect(msgHitComp.description, description);
      expect(msgHitComp.htmlDescription, htmlDescription);
      expect(msgHitComp.categories.first, category);
      expect(msgHitComp.comments.first, comment);
      expect(msgHitComp.contacts.first, contact);

      final msgHitGeo = msgHitComp.geo!;
      expect(msgHitGeo.latitude, latitude);
      expect(msgHitGeo.longitude, longitude);

      final msgHitAtt = msgHitComp.attendees.first;
      expect(msgHitAtt.address, address);
      expect(msgHitAtt.url, url);
      expect(msgHitAtt.displayName, displayName);
      expect(msgHitAtt.sentBy, sentBy);
      expect(msgHitAtt.dir, dir);
      expect(msgHitAtt.language, language);
      expect(msgHitAtt.cuType, cuType);
      expect(msgHitAtt.role, role);
      expect(msgHitAtt.partStat, partStat);
      expect(msgHitAtt.rsvp, rsvp);
      expect(msgHitAtt.member, member);
      expect(msgHitAtt.delegatedTo, delegatedTo);
      expect(msgHitAtt.delegatedFrom, delegatedFrom);
      expect(msgHitAtt.xParams.first.name, name);
      expect(msgHitAtt.xParams.first.value, value);

      final msgHitAlarm = msgHitComp.alarms.first;
      expect(msgHitAlarm.action, AlarmAction.display);
      expect(msgHitAlarm.description, description);
      expect(msgHitAlarm.summary, summary);
      expect(msgHitAlarm.attach!.uri, uri);
      expect(msgHitAlarm.attach!.contentType, contentType);
      expect(msgHitAlarm.attach!.binaryB64Data, binaryB64Data);

      final msgHitAlarmAtt = msgHitAlarm.attendees.first;
      expect(msgHitAlarmAtt.address, address);
      expect(msgHitAlarmAtt.url, url);
      expect(msgHitAlarmAtt.displayName, displayName);
      expect(msgHitAlarmAtt.sentBy, sentBy);
      expect(msgHitAlarmAtt.dir, dir);
      expect(msgHitAlarmAtt.language, language);
      expect(msgHitAlarmAtt.cuType, cuType);
      expect(msgHitAlarmAtt.role, role);
      expect(msgHitAlarmAtt.partStat, partStat);
      expect(msgHitAlarmAtt.rsvp, rsvp);
      expect(msgHitAlarmAtt.member, member);
      expect(msgHitAlarmAtt.delegatedTo, delegatedTo);
      expect(msgHitAlarmAtt.delegatedFrom, delegatedFrom);
      expect(msgHitAlarmAtt.xParams.first.name, name);
      expect(msgHitAlarmAtt.xParams.first.value, value);

      final msgHitAlarmXProp = msgHitAlarm.xProps.first;
      expect(msgHitAlarmXProp.name, name);
      expect(msgHitAlarmXProp.value, value);
      expect(msgHitAlarmXProp.xParams.first.name, name);
      expect(msgHitAlarmXProp.xParams.first.value, value);

      final msgHitCompXProp = msgHitComp.xProps.first;
      expect(msgHitCompXProp.name, name);
      expect(msgHitCompXProp.value, value);
      expect(msgHitCompXProp.xParams.first.name, name);
      expect(msgHitCompXProp.xParams.first.value, value);

      final msgHitOrganizer = msgHitComp.organizer!;
      expect(msgHitOrganizer.address, address);
      expect(msgHitOrganizer.url, url);
      expect(msgHitOrganizer.displayName, displayName);
      expect(msgHitOrganizer.sentBy, sentBy);
      expect(msgHitOrganizer.dir, dir);
      expect(msgHitOrganizer.language, language);
      expect(msgHitOrganizer.xParams.first.name, name);
      expect(msgHitOrganizer.xParams.first.value, value);

      final msgHitRecurrence = msgHitComp.recurrence!;
      expect(msgHitRecurrence.add.first, isA<AddRecurrenceInfo>());
      expect(msgHitRecurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final msgHitExcept = msgHitRecurrence.except.first;
      expect(msgHitExcept.recurrenceRangeType, recurrenceRangeType);
      expect(msgHitExcept.recurrenceId, recurrenceId);
      expect(msgHitExcept.timezone, timezone);
      expect(msgHitExcept.recurIdZ, recurIdZ);
      expect(msgHitExcept.add, isA<RecurrenceInfo>());
      expect(msgHitExcept.exclude, isA<RecurrenceInfo>());

      final msgHitCancel = msgHitRecurrence.cancel.first;
      expect(msgHitCancel.recurrenceRangeType, recurrenceRangeType);
      expect(msgHitCancel.recurrenceId, recurrenceId);
      expect(msgHitCancel.timezone, timezone);
      expect(msgHitCancel.recurIdZ, recurIdZ);
      final msgHitDates = msgHitRecurrence.dates.first;
      expect(msgHitDates.timezone, timezone);

      final msgHitStartTime = msgHitDates.dtVals.first.startTime!;
      expect(msgHitStartTime.dateTime, dateTimeString);
      expect(msgHitStartTime.timezone, timezone);
      expect(msgHitStartTime.utcTime, utcTime);

      final msgHitEndTime = msgHitDates.dtVals.first.endTime!;
      expect(msgHitEndTime.dateTime, dateTimeString);
      expect(msgHitEndTime.timezone, timezone);
      expect(msgHitEndTime.utcTime, utcTime);

      final msgHitDuration = msgHitDates.dtVals.first.duration!;
      expect(msgHitDuration.durationNegative, durationNegative);
      expect(msgHitDuration.weeks, weeks);
      expect(msgHitDuration.days, days);
      expect(msgHitDuration.hours, hours);
      expect(msgHitDuration.minutes, minutes);
      expect(msgHitDuration.seconds, seconds);
      expect(msgHitDuration.related, AlarmRelated.start);
      expect(msgHitDuration.repeatCount, repeatCount);

      final msgHitSimple = msgHitRecurrence.simple.first;
      expect(msgHitSimple.until!.dateTime, dateTimeString);
      expect(msgHitSimple.count!.num, num);
      expect(msgHitSimple.interval!.ival, ival);
      expect(msgHitSimple.bySecond!.list, list);
      expect(msgHitSimple.byMinute!.list, list);
      expect(msgHitSimple.byHour!.list, list);
      expect(msgHitSimple.byDay!.days.first.day, WeekDay.sunday);
      expect(msgHitSimple.byDay!.days.first.ordWk, ordWk);
      expect(msgHitSimple.byMonthDay!.list, list);
      expect(msgHitSimple.byYearDay!.list, list);
      expect(msgHitSimple.byWeekNo!.list, list);
      expect(msgHitSimple.byMonth!.list, list);
      expect(msgHitSimple.bySetPose!.list, list);
      expect(msgHitSimple.weekStart!.day, WeekDay.sunday);
      expect(msgHitSimple.xNames.first.name, name);
      expect(msgHitSimple.xNames.first.value, value);

      final msgHitExceptionId = msgHitComp.exceptionId!;
      expect(msgHitExceptionId.dateTime, dateTimeString);
      expect(msgHitExceptionId.timezone, timezone);
      expect(msgHitExceptionId.recurrenceRangeType, recurrenceRangeType);

      final msgHitDtStart = msgHitComp.dtStart!;
      expect(msgHitDtStart.dateTime, dateTimeString);
      expect(msgHitDtStart.timezone, timezone);
      expect(msgHitDtStart.utcTime, utcTime);

      final msgHitDtEnd = msgHitComp.dtEnd!;
      expect(msgHitDtEnd.dateTime, dateTimeString);
      expect(msgHitDtEnd.timezone, timezone);
      expect(msgHitDtEnd.utcTime, utcTime);

      final msgHitInviteDuration = msgHitComp.duration!;
      expect(msgHitInviteDuration.durationNegative, durationNegative);
      expect(msgHitInviteDuration.weeks, weeks);
      expect(msgHitInviteDuration.days, days);
      expect(msgHitInviteDuration.hours, hours);
      expect(msgHitInviteDuration.minutes, minutes);
      expect(msgHitInviteDuration.seconds, seconds);
      expect(msgHitInviteDuration.related, AlarmRelated.start);
      expect(msgHitInviteDuration.repeatCount, repeatCount);

      final chatHit = response.chatHits.first;
      expect(chatHit, isA<MessageHitInfo>());
      expect(chatHit.sortField, sortField);
      expect(chatHit.contentMatched, contentMatched);
      expect(chatHit.id, id);
      expect(chatHit.imapUid, imapUid);
      expect(chatHit.calendarIntendedFor, calendarIntendedFor);
      expect(chatHit.origId, origId);
      expect(chatHit.draftReplyType, draftReplyType);
      expect(chatHit.identityId, identityId);
      expect(chatHit.draftAccountId, draftAccountId);
      expect(chatHit.draftAutoSendTime, draftAutoSendTime);
      expect(chatHit.sentDate, sentDate);
      expect(chatHit.resentDate, resentDate);
      expect(chatHit.part, part);
      expect(chatHit.fragment, fragment);
      expect(chatHit.subject, subject);
      expect(chatHit.messageIdHeader, messageIdHeader);
      expect(chatHit.inReplyTo, inReplyTo);
      expect(chatHit.size, size);
      expect(chatHit.date, date);
      expect(chatHit.folder, folder);
      expect(chatHit.conversationId, conversationId.toString());
      expect(chatHit.flags, flags);
      expect(chatHit.tags, tags);
      expect(chatHit.tagNames, tagNames);
      expect(chatHit.revision, revision);
      expect(chatHit.changeDate, changeDate);
      expect(chatHit.modifiedSequence, modifiedSequence);

      final mpHit = response.messagePartHits.first;
      expect(mpHit.id, id);
      expect(mpHit.sortField, sortField);
      expect(mpHit.size, size);
      expect(mpHit.date, date);
      expect(mpHit.conversationId, conversationId);
      expect(mpHit.messageId, messageId);
      expect(mpHit.contentType, contentType);
      expect(mpHit.contentName, contentName);
      expect(mpHit.part, part);
      expect(mpHit.subject, subject);

      final mpHitEmail = mpHit.email!;
      expect(mpHitEmail.address, address);
      expect(mpHitEmail.display, display);
      expect(mpHitEmail.personal, personal);
      expect(mpHitEmail.addressType, addressType);
      expect(mpHitEmail.isGroup, isGroup);
      expect(mpHitEmail.canExpandGroupMembers, canExpandGroupMembers);

      final contactHit = response.contactHits.first;
      expect(contactHit.sortField, sortField);
      expect(contactHit.canExpand, canExpand);
      expect(contactHit.id, id);
      expect(contactHit.imapUid, imapUid);
      expect(contactHit.folder, folder);
      expect(contactHit.flags, flags);
      expect(contactHit.tags, tags);
      expect(contactHit.tagNames, tagNames);
      expect(contactHit.changeDate, changeDate);
      expect(contactHit.modifiedSequenceId, modifiedSequenceId);
      expect(contactHit.date, date);
      expect(contactHit.revisionId, revisionId);
      expect(contactHit.fileAs, fileAs);
      expect(contactHit.email, email);
      expect(contactHit.email2, email2);
      expect(contactHit.email3, email3);
      expect(contactHit.type, type);
      expect(contactHit.dlist, dlist);
      expect(contactHit.reference, reference);
      expect(contactHit.tooManyMembers, tooManyMembers);
      expect(contactHit.memberOf, memberOf);
      final contactMeta = contactHit.metadatas.first;
      expect(contactMeta.section, section);
      expect(contactMeta.keyValuePairs.first.key, key);
      expect(contactMeta.keyValuePairs.first.value, value);

      final contactAttr = contactHit.attrs.first;
      expect(contactAttr.key, key);
      expect(contactAttr.value, value);

      final contactMember = contactHit.contactGroupMembers.first;
      expect(contactMember.type, MemberType.contact);
      expect(contactMember.value, value);

      final cnMember = contactMember.contact!;
      expect(cnMember.sortField, sortField);
      expect(cnMember.canExpand, canExpand);
      expect(cnMember.id, id);
      expect(cnMember.imapUid, imapUid);
      expect(cnMember.folder, folder);
      expect(cnMember.flags, flags);
      expect(cnMember.tags, tags);
      expect(cnMember.tagNames, tagNames);
      expect(cnMember.changeDate, changeDate);
      expect(cnMember.modifiedSequenceId, modifiedSequenceId);
      expect(cnMember.date, date);
      expect(cnMember.revisionId, revisionId);
      expect(cnMember.fileAs, fileAs);
      expect(cnMember.email, email);
      expect(cnMember.email2, email2);
      expect(cnMember.email3, email3);
      expect(cnMember.type, type);
      expect(cnMember.dlist, dlist);
      expect(cnMember.reference, reference);
      expect(cnMember.tooManyMembers, tooManyMembers);
      expect(cnMember.memberOf, memberOf);

      final noteHit = response.noteHits.first;
      expect(noteHit.sortField, sortField);
      expect(noteHit.id, id);
      expect(noteHit.revision, revision);
      expect(noteHit.folder, folder);
      expect(noteHit.date, date);
      expect(noteHit.flags, flags);
      expect(noteHit.tags, tags);
      expect(noteHit.tagNames, tagNames);
      expect(noteHit.bounds, bounds);
      expect(noteHit.color, color);
      expect(noteHit.rgb, rgb);
      expect(noteHit.changeDate, changeDate);
      expect(noteHit.modifiedSequence, modifiedSequence);
      expect(noteHit.content, content);

      final noteHitMeta = noteHit.metadatas.first;
      expect(noteHitMeta.section, section);
      expect(noteHitMeta.keyValuePairs.first.key, key);
      expect(noteHitMeta.keyValuePairs.first.value, value);

      final docHit = response.documentHits.first;
      expect(docHit.sortField, sortField);
      expect(docHit.lockOwnerId, lockOwnerId);
      expect(docHit.lockOwnerEmail, lockOwnerEmail);
      expect(docHit.lockOwnerTimestamp, lockOwnerTimestamp);
      expect(docHit.id, id);
      expect(docHit.uuid, uuid);
      expect(docHit.name, name);
      expect(docHit.size, size);
      expect(docHit.date, date);
      expect(docHit.folderId, folderId);
      expect(docHit.folderUuid, folderUuid);
      expect(docHit.modifiedSequence, modifiedSequence);
      expect(docHit.metadataVersion, metadataVersion);
      expect(docHit.changeDate, changeDate);
      expect(docHit.revision, revision);
      expect(docHit.flags, flags);
      expect(docHit.tags, tags);
      expect(docHit.tagNames, tagNames);
      expect(docHit.description, description);
      expect(docHit.contentType, contentType);
      expect(docHit.descEnabled, descEnabled);
      expect(docHit.version, version);
      expect(docHit.lastEditedBy, lastEditedBy);
      expect(docHit.creator, creator);
      expect(docHit.createdDate, createdDate);
      expect(docHit.fragment, fragment);

      final docHitMeta = docHit.metadatas.first;
      expect(docHitMeta.section, section);
      expect(docHitMeta.keyValuePairs.first.key, key);
      expect(docHitMeta.keyValuePairs.first.value, value);

      final docHitAcl = docHit.acl!;
      expect(docHitAcl.internalGrantExpiry, internalGrantExpiry);
      expect(docHitAcl.guestGrantExpiry, guestGrantExpiry);

      final docHitGrant = docHitAcl.grants.first;
      expect(docHitGrant.perm, perm);
      expect(docHitGrant.granteeType, GrantGranteeType.all);
      expect(docHitGrant.granteeId, granteeId);
      expect(docHitGrant.expiry, expiry);
      expect(docHitGrant.granteeName, granteeName);
      expect(docHitGrant.guestPassword, guestPassword);
      expect(docHitGrant.accessKey, accessKey);

      final wikiHit = response.wikiHits.first;
      expect(wikiHit.sortField, sortField);
      expect(wikiHit.id, id);
      expect(wikiHit.uuid, uuid);
      expect(wikiHit.name, name);
      expect(wikiHit.size, size);
      expect(wikiHit.date, date);
      expect(wikiHit.folderId, folderId);
      expect(wikiHit.folderUuid, folderUuid);
      expect(wikiHit.modifiedSequence, modifiedSequence);
      expect(wikiHit.metadataVersion, metadataVersion);
      expect(wikiHit.changeDate, changeDate);
      expect(wikiHit.revision, revision);
      expect(wikiHit.flags, flags);
      expect(wikiHit.tags, tags);
      expect(wikiHit.tagNames, tagNames);
      expect(wikiHit.description, description);
      expect(wikiHit.contentType, contentType);
      expect(wikiHit.descEnabled, descEnabled);
      expect(wikiHit.version, version);
      expect(wikiHit.lastEditedBy, lastEditedBy);
      expect(wikiHit.creator, creator);
      expect(wikiHit.createdDate, createdDate);
      expect(wikiHit.fragment, fragment);

      final wikiHitMeta = wikiHit.metadatas.first;
      expect(wikiHitMeta.section, section);
      expect(wikiHitMeta.keyValuePairs.first.key, key);
      expect(wikiHitMeta.keyValuePairs.first.value, value);

      final wikiHitAcl = wikiHit.acl!;
      expect(wikiHitAcl.internalGrantExpiry, internalGrantExpiry);
      expect(wikiHitAcl.guestGrantExpiry, guestGrantExpiry);

      final wikiHitGrant = wikiHitAcl.grants.first;
      expect(wikiHitGrant.perm, perm);
      expect(wikiHitGrant.granteeType, GrantGranteeType.all);
      expect(wikiHitGrant.granteeId, granteeId);
      expect(wikiHitGrant.expiry, expiry);
      expect(wikiHitGrant.granteeName, granteeName);
      expect(wikiHitGrant.guestPassword, guestPassword);
      expect(wikiHitGrant.accessKey, accessKey);

      final apptHit = response.appointmentHits.first;
      expect(apptHit.sortField, sortField);
      expect(apptHit.date, date);
      expect(apptHit.contentMatched, contentMatched);
      expect(apptHit.nextAlarm, nextAlarm);
      expect(apptHit.fragment, fragment);
      expect(apptHit.xUid, xUid);
      expect(apptHit.uid, uid);
      expect(apptHit.flags, flags);
      expect(apptHit.tags, tags);
      expect(apptHit.tagNames, tagNames);
      expect(apptHit.folderId, folderId);
      expect(apptHit.size, size);
      expect(apptHit.changeDate, changeDate);
      expect(apptHit.modifiedSequence, modifiedSequence);
      expect(apptHit.revision, revision);
      expect(apptHit.id, id);
      expect(apptHit.duration, duration);
      expect(apptHit.partStat, partStat);
      expect(apptHit.recurIdZ, recurIdZ);
      expect(apptHit.tzOffset, tzOffset);
      expect(apptHit.freeBusyActual, FreeBusyStatus.free);
      expect(apptHit.taskPercentComplete, taskPercentComplete);
      expect(apptHit.isRecurring, isRecurring);
      expect(apptHit.hasExceptions, hasExceptions);
      expect(apptHit.priority, priority);
      expect(apptHit.freeBusyIntended, FreeBusyStatus.free);
      expect(apptHit.transparency, Transparency.opaque);
      expect(apptHit.name, name);
      expect(apptHit.location, location);
      expect(apptHit.hasOtherAttendees, hasOtherAttendees);
      expect(apptHit.hasAlarm, hasAlarm);
      expect(apptHit.isOrganizer, isOrganizer);
      expect(apptHit.invId, invId.toString());
      expect(apptHit.componentNum, componentNum);
      expect(apptHit.status, InviteStatus.completed);
      expect(apptHit.calClass, InviteClass.public);
      expect(apptHit.allDay, allDay);
      expect(apptHit.draft, draft);
      expect(apptHit.neverSent, neverSent);
      expect(apptHit.taskDueDate, taskDueDate);
      expect(apptHit.taskTzOffsetDue, taskTzOffsetDue);
      expect(apptHit.categories.first, category);

      final apptHitOrganizer = apptHit.organizer!;
      expect(apptHitOrganizer.address, address);
      expect(apptHitOrganizer.url, url);
      expect(apptHitOrganizer.displayName, displayName);
      expect(apptHitOrganizer.sentBy, sentBy);
      expect(apptHitOrganizer.dir, dir);
      expect(apptHitOrganizer.language, language);
      expect(apptHitOrganizer.xParams.first.name, name);
      expect(apptHitOrganizer.xParams.first.value, value);

      final apptHitGeo = apptHit.geo!;
      expect(apptHitGeo.latitude, latitude);
      expect(apptHitGeo.longitude, longitude);

      final apptHitInst = apptHit.instances.first;
      expect(apptHitInst.startTime, startTime);
      expect(apptHitInst.isException, isException);
      expect(apptHitInst.fragment, fragment);
      expect(apptHitInst.duration, duration);
      expect(apptHitInst.partStat, partStat);
      expect(apptHitInst.recurIdZ, recurIdZ);
      expect(apptHitInst.tzOffset, tzOffset);
      expect(apptHitInst.freeBusyActual, FreeBusyStatus.free);
      expect(apptHitInst.taskPercentComplete, taskPercentComplete);
      expect(apptHitInst.isRecurring, isRecurring);
      expect(apptHitInst.hasExceptions, hasExceptions);
      expect(apptHitInst.priority, priority);
      expect(apptHitInst.freeBusyIntended, FreeBusyStatus.free);
      expect(apptHitInst.transparency, Transparency.opaque);
      expect(apptHitInst.name, name);
      expect(apptHitInst.location, location);
      expect(apptHitInst.hasOtherAttendees, hasOtherAttendees);
      expect(apptHitInst.hasAlarm, hasAlarm);
      expect(apptHitInst.isOrganizer, isOrganizer);
      expect(apptHitInst.invId, invId.toString());
      expect(apptHitInst.componentNum, componentNum);
      expect(apptHitInst.status, InviteStatus.completed);
      expect(apptHitInst.calClass, InviteClass.public);
      expect(apptHitInst.allDay, allDay);
      expect(apptHitInst.draft, draft);
      expect(apptHitInst.neverSent, neverSent);
      expect(apptHitInst.taskDueDate, taskDueDate);
      expect(apptHitInst.taskTzOffsetDue, taskTzOffsetDue);
      expect(apptHitInst.categories.first, category);

      final apptHitInstOrganizer = apptHitInst.organizer!;
      expect(apptHitInstOrganizer.address, address);
      expect(apptHitInstOrganizer.url, url);
      expect(apptHitInstOrganizer.displayName, displayName);
      expect(apptHitInstOrganizer.sentBy, sentBy);
      expect(apptHitInstOrganizer.dir, dir);
      expect(apptHitInstOrganizer.language, language);
      expect(apptHitInstOrganizer.xParams.first.name, name);
      expect(apptHitInstOrganizer.xParams.first.value, value);

      final apptHitInstEeo = apptHitInst.geo!;
      expect(apptHitInstEeo.latitude, latitude);
      expect(apptHitInstEeo.longitude, longitude);

      final apptHitAlarmData = apptHit.alarmData!;
      expect(apptHitAlarmData.nextAlarm, nextAlarm);
      expect(apptHitAlarmData.alarmInstanceStart, alarmInstanceStart);
      expect(apptHitAlarmData.invId, invId);
      expect(apptHitAlarmData.componentNum, componentNum);
      expect(apptHitAlarmData.name, name);
      expect(apptHitAlarmData.location, location);

      final apptHitAlarm = apptHitAlarmData.alarm!;
      expect(apptHitAlarm.action, AlarmAction.display);
      expect(apptHitAlarm.description, description);
      expect(apptHitAlarm.summary, summary);
      expect(apptHitAlarm.attach!.uri, uri);
      expect(apptHitAlarm.attach!.contentType, contentType);
      expect(apptHitAlarm.attach!.binaryB64Data, binaryB64Data);

      final apptHitAlarmAt = apptHitAlarm.attendees.first;
      expect(apptHitAlarmAt.address, address);
      expect(apptHitAlarmAt.url, url);
      expect(apptHitAlarmAt.displayName, displayName);
      expect(apptHitAlarmAt.sentBy, sentBy);
      expect(apptHitAlarmAt.dir, dir);
      expect(apptHitAlarmAt.language, language);
      expect(apptHitAlarmAt.cuType, cuType);
      expect(apptHitAlarmAt.role, role);
      expect(apptHitAlarmAt.partStat, partStat);
      expect(apptHitAlarmAt.rsvp, rsvp);
      expect(apptHitAlarmAt.member, member);
      expect(apptHitAlarmAt.delegatedTo, delegatedTo);
      expect(apptHitAlarmAt.delegatedFrom, delegatedFrom);
      expect(apptHitAlarmAt.xParams.first.name, name);
      expect(apptHitAlarmAt.xParams.first.value, value);

      final apptHitAlarmXProp = apptHitAlarm.xProps.first;
      expect(apptHitAlarmXProp.name, name);
      expect(apptHitAlarmXProp.value, value);
      expect(apptHitAlarmXProp.xParams.first.name, name);
      expect(apptHitAlarmXProp.xParams.first.value, value);

      final apptHitInvite = apptHit.invites.first;
      expect(apptHitInvite.calItemType, calItemType);
      expect(apptHitInvite.sequence, sequence);
      expect(apptHitInvite.id, id);
      expect(apptHitInvite.componentNum, componentNum);
      expect(apptHitInvite.recurrenceId, recurrenceId);

      final apptHitInviteTz = apptHitInvite.timezones.first;
      expect(apptHitInviteTz.id, id);
      expect(apptHitInviteTz.tzStdOffset, tzStdOffset);
      expect(apptHitInviteTz.tzDayOffset, tzDayOffset);
      expect(apptHitInviteTz.standardTZName, standardTZName);
      expect(apptHitInviteTz.daylightTZName, daylightTZName);

      final apptHitInviteTzStandard = apptHitInviteTz.standardTzOnset!;
      expect(apptHitInviteTzStandard.month, month);
      expect(apptHitInviteTzStandard.hour, hour);
      expect(apptHitInviteTzStandard.minute, minute);
      expect(apptHitInviteTzStandard.second, second);
      expect(apptHitInviteTzStandard.dayOfMonth, dayOfMonth);
      expect(apptHitInviteTzStandard.week, week);
      expect(apptHitInviteTzStandard.dayOfWeek, dayOfWeek);

      final apptHitInviteTzDaylight = apptHitInviteTz.daylightTzOnset!;
      expect(apptHitInviteTzDaylight.month, month);
      expect(apptHitInviteTzDaylight.hour, hour);
      expect(apptHitInviteTzDaylight.minute, minute);
      expect(apptHitInviteTzDaylight.second, second);
      expect(apptHitInviteTzDaylight.dayOfMonth, dayOfMonth);
      expect(apptHitInviteTzDaylight.week, week);
      expect(apptHitInviteTzDaylight.dayOfWeek, dayOfWeek);

      final apptHitComp = apptHitInvite.inviteComponent!;
      expect(apptHitComp.method, method);
      expect(apptHitComp.componentNum, componentNum);
      expect(apptHitComp.rsvp, rsvp);
      expect(apptHitComp.priority, priority);
      expect(apptHitComp.name, name);
      expect(apptHitComp.location, location);
      expect(apptHitComp.percentComplete, percentComplete);
      expect(apptHitComp.completed, completed);
      expect(apptHitComp.noBlob, noBlob);
      expect(apptHitComp.freeBusyActual, FreeBusyStatus.free);
      expect(apptHitComp.freeBusy, FreeBusyStatus.free);
      expect(apptHitComp.transparency, Transparency.opaque);
      expect(apptHitComp.isOrganizer, isOrganizer);
      expect(apptHitComp.xUid, xUid);
      expect(apptHitComp.uid, uid);
      expect(apptHitComp.sequence, sequence);
      expect(apptHitComp.dateTime, dateTime);
      expect(apptHitComp.calItemId, calItemId);
      expect(apptHitComp.deprecatedApptId, deprecatedApptId);
      expect(apptHitComp.calItemFolder, calItemFolder);
      expect(apptHitComp.status, InviteStatus.completed);
      expect(apptHitComp.calClass, InviteClass.public);
      expect(apptHitComp.url, url);
      expect(apptHitComp.isException, isException);
      expect(apptHitComp.recurIdZ, recurIdZ);
      expect(apptHitComp.isAllDay, isAllDay);
      expect(apptHitComp.isDraft, isDraft);
      expect(apptHitComp.neverSent, neverSent);
      expect(apptHitComp.changes, changes);
      expect(apptHitComp.fragment, fragment);
      expect(apptHitComp.description, description);
      expect(apptHitComp.htmlDescription, htmlDescription);
      expect(apptHitComp.categories.first, category);
      expect(apptHitComp.comments.first, comment);
      expect(apptHitComp.contacts.first, contact);

      final apptHitCompGeo = apptHitComp.geo!;
      expect(apptHitCompGeo.latitude, latitude);
      expect(apptHitCompGeo.longitude, longitude);

      final apptHitCompAt = apptHitComp.attendees.first;
      expect(apptHitCompAt.address, address);
      expect(apptHitCompAt.url, url);
      expect(apptHitCompAt.displayName, displayName);
      expect(apptHitCompAt.sentBy, sentBy);
      expect(apptHitCompAt.dir, dir);
      expect(apptHitCompAt.language, language);
      expect(apptHitCompAt.cuType, cuType);
      expect(apptHitCompAt.role, role);
      expect(apptHitCompAt.partStat, partStat);
      expect(apptHitCompAt.rsvp, rsvp);
      expect(apptHitCompAt.member, member);
      expect(apptHitCompAt.delegatedTo, delegatedTo);
      expect(apptHitCompAt.delegatedFrom, delegatedFrom);
      expect(apptHitCompAt.xParams.first.name, name);
      expect(apptHitCompAt.xParams.first.value, value);

      final apptHitCompAlarm = apptHitComp.alarms.first;
      expect(apptHitCompAlarm.action, AlarmAction.display);
      expect(apptHitCompAlarm.description, description);
      expect(apptHitCompAlarm.summary, summary);
      expect(apptHitCompAlarm.attach!.uri, uri);
      expect(apptHitCompAlarm.attach!.contentType, contentType);
      expect(apptHitCompAlarm.attach!.binaryB64Data, binaryB64Data);

      final apptHitCompAlarmAt = apptHitCompAlarm.attendees.first;
      expect(apptHitCompAlarmAt.address, address);
      expect(apptHitCompAlarmAt.url, url);
      expect(apptHitCompAlarmAt.displayName, displayName);
      expect(apptHitCompAlarmAt.sentBy, sentBy);
      expect(apptHitCompAlarmAt.dir, dir);
      expect(apptHitCompAlarmAt.language, language);
      expect(apptHitCompAlarmAt.cuType, cuType);
      expect(apptHitCompAlarmAt.role, role);
      expect(apptHitCompAlarmAt.partStat, partStat);
      expect(apptHitCompAlarmAt.rsvp, rsvp);
      expect(apptHitCompAlarmAt.member, member);
      expect(apptHitCompAlarmAt.delegatedTo, delegatedTo);
      expect(apptHitCompAlarmAt.delegatedFrom, delegatedFrom);
      expect(apptHitCompAlarmAt.xParams.first.name, name);
      expect(apptHitCompAlarmAt.xParams.first.value, value);

      final apptHitCompAlarmXProp = apptHitCompAlarm.xProps.first;
      expect(apptHitCompAlarmXProp.name, name);
      expect(apptHitCompAlarmXProp.value, value);
      expect(apptHitCompAlarmXProp.xParams.first.name, name);
      expect(apptHitCompAlarmXProp.xParams.first.value, value);

      final apptHitCompXProp = apptHitComp.xProps.first;
      expect(apptHitCompXProp.name, name);
      expect(apptHitCompXProp.value, value);
      expect(apptHitCompXProp.xParams.first.name, name);
      expect(apptHitCompXProp.xParams.first.value, value);

      final apptHitCompOrganizer = apptHitComp.organizer!;
      expect(apptHitCompOrganizer.address, address);
      expect(apptHitCompOrganizer.url, url);
      expect(apptHitCompOrganizer.displayName, displayName);
      expect(apptHitCompOrganizer.sentBy, sentBy);
      expect(apptHitCompOrganizer.dir, dir);
      expect(apptHitCompOrganizer.language, language);
      expect(apptHitCompOrganizer.xParams.first.name, name);
      expect(apptHitCompOrganizer.xParams.first.value, value);

      final apptHitRecurrence = apptHitComp.recurrence!;
      expect(apptHitRecurrence.add.first, isA<AddRecurrenceInfo>());
      expect(apptHitRecurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final apptHitExcept = apptHitRecurrence.except.first;
      expect(apptHitExcept.recurrenceRangeType, recurrenceRangeType);
      expect(apptHitExcept.recurrenceId, recurrenceId);
      expect(apptHitExcept.timezone, timezone);
      expect(apptHitExcept.recurIdZ, recurIdZ);
      expect(apptHitExcept.add, isA<RecurrenceInfo>());
      expect(apptHitExcept.exclude, isA<RecurrenceInfo>());

      final apptHitCancel = apptHitRecurrence.cancel.first;
      expect(apptHitCancel.recurrenceRangeType, recurrenceRangeType);
      expect(apptHitCancel.recurrenceId, recurrenceId);
      expect(apptHitCancel.timezone, timezone);
      expect(apptHitCancel.recurIdZ, recurIdZ);

      final apptHitDates = apptHitRecurrence.dates.first;
      expect(apptHitDates.timezone, timezone);

      final apptHitStartTime = apptHitDates.dtVals.first.startTime!;
      expect(apptHitStartTime.dateTime, dateTimeString);
      expect(apptHitStartTime.timezone, timezone);
      expect(apptHitStartTime.utcTime, utcTime);

      final apptHitEndTime = apptHitDates.dtVals.first.endTime!;
      expect(apptHitEndTime.dateTime, dateTimeString);
      expect(apptHitEndTime.timezone, timezone);
      expect(apptHitEndTime.utcTime, utcTime);

      final apptHitDuration = apptHitDates.dtVals.first.duration!;
      expect(apptHitDuration.durationNegative, durationNegative);
      expect(apptHitDuration.weeks, weeks);
      expect(apptHitDuration.days, days);
      expect(apptHitDuration.hours, hours);
      expect(apptHitDuration.minutes, minutes);
      expect(apptHitDuration.seconds, seconds);
      expect(apptHitDuration.related, AlarmRelated.start);
      expect(apptHitDuration.repeatCount, repeatCount);

      final apptHitSimple = apptHitRecurrence.simple.first;
      expect(apptHitSimple.until!.dateTime, dateTimeString);
      expect(apptHitSimple.count!.num, num);
      expect(apptHitSimple.interval!.ival, ival);
      expect(apptHitSimple.bySecond!.list, list);
      expect(apptHitSimple.byMinute!.list, list);
      expect(apptHitSimple.byHour!.list, list);
      expect(apptHitSimple.byDay!.days.first.day, WeekDay.sunday);
      expect(apptHitSimple.byDay!.days.first.ordWk, ordWk);
      expect(apptHitSimple.byMonthDay!.list, list);
      expect(apptHitSimple.byYearDay!.list, list);
      expect(apptHitSimple.byWeekNo!.list, list);
      expect(apptHitSimple.byMonth!.list, list);
      expect(apptHitSimple.bySetPose!.list, list);
      expect(apptHitSimple.weekStart!.day, WeekDay.sunday);
      expect(apptHitSimple.xNames.first.name, name);
      expect(apptHitSimple.xNames.first.value, value);

      final apptHitExceptionId = apptHitComp.exceptionId!;
      expect(apptHitExceptionId.dateTime, dateTimeString);
      expect(apptHitExceptionId.timezone, timezone);
      expect(apptHitExceptionId.recurrenceRangeType, recurrenceRangeType);

      final apptHitDtStart = apptHitComp.dtStart!;
      expect(apptHitDtStart.dateTime, dateTimeString);
      expect(apptHitDtStart.timezone, timezone);
      expect(apptHitDtStart.utcTime, utcTime);

      final apptHitDtEnd = apptHitComp.dtEnd!;
      expect(apptHitDtEnd.dateTime, dateTimeString);
      expect(apptHitDtEnd.timezone, timezone);
      expect(apptHitDtEnd.utcTime, utcTime);

      final apptHitInviteDuration = apptHitComp.duration!;
      expect(apptHitInviteDuration.durationNegative, durationNegative);
      expect(apptHitInviteDuration.weeks, weeks);
      expect(apptHitInviteDuration.days, days);
      expect(apptHitInviteDuration.hours, hours);
      expect(apptHitInviteDuration.minutes, minutes);
      expect(apptHitInviteDuration.seconds, seconds);
      expect(apptHitInviteDuration.related, AlarmRelated.start);
      expect(apptHitInviteDuration.repeatCount, repeatCount);

      final apptHitInviteMp = apptHitInvite.partInfos.first;
      expect(apptHitInviteMp.part, part);
      expect(apptHitInviteMp.contentType, contentType);
      expect(apptHitInviteMp.size, size);
      expect(apptHitInviteMp.contentDisposition, contentDisposition);
      expect(apptHitInviteMp.contentFilename, contentFilename);
      expect(apptHitInviteMp.contentId, contentId);
      expect(apptHitInviteMp.location, location);
      expect(apptHitInviteMp.body, body);
      expect(apptHitInviteMp.truncatedContent, truncatedContent);
      expect(apptHitInviteMp.content, content);

      final apptHitInviteMpMimePart = apptHitInviteMp.mimeParts.first;
      expect(apptHitInviteMpMimePart.part, part);
      expect(apptHitInviteMpMimePart.contentType, contentType);
      expect(apptHitInviteMpMimePart.size, size);
      expect(apptHitInviteMpMimePart.contentDisposition, contentDisposition);
      expect(apptHitInviteMpMimePart.contentFilename, contentFilename);
      expect(apptHitInviteMpMimePart.contentId, contentId);
      expect(apptHitInviteMpMimePart.location, location);
      expect(apptHitInviteMpMimePart.body, body);
      expect(apptHitInviteMpMimePart.truncatedContent, truncatedContent);
      expect(apptHitInviteMpMimePart.content, content);

      final apptHitInviteShr = apptHitInvite.shareNotifications.first;
      expect(apptHitInviteShr.content, content);
      expect(apptHitInviteShr.truncatedContent, truncatedContent);

      final apptHitInviteDlSubs = apptHitInvite.dlSubsNotifications.first;
      expect(apptHitInviteDlSubs.content, content);
      expect(apptHitInviteDlSubs.truncatedContent, truncatedContent);

      final apptHitReply = apptHit.replies.first;
      expect(apptHitReply.recurrenceRangeType, recurrenceRangeType);
      expect(apptHitReply.recurrenceId, recurrenceId);
      expect(apptHitReply.sequence, sequence);
      expect(apptHitReply.date, date);
      expect(apptHitReply.attendee, attendee);
      expect(apptHitReply.sentBy, sentBy);
      expect(apptHitReply.partStat, partStat);
      expect(apptHitReply.timezone, timezone);
      expect(apptHitReply.recurIdZ, recurIdZ);

      final taskHit = response.taskHits.first;
      expect(taskHit, isA<CalendarItemHitInfo>());
      expect(taskHit.sortField, sortField);
      expect(taskHit.date, date);
      expect(taskHit.contentMatched, contentMatched);
      expect(taskHit.nextAlarm, nextAlarm);
      expect(taskHit.fragment, fragment);
      expect(taskHit.xUid, xUid);
      expect(taskHit.uid, uid);
      expect(taskHit.flags, flags);
      expect(taskHit.tags, tags);
      expect(taskHit.tagNames, tagNames);
      expect(taskHit.folderId, folderId);
      expect(taskHit.size, size);
      expect(taskHit.changeDate, changeDate);
      expect(taskHit.modifiedSequence, modifiedSequence);
      expect(taskHit.revision, revision);
      expect(taskHit.id, id);
      expect(taskHit.duration, duration);
      expect(taskHit.partStat, partStat);
      expect(taskHit.recurIdZ, recurIdZ);
      expect(taskHit.tzOffset, tzOffset);
      expect(taskHit.freeBusyActual, FreeBusyStatus.free);
      expect(taskHit.taskPercentComplete, taskPercentComplete);
      expect(taskHit.isRecurring, isRecurring);
      expect(taskHit.hasExceptions, hasExceptions);
      expect(taskHit.priority, priority);
      expect(taskHit.freeBusyIntended, FreeBusyStatus.free);
      expect(taskHit.transparency, Transparency.opaque);
      expect(taskHit.name, name);
      expect(taskHit.location, location);
      expect(taskHit.hasOtherAttendees, hasOtherAttendees);
      expect(taskHit.hasAlarm, hasAlarm);
      expect(taskHit.isOrganizer, isOrganizer);
      expect(taskHit.invId, invId.toString());
      expect(taskHit.componentNum, componentNum);
      expect(taskHit.status, InviteStatus.completed);
      expect(taskHit.calClass, InviteClass.public);
      expect(taskHit.allDay, allDay);
      expect(taskHit.draft, draft);
      expect(taskHit.neverSent, neverSent);
      expect(taskHit.taskDueDate, taskDueDate);
      expect(taskHit.taskTzOffsetDue, taskTzOffsetDue);

      final queryInfo = response.queryInfo!;
      expect(queryInfo.suggests.first.suggestedQueryString, suggestedQueryString);
      expect(queryInfo.wildcards.first.wildcardString, wildcardString);
      expect(queryInfo.wildcards.first.expanded, expanded);
      expect(queryInfo.wildcards.first.numExpanded, numExpanded);
    }));

    test('Send delivery report test', (() async {
      final data = {
        'Body': {
          'SendDeliveryReportResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.sendDeliveryReport(faker.guid.guid());
      expect(response, isNotNull);
      expect(response, isA<SendDeliveryReportResponse>());
    }));

    test('Send invite reply test', (() async {
      final id = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final calInvId = faker.guid.guid();
      final modifiedSequence = faker.randomGenerator.integer(100);
      final revision = faker.randomGenerator.integer(100);

      final uid = faker.guid.guid();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;

      final part = faker.lorem.word();
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.person.name();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final seq = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecond;
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final content = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentDisposition = faker.lorem.word();
      final contentFilename = faker.lorem.word();
      final contentId = faker.guid.guid();
      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();
      final size = faker.randomGenerator.integer(100);
      final num = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final url = faker.internet.httpsUrl();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final section = faker.lorem.word();

      final data = {
        'Body': {
          'SendInviteReplyResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'apptId': deprecatedApptId,
            'invId': calInvId,
            'ms': modifiedSequence,
            'rev': revision,
            'm': {
              'id': id,
            },
            'echo': {
              'm': {
                'id': id,
                'part': part,
                'sd': sentDate,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'mid': messageIdHeader,
                'inv': {
                  'type': InviteType.appt.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ],
                  },
                  'comp': [
                    {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    }
                  ],
                },
                '_attrs': {
                  key: value,
                },
                'mp': [
                  {
                    'part': part,
                    'ct': contentType,
                    's': size,
                    'cd': contentDisposition,
                    'filename': contentFilename,
                    'ci': contentId,
                    'cl': location,
                    'body': body,
                    'truncated': truncatedContent,
                    'content': content,
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'shr': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                'dlSubs': [
                  {
                    'truncated': truncatedContent,
                    'content': content,
                  }
                ],
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              },
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.sendInviteReply(id, componentNum);

      expect(response!.calItemId, calItemId);
      expect(response.deprecatedApptId, deprecatedApptId);
      expect(response.calInvId, calInvId);
      expect(response.modifiedSequence, modifiedSequence);
      expect(response.msg!.id, id);

      final echo = response.echo!;
      final invite = echo.invite!;

      expect(invite.id, id);
      expect(invite.part, part);
      expect(invite.sentDate, sentDate);
      expect(invite.subject, subject);
      expect(invite.messageIdHeader, messageIdHeader);
      expect(invite.size, size);
      expect(invite.date, date);
      expect(invite.folder, folder);
      expect(invite.conversationId, conversationId);
      expect(invite.flags, flags);
      expect(invite.tags, tags);
      expect(invite.tagNames, tagNames);
      expect(invite.revision, revision);
      expect(invite.changeDate, changeDate);
      expect(invite.modifiedSequence, modifiedSequence);

      final email = invite.emails.first;
      expect(email.address, address);
      expect(email.display, display);
      expect(email.personal, personal);
      expect(email.addressType, AddressType.from);
      expect(email.isGroup, isGroup);
      expect(email.canExpandGroupMembers, canExpandGroupMembers);

      final header = invite.headers.first;
      expect(header.key, key);
      expect(header.value, value);

      final mpContent = invite.mpContentElems.first;
      expect(mpContent.part, part);
      expect(mpContent.contentType, contentType);
      expect(mpContent.size, size);
      expect(mpContent.contentDisposition, contentDisposition);
      expect(mpContent.contentFilename, contentFilename);
      expect(mpContent.contentId, contentId);
      expect(mpContent.location, location);
      expect(mpContent.body, body);
      expect(mpContent.truncatedContent, truncatedContent);
      expect(mpContent.content, content);

      final mimePart = mpContent.mimeParts.first;
      expect(mimePart.part, part);
      expect(mimePart.contentType, contentType);
      expect(mimePart.size, size);
      expect(mimePart.contentDisposition, contentDisposition);
      expect(mimePart.contentFilename, contentFilename);
      expect(mimePart.contentId, contentId);
      expect(mimePart.location, location);
      expect(mimePart.body, body);
      expect(mimePart.truncatedContent, truncatedContent);
      expect(mimePart.content, content);

      final shr = invite.shrContentElems.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = invite.dlSubsContentElems.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final inv = invite.invite!;
      expect(inv.calItemType, InviteType.appt);

      final tz = inv.timezones.first;
      expect(tz.id, id);
      expect(tz.tzStdOffset, tzStdOffset);
      expect(tz.tzDayOffset, tzDayOffset);
      expect(tz.standardTZName, standardTZName);
      expect(tz.daylightTZName, daylightTZName);

      final standard = tz.standardTzOnset!;
      expect(standard.month, month);
      expect(standard.hour, hour);
      expect(standard.minute, minute);
      expect(standard.second, second);
      expect(standard.dayOfMonth, dayOfMonth);
      expect(standard.week, week);
      expect(standard.dayOfWeek, dayOfWeek);

      final daylight = tz.daylightTzOnset!;
      expect(daylight.month, month);
      expect(daylight.hour, hour);
      expect(daylight.minute, minute);
      expect(daylight.second, second);
      expect(daylight.dayOfMonth, dayOfMonth);
      expect(daylight.week, week);
      expect(daylight.dayOfWeek, dayOfWeek);

      final reply = inv.calendarReplies.first;
      expect(reply.recurrenceRangeType, recurrenceRangeType);
      expect(reply.recurrenceId, recurrenceId);
      expect(reply.seq, seq);
      expect(reply.date, date);
      expect(reply.attendee, attendee);
      expect(reply.sentBy, sentBy);
      expect(reply.partStat, partStat);
      expect(reply.timezone, timezone);
      expect(reply.recurIdZ, recurIdZ);

      final comp = inv.inviteComponents.first;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Send msg test', (() async {
      final id = faker.guid.guid();
      final imapUid = faker.randomGenerator.integer(100);
      final calendarIntendedFor = faker.lorem.word();
      final origId = faker.guid.guid();
      final identityId = faker.guid.guid();
      final draftAccountId = faker.guid.guid();
      final draftAutoSendTime = faker.randomGenerator.integer(100);
      final sentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final resentDate = faker.date.dateTime().millisecondsSinceEpoch;
      final part = faker.lorem.word();
      final fragment = faker.lorem.word();
      final subject = faker.lorem.word();
      final messageIdHeader = faker.guid.guid();
      final inReplyTo = faker.internet.email();
      final size = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final folder = faker.guid.guid();
      final conversationId = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final revision = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final modifiedSequence = faker.randomGenerator.integer(100);
      final calItemType = faker.randomGenerator.element(InviteType.values);
      final dateTimeString = faker.date.dateTime().toString();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.person.name();
      final addressType = faker.randomGenerator.element(AddressType.values);
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final name = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final summary = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final content = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentId = faker.guid.guid();
      final attachmentId = faker.guid.guid();
      final messageId = faker.guid.guid();
      final optional = faker.randomGenerator.boolean();
      final path = faker.lorem.word();
      final version = faker.randomGenerator.integer(100);
      final truncatedContent = faker.randomGenerator.boolean();
      final url = faker.internet.httpsUrl();
      final uri = faker.lorem.word();

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final recurrenceId = faker.guid.guid();
      final seq = faker.randomGenerator.integer(100);
      final attendee = faker.internet.email();
      final timezone = faker.lorem.word();
      final utcTime = faker.date.dateTime().millisecondsSinceEpoch;
      final recurIdZ = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final related = faker.randomGenerator.element(AlarmRelated.values);
      final repeatCount = faker.randomGenerator.integer(100);

      final displayName = faker.person.name();
      final sentBy = faker.internet.email();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final alarmAction = faker.randomGenerator.element(AlarmAction.values);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final num = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final componentNum = faker.randomGenerator.integer(100);
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final uid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final sequence = faker.randomGenerator.integer(100);
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final data = {
        'Body': {
          'SendMsgResponse': {
            '_jsns': 'urn:zimbraMail',
            'm': {
              'id': id,
              'i4uid': imapUid,
              'cif': calendarIntendedFor,
              'origid': origId,
              'rt': ReplyType.replied.name,
              'idnt': identityId,
              'forAcct': draftAccountId,
              'autoSendTime': draftAutoSendTime,
              'sd': sentDate,
              'rd': resentDate,
              'part': part,
              'fr': fragment,
              'e': [
                {
                  'a': address,
                  'd': display,
                  'p': personal,
                  't': addressType.name,
                  'isGroup': isGroup,
                  'exp': canExpandGroupMembers,
                }
              ],
              'su': subject,
              'mid': messageIdHeader,
              'irt': inReplyTo,
              'inv': {
                'type': calItemType.name,
                'tz': [
                  {
                    'id': id,
                    'stdoff': tzStdOffset,
                    'dayoff': tzDayOffset,
                    'standard': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'daylight': {
                      'mon': month,
                      'hour': hour,
                      'min': minute,
                      'sec': second,
                      'mday': dayOfMonth,
                      'week': week,
                      'wkday': dayOfWeek,
                    },
                    'stdname': standardTZName,
                    'dayname': daylightTZName,
                  }
                ],
                'comp': [
                  {
                    'category': [
                      {'_content': category}
                    ],
                    'comment': [
                      {'_content': comment}
                    ],
                    'contact': [
                      {'_content': contact}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'alarm': [
                      {
                        'action': alarmAction.name,
                        'trigger': {
                          'abs': {
                            'd': dateTimeString,
                          },
                          'rel': {
                            'd': dateTimeString,
                          },
                        },
                        'repeat': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': related.name,
                          'count': repeatCount,
                        },
                        'desc': {'_content': description},
                        'attach': {
                          'uri': uri,
                          'ct': contentType,
                          '_content': binaryB64Data,
                        },
                        'summary': {'_content': summary},
                        'at': [
                          {
                            'a': address,
                            'url': url,
                            'd': displayName,
                            'sentBy': sentBy,
                            'dir': dir,
                            'lang': language,
                            'cutype': cuType,
                            'role': role,
                            'ptst': partStat.name,
                            'rsvp': rsvp,
                            'member': member,
                            'delegatedTo': delegatedTo,
                            'delegatedFrom': delegatedFrom,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'xprop': [
                          {
                            'name': name,
                            'value': value,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'fr': fragment,
                    'desc': {'_content': description},
                    'descHtml': {'_content': htmlDescription},
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'recur': {
                      'add': [
                        {'add': {}}
                      ],
                      'exclude': [
                        {'exclude': {}}
                      ],
                      'except': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                          'add': {'add': []},
                          'exclude': {'exclude': []},
                        }
                      ],
                      'cancel': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ],
                      'dates': [
                        {
                          'tz': timezone,
                          'dtval': [
                            {
                              's': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'e': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'dur': {
                                'neg': durationNegative,
                                'w': weeks,
                                'd': days,
                                'h': hours,
                                'm': minutes,
                                's': seconds,
                                'related': AlarmRelated.start.name,
                                'count': repeatCount,
                              },
                            }
                          ],
                        }
                      ],
                      'rule': [
                        {
                          'freq': Frequency.second.name,
                          'until': {
                            'd': dateTimeString,
                          },
                          'count': {
                            'num': num,
                          },
                          'interval': {
                            'ival': ival,
                          },
                          'bysecond': {
                            'seclist': list,
                          },
                          'byminute': {
                            'minlist': list,
                          },
                          'byhour': {
                            'hrlist': list,
                          },
                          'byday': {
                            'wkday': [
                              {
                                'day': WeekDay.sunday.name,
                                'ordWk': ordWk,
                              }
                            ],
                          },
                          'bymonthday': {
                            'modaylist': list,
                          },
                          'byyearday': {
                            'yrdaylist': list,
                          },
                          'byweekno': {
                            'wklist': list,
                          },
                          'bymonth': {
                            'molist': list,
                          },
                          'bysetpos': {
                            'poslist': list,
                          },
                          'wkst': {
                            'day': WeekDay.sunday.name,
                          },
                          'rule-x-name': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    },
                    'exceptId': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'rangeType': recurrenceRangeType,
                    },
                    's': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'e': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'dur': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'method': method,
                    'compNum': componentNum,
                    'rsvp': rsvp,
                    'priority': priority,
                    'name': name,
                    'loc': location,
                    'percentComplete': percentComplete,
                    'completed': completed,
                    'noBlob': noBlob,
                    'fba': FreeBusyStatus.free.name,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'isOrg': isOrganizer,
                    'x_uid': xUid,
                    'uid': uid,
                    'seq': sequence,
                    'd': dateTime,
                    'calItemId': calItemId,
                    'apptId': deprecatedApptId,
                    'ciFolder': calItemFolder,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'url': url,
                    'ex': isException,
                    'ridZ': recurIdZ,
                    'allDay': isAllDay,
                    'draft': isDraft,
                    'neverSent': neverSent,
                    'changes': changes,
                  }
                ],
                'replies': {
                  'reply': [
                    {
                      'rangeType': recurrenceRangeType,
                      'recurId': recurrenceId,
                      'seq': seq,
                      'd': date,
                      'at': attendee,
                      'sentBy': sentBy,
                      'ptst': partStat.name,
                      'tz': timezone,
                      'ridZ': recurIdZ,
                    }
                  ]
                },
              },
              '_attrs': {
                key: value,
              },
              'mp': {
                'ct': contentType,
                'content': content,
                'ci': contentId,
                'attach': {
                  'aid': attachmentId,
                  'mp': [
                    {
                      'mid': messageId,
                      'part': part,
                      'optional': optional,
                    }
                  ],
                  'm': [
                    {
                      'id': id,
                      'optional': optional,
                    }
                  ],
                  'cn': [
                    {
                      'id': id,
                      'optional': optional,
                    }
                  ],
                  'doc': [
                    {
                      'path': path,
                      'id': id,
                      'ver': version,
                      'optional': optional,
                    }
                  ],
                },
                'mp': [
                  {
                    'ct': contentType,
                    'content': content,
                    'ci': contentId,
                  }
                ],
              },
              'shr': {
                'truncated': truncatedContent,
                'content': content,
              },
              'dlSubs': {
                'truncated': truncatedContent,
                'content': content,
              },
              'content': {
                'url': url,
                '_content': value,
              },
              's': size,
              'd': date,
              'l': folder,
              'cid': conversationId,
              'f': flags,
              't': tags,
              'tn': tagNames,
              'rev': revision,
              'md': changeDate,
              'ms': modifiedSequence,
              'meta': [
                {
                  'section': section,
                  '_attrs': {
                    key: value,
                  },
                }
              ],
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.sendMsg(MsgToSend());
      final msg = response!.msg!;

      expect(msg.id, id);
      expect(msg.imapUid, imapUid);
      expect(msg.calendarIntendedFor, calendarIntendedFor);
      expect(msg.origId, origId);
      expect(msg.draftReplyType, ReplyType.replied);
      expect(msg.identityId, identityId);
      expect(msg.draftAccountId, draftAccountId);
      expect(msg.draftAutoSendTime, draftAutoSendTime);
      expect(msg.sentDate, sentDate);
      expect(msg.resentDate, resentDate);
      expect(msg.part, part);
      expect(msg.fragment, fragment);
      expect(msg.subject, subject);
      expect(msg.messageIdHeader, messageIdHeader);
      expect(msg.inReplyTo, inReplyTo);
      expect(msg.size, size);
      expect(msg.date, date);
      expect(msg.folder, folder);
      expect(msg.conversationId, conversationId);
      expect(msg.flags, flags);
      expect(msg.tags, tags);
      expect(msg.tagNames, tagNames);
      expect(msg.revision, revision);
      expect(msg.changeDate, changeDate);
      expect(msg.modifiedSequence, modifiedSequence);

      final msgEmail = msg.emails.first;
      expect(msgEmail.address, address);
      expect(msgEmail.display, display);
      expect(msgEmail.personal, personal);
      expect(msgEmail.addressType, addressType);
      expect(msgEmail.isGroup, isGroup);
      expect(msgEmail.canExpandGroupMembers, canExpandGroupMembers);

      final msgHeader = msg.headers.first;
      expect(msgHeader.key, key);
      expect(msgHeader.value, value);

      final msgMimePart = msg.mimePart!;
      expect(msgMimePart.contentType, contentType);
      expect(msgMimePart.content, content);
      expect(msgMimePart.contentId, contentId);

      final msgAttach = msgMimePart.attachments!;
      expect(msgAttach.attachmentId, attachmentId);

      final mpAttach = msgAttach.mpAttachments.first;
      expect(mpAttach.messageId, messageId);
      expect(mpAttach.part, part);
      expect(mpAttach.optional, optional);

      final mAttach = msgAttach.msgAttachments.first;
      expect(mAttach.id, id);
      expect(mAttach.optional, optional);

      final cnAttach = msgAttach.cnAttachments.first;
      expect(cnAttach.id, id);
      expect(cnAttach.optional, optional);

      final doc = msgAttach.docAttachments.first;
      expect(doc.path, path);
      expect(doc.id, id);
      expect(doc.version, version);
      expect(doc.optional, optional);

      final msgShr = msg.shrNotification!;
      expect(msgShr.truncatedContent, truncatedContent);
      expect(msgShr.content, content);

      final msgDlSubs = msg.dlSubsNotification!;
      expect(msgDlSubs.truncatedContent, truncatedContent);
      expect(msgDlSubs.content, content);

      final msgContent = msg.content!;
      expect(msgContent.url, url);
      expect(msgContent.value, value);

      final msgMeta = msg.metadatas.first;
      expect(msgMeta.section, section);
      expect(msgMeta.keyValuePairs.first.key, key);
      expect(msgMeta.keyValuePairs.first.value, value);

      final invite = msg.invite!;
      expect(invite.calItemType, calItemType);

      final inviteTz = invite.timezones.first;
      expect(inviteTz.id, id);
      expect(inviteTz.tzStdOffset, tzStdOffset);
      expect(inviteTz.tzDayOffset, tzDayOffset);
      expect(inviteTz.standardTZName, standardTZName);
      expect(inviteTz.daylightTZName, daylightTZName);

      final inviteTzStandard = inviteTz.standardTzOnset!;
      expect(inviteTzStandard.month, month);
      expect(inviteTzStandard.hour, hour);
      expect(inviteTzStandard.minute, minute);
      expect(inviteTzStandard.second, second);
      expect(inviteTzStandard.dayOfMonth, dayOfMonth);
      expect(inviteTzStandard.week, week);
      expect(inviteTzStandard.dayOfWeek, dayOfWeek);

      final inviteTzDaylight = inviteTz.daylightTzOnset!;
      expect(inviteTzDaylight.month, month);
      expect(inviteTzDaylight.hour, hour);
      expect(inviteTzDaylight.minute, minute);
      expect(inviteTzDaylight.second, second);
      expect(inviteTzDaylight.dayOfMonth, dayOfMonth);
      expect(inviteTzDaylight.week, week);
      expect(inviteTzDaylight.dayOfWeek, dayOfWeek);

      final inviteComp = invite.inviteComponents.first;
      expect(inviteComp.categories.first, category);
      expect(inviteComp.comments.first, comment);
      expect(inviteComp.contacts.first, contact);
      expect(inviteComp.fragment, fragment);
      expect(inviteComp.description, description);
      expect(inviteComp.htmlDescription, htmlDescription);
      expect(inviteComp.method, method);
      expect(inviteComp.componentNum, componentNum);
      expect(inviteComp.rsvp, rsvp);
      expect(inviteComp.priority, priority);
      expect(inviteComp.name, name);
      expect(inviteComp.location, location);
      expect(inviteComp.percentComplete, percentComplete);
      expect(inviteComp.completed, completed);
      expect(inviteComp.noBlob, noBlob);
      expect(inviteComp.freeBusyActual, FreeBusyStatus.free);
      expect(inviteComp.freeBusy, FreeBusyStatus.free);
      expect(inviteComp.transparency, Transparency.opaque);
      expect(inviteComp.isOrganizer, isOrganizer);
      expect(inviteComp.xUid, xUid);
      expect(inviteComp.uid, uid);
      expect(inviteComp.sequence, sequence);
      expect(inviteComp.dateTime, dateTime);
      expect(inviteComp.calItemId, calItemId);
      expect(inviteComp.deprecatedApptId, deprecatedApptId);
      expect(inviteComp.calItemFolder, calItemFolder);
      expect(inviteComp.status, InviteStatus.completed);
      expect(inviteComp.calClass, InviteClass.public);
      expect(inviteComp.url, url);
      expect(inviteComp.isException, isException);
      expect(inviteComp.recurIdZ, recurIdZ);
      expect(inviteComp.isAllDay, isAllDay);
      expect(inviteComp.isDraft, isDraft);
      expect(inviteComp.neverSent, neverSent);
      expect(inviteComp.changes, changes);

      final compGeo = inviteComp.geo!;
      expect(compGeo.latitude, latitude);
      expect(compGeo.longitude, longitude);

      final compAt = inviteComp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = inviteComp.alarms.first;
      expect(alarm.action, alarmAction);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = inviteComp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = inviteComp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = inviteComp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = inviteComp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = inviteComp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = inviteComp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = inviteComp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);
    }));

    test('Send share notification test', (() async {
      final data = {
        'Body': {
          'SendShareNotificationResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.sendShareNotification(Id());
      expect(response, isNotNull);
      expect(response, isA<SendShareNotificationResponse>());
    }));

    test('Send verification code test', (() async {
      final data = {
        'Body': {
          'SendVerificationCodeResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.sendVerificationCode(faker.internet.email());
      expect(response, isNotNull);
      expect(response, isA<SendVerificationCodeResponse>());
    }));

    test('Set appointment test', (() async {
      final id = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final recurrenceId = faker.guid.guid();

      final data = {
        'Body': {
          'SetAppointmentResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'apptId': deprecatedApptId,
            'default': {'id': id},
            'except': [
              {
                'recurId': recurrenceId,
                'id': id,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.setAppointment();

      expect(response!.calItemId, calItemId);
      expect(response.deprecatedApptId, deprecatedApptId);

      final defaultId = response.defaultId!;
      expect(defaultId.id, id);

      final except = response.exceptions.first;
      expect(except.recurrenceId, recurrenceId);
      expect(except.id, id);
    }));

    test('Set custom metadata test', (() async {
      final id = faker.guid.guid();
      final data = {
        'Body': {
          'SetCustomMetadataResponse': {
            '_jsns': 'urn:zimbraMail',
            'id': id,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.setCustomMetadata(MailCustomMetadata());
      expect(response!.id, id);
    }));

    test('Set mailbox metadata test', (() async {
      final data = {
        'Body': {
          'SetMailboxMetadataResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.setMailboxMetadata(MailCustomMetadata());
      expect(response, isNotNull);
      expect(response, isA<SetMailboxMetadataResponse>());
    }));

    test('Set recover account test', (() async {
      final data = {
        'Body': {
          'SetRecoveryAccountResponse': {
            '_jsns': 'urn:zimbraMail',
          }
        }
      };
      final api = mockApi(data);
      final response = await api.setRecoveryAccount(
        RecoveryAccountOperation.sendCode,
        faker.internet.email(),
        faker.lorem.word(),
      );
      expect(response, isNotNull);
      expect(response, isA<SetRecoveryAccountResponse>());
    }));

    test('Set task test', (() async {
      final id = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final recurrenceId = faker.guid.guid();

      final data = {
        'Body': {
          'SetTaskResponse': {
            '_jsns': 'urn:zimbraMail',
            'calItemId': calItemId,
            'apptId': deprecatedApptId,
            'default': {'id': id},
            'except': [
              {
                'recurId': recurrenceId,
                'id': id,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.setTask();

      expect(response!.calItemId, calItemId);
      expect(response.deprecatedApptId, deprecatedApptId);

      final defaultId = response.defaultId!;
      expect(defaultId.id, id);

      final except = response.exceptions.first;
      expect(except.recurrenceId, recurrenceId);
      expect(except.id, id);
    }));

    test('Snooze calendar item alarm test', (() async {
      final calItemId = faker.guid.guid();
      final nextAlarm = faker.randomGenerator.integer(100);
      final alarmInstanceStart = faker.randomGenerator.integer(100);
      final invId = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);
      final name = faker.lorem.word();
      final value = faker.lorem.word();
      final location = faker.lorem.word();

      final address = faker.internet.email();
      final url = faker.internet.httpsUrl();
      final displayName = faker.person.name();
      final sentBy = faker.internet.email();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final dateString = faker.date.dateTime().toString();
      final description = faker.lorem.word();
      final summary = faker.lorem.word();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final uri = faker.internet.uri('http');
      final contentType = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final data = {
        'Body': {
          'SnoozeCalendarItemAlarmResponse': {
            '_jsns': 'urn:zimbraMail',
            'appt': [
              {
                'calItemId': calItemId,
                'alarmData': {
                  'nextAlarm': nextAlarm,
                  'alarmInstStart': alarmInstanceStart,
                  'invId': invId,
                  'compNum': componentNum,
                  'name': name,
                  'loc': location,
                  'alarm': {
                    'action': AlarmAction.display.name,
                    'trigger': {
                      'abs': {
                        'd': dateString,
                      },
                      'rel': {
                        'd': dateString,
                      },
                    },
                    'repeat': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'desc': {'_content': description},
                    'attach': {
                      'uri': uri,
                      'ct': contentType,
                      '_content': binaryB64Data,
                    },
                    'summary': {'_content': summary},
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': ParticipationStatus.accept.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                  },
                },
              }
            ],
            'task': [
              {
                'calItemId': calItemId,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.snoozeCalendarItemAlarm();

      final appt = response!.apptUpdatedAlarms.first;
      expect(appt.calItemId, calItemId);

      final alarmData = appt.alarmData!;
      expect(alarmData.nextAlarm, nextAlarm);
      expect(alarmData.alarmInstanceStart, alarmInstanceStart);
      expect(alarmData.invId, invId);
      expect(alarmData.componentNum, componentNum);
      expect(alarmData.name, name);
      expect(alarmData.location, location);

      final alarm = alarmData.alarm!;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);

      final trigger = alarm.trigger!;
      final absolute = trigger.absolute!;
      final relative = trigger.relative!;
      expect(absolute.date, dateString);
      expect(relative.date, dateString);

      final repeat = alarm.repeat!;
      expect(repeat.durationNegative, durationNegative);
      expect(repeat.weeks, weeks);
      expect(repeat.days, days);
      expect(repeat.hours, hours);
      expect(repeat.minutes, minutes);
      expect(repeat.seconds, seconds);
      expect(repeat.related, AlarmRelated.start);
      expect(repeat.repeatCount, repeatCount);

      final attach = alarm.attach!;
      expect(attach.uri, uri);
      expect(attach.contentType, contentType);
      expect(attach.binaryB64Data, binaryB64Data);

      final attendee = alarm.attendees.first;
      expect(attendee.address, address);
      expect(attendee.url, url);
      expect(attendee.displayName, displayName);
      expect(attendee.sentBy, sentBy);
      expect(attendee.dir, dir);
      expect(attendee.language, language);
      expect(attendee.cuType, cuType);
      expect(attendee.role, role);
      expect(attendee.partStat, ParticipationStatus.accept);
      expect(attendee.rsvp, rsvp);
      expect(attendee.member, member);
      expect(attendee.delegatedTo, delegatedTo);
      expect(attendee.delegatedFrom, delegatedFrom);
      expect(attendee.xParams.first.name, name);
      expect(attendee.xParams.first.value, value);

      final xprop = alarm.xProps.first;
      expect(xprop.name, name);
      expect(xprop.value, value);
      expect(xprop.xParams.first.name, name);
      expect(xprop.xParams.first.value, value);

      final task = response.taskUpdatedAlarms.first;
      expect(task.calItemId, calItemId);
      expect(task, isA<UpdatedAlarmInfo>());
    }));

    test('Sync test', (() async {
      final token = faker.guid.guid();
      final size = faker.randomGenerator.integer(100);
      final more = faker.randomGenerator.boolean();

      final id = faker.guid.guid();
      final uuid = faker.guid.guid();
      final name = faker.lorem.word();
      final ids = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');

      final absoluteFolderPath = faker.lorem.word();
      final parentId = faker.guid.guid();
      final folderId = faker.guid.guid();
      final folderUuid = faker.guid.guid();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final tagNames = faker.lorem.word();
      final bounds = faker.lorem.word();
      final content = faker.lorem.word();
      final color = faker.randomGenerator.integer(127);
      final rgb = faker.randomGenerator.fromPatternToHex(['######']);
      final unreadCount = faker.randomGenerator.integer(100);
      final imapUnreadCount = faker.randomGenerator.integer(100);
      final unread = faker.randomGenerator.integer(100);
      final count = faker.randomGenerator.integer(100);
      final date = faker.date.dateTime().millisecondsSinceEpoch;
      final revision = faker.randomGenerator.integer(100);
      final folder = faker.guid.guid();
      final modifiedSequence = faker.randomGenerator.integer(100);
      final changeDate = faker.date.dateTime().millisecondsSinceEpoch;
      final itemCount = faker.randomGenerator.integer(100);
      final imapItemCount = faker.randomGenerator.integer(100);
      final totalSize = faker.randomGenerator.integer(100);
      final imapModifiedSequence = faker.randomGenerator.integer(100);
      final imapUidNext = faker.randomGenerator.integer(100);
      final url = faker.internet.httpsUrl();
      final activeSyncDisabled = faker.randomGenerator.boolean();
      final webOfflineSyncDays = faker.randomGenerator.integer(100);
      final perm = faker.lorem.word();
      final recursive = faker.randomGenerator.boolean();
      final restUrl = faker.internet.httpsUrl();
      final deletable = faker.randomGenerator.boolean();

      final section = faker.lorem.word();
      final key = faker.lorem.word();
      final value = faker.lorem.word();
      final lifetime = faker.randomGenerator.integer(100).toString();

      final internalGrantExpiry = faker.randomGenerator.integer(100);
      final guestGrantExpiry = faker.randomGenerator.integer(100);

      final granteeId = faker.guid.guid();
      final expiry = faker.randomGenerator.integer(100);
      final granteeName = faker.person.name();
      final guestPassword = faker.internet.password();
      final accessKey = faker.internet.password();

      final ownerEmail = faker.internet.email();
      final ownerAccountId = faker.guid.guid();
      final remoteFolderId = faker.randomGenerator.integer(100);
      final remoteUuid = faker.guid.guid();
      final remoteFolderName = faker.lorem.word();
      final reminderEnabled = faker.randomGenerator.boolean();
      final broken = faker.randomGenerator.boolean();

      final query = faker.lorem.word();
      final types = faker.lorem.words(3).join(',');

      final sortField = faker.lorem.word();
      final canExpand = faker.randomGenerator.boolean();
      final imapUid = faker.randomGenerator.integer(100);
      final modifiedSequenceId = faker.randomGenerator.integer(100);
      final revisionId = faker.randomGenerator.integer(100);
      final fileAs = faker.lorem.word();
      final email = faker.internet.email();
      final email2 = faker.internet.email();
      final email3 = faker.internet.email();
      final type = faker.lorem.word();
      final dlist = faker.lorem.word();
      final reference = faker.lorem.word();
      final tooManyMembers = faker.randomGenerator.boolean();
      final memberOf = faker.internet.email();

      final part = faker.lorem.word();
      final contentType = faker.lorem.word();
      final contentFilename = faker.lorem.word();

      final uid = faker.guid.guid();
      final version = faker.randomGenerator.integer(100);
      final metadataVersion = faker.randomGenerator.integer(100);

      final nextAlarm = faker.date.dateTime().millisecondsSinceEpoch;
      final orphan = faker.randomGenerator.boolean();

      final sequence = faker.randomGenerator.integer(100);
      final componentNum = faker.randomGenerator.integer(100);
      final recurrenceId = faker.date.dateTime().toString();
      final seq = faker.randomGenerator.integer(100);

      final tzStdOffset = faker.randomGenerator.integer(100);
      final tzDayOffset = faker.randomGenerator.integer(100);
      final standardTZName = faker.lorem.word();
      final daylightTZName = faker.lorem.word();

      final recurrenceRangeType = faker.randomGenerator.integer(3, min: 1);
      final attendee = faker.internet.email();
      final sentBy = faker.internet.email();
      final timezone = faker.lorem.word();
      final recurIdZ = faker.date.dateTime().toString();

      final month = faker.date.dateTime().month;
      final hour = faker.date.dateTime().hour;
      final minute = faker.date.dateTime().minute;
      final second = faker.date.dateTime().second;
      final dayOfMonth = faker.randomGenerator.integer(31, min: 1);
      final week = faker.randomGenerator.integer(4, min: 1);
      final dayOfWeek = faker.randomGenerator.integer(7, min: 1);

      final category = faker.lorem.word();
      final comment = faker.lorem.word();
      final contact = faker.lorem.word();
      final latitude = faker.randomGenerator.decimal().toString();
      final longitude = faker.randomGenerator.decimal().toString();

      final address = faker.internet.email();
      final display = faker.person.name();
      final personal = faker.lorem.word();
      final displayName = faker.person.name();
      final dir = faker.lorem.word();
      final language = faker.address.countryCode();
      final cuType = faker.lorem.word();
      final role = faker.lorem.word();
      final member = faker.internet.email();
      final delegatedTo = faker.internet.email();
      final delegatedFrom = faker.internet.email();
      final utcTime = faker.date.dateTime().millisecond;
      final dateTimeString = faker.date.dateTime().toString();

      final durationNegative = faker.randomGenerator.boolean();
      final weeks = faker.randomGenerator.integer(100);
      final days = faker.randomGenerator.integer(100);
      final hours = faker.randomGenerator.integer(100);
      final minutes = faker.randomGenerator.integer(100);
      final seconds = faker.randomGenerator.integer(100);
      final repeatCount = faker.randomGenerator.integer(100);

      final summary = faker.guid.guid();
      final fragment = faker.lorem.word();
      final subject = faker.lorem.word();
      final description = faker.lorem.word();
      final htmlDescription = faker.lorem.word();
      final binaryB64Data = faker.lorem.word();

      final num = faker.randomGenerator.integer(100);
      final numUnread = faker.randomGenerator.integer(100);
      final ival = faker.randomGenerator.integer(100);
      final list = faker.randomGenerator.amount((_) => random.integer(10), 10).join(',');
      final ordWk = faker.randomGenerator.integer(100);

      final partStat = faker.randomGenerator.element(ParticipationStatus.values);
      final method = faker.lorem.word();
      final rsvp = faker.randomGenerator.boolean();
      final priority = faker.randomGenerator.integer(9).toString();
      final location = faker.address.streetAddress();
      final percentComplete = faker.randomGenerator.integer(100).toString();
      final completed = faker.date.dateTime().toString();
      final noBlob = faker.randomGenerator.boolean();
      final isOrganizer = faker.randomGenerator.boolean();
      final xUid = faker.guid.guid();
      final calItemId = faker.guid.guid();
      final deprecatedApptId = faker.guid.guid();
      final dateTime = faker.randomGenerator.integer(100);
      final calItemFolder = faker.lorem.word();
      final uri = faker.internet.uri('http');
      final isException = faker.randomGenerator.boolean();
      final isAllDay = faker.randomGenerator.boolean();
      final isDraft = faker.randomGenerator.boolean();
      final neverSent = faker.randomGenerator.boolean();
      final changes = faker.lorem.words(3).join(',');

      final contentDisposition = faker.lorem.word();
      final contentId = faker.guid.guid();
      final body = faker.randomGenerator.boolean();
      final truncatedContent = faker.randomGenerator.boolean();
      final elided = faker.randomGenerator.boolean();
      final isGroup = faker.randomGenerator.boolean();
      final canExpandGroupMembers = faker.randomGenerator.boolean();
      final descEnabled = faker.randomGenerator.boolean();

      final lastEditedBy = faker.lorem.word();
      final creator = faker.lorem.word();
      final createdDate = faker.date.dateTime().millisecondsSinceEpoch;
      final lockOwnerId = faker.guid.guid();
      final lockOwnerEmail = faker.internet.email();
      final lockOwnerTimestamp = faker.date.dateTime().toString();
      final autoSendTime = faker.randomGenerator.integer(100);
      final conversationId = faker.guid.guid();

      final data = {
        'Body': {
          'SyncResponse': {
            '_jsns': 'urn:zimbraMail',
            'md': changeDate,
            'token': token,
            's': size,
            'more': more,
            'deleted': {
              'ids': ids,
              'folder': [
                {
                  'ids': ids,
                }
              ],
              'search': [
                {
                  'ids': ids,
                }
              ],
              'link': [
                {
                  'ids': ids,
                }
              ],
              'tag': [
                {
                  'ids': ids,
                }
              ],
              'c': [
                {
                  'ids': ids,
                }
              ],
              'chat': [
                {
                  'ids': ids,
                }
              ],
              'm': [
                {
                  'ids': ids,
                }
              ],
              'cn': [
                {
                  'ids': ids,
                }
              ],
              'appt': [
                {
                  'ids': ids,
                }
              ],
              'task': [
                {
                  'ids': ids,
                }
              ],
              'notes': [
                {
                  'ids': ids,
                }
              ],
              'w': [
                {
                  'ids': ids,
                }
              ],
              'doc': [
                {
                  'ids': ids,
                }
              ],
            },
            'folder': [
              {
                'tag': [
                  {
                    'ids': ids,
                  }
                ],
                'c': [
                  {
                    'ids': ids,
                  }
                ],
                'chat': [
                  {
                    'ids': ids,
                  }
                ],
                'm': [
                  {
                    'ids': ids,
                  }
                ],
                'cn': [
                  {
                    'ids': ids,
                  }
                ],
                'appt': [
                  {
                    'ids': ids,
                  }
                ],
                'task': [
                  {
                    'ids': ids,
                  }
                ],
                'notes': [
                  {
                    'ids': ids,
                  }
                ],
                'w': [
                  {
                    'ids': ids,
                  }
                ],
                'doc': [
                  {
                    'ids': ids,
                  }
                ],
                'id': id,
                'uuid': uuid,
                'name': name,
                'absFolderPath': absoluteFolderPath,
                'l': parentId,
                'luuid': folderUuid,
                'f': flags,
                'color': color,
                'rgb': rgb,
                'u': unreadCount,
                'i4u': imapUnreadCount,
                'view': ViewType.conversation.name,
                'rev': revision,
                'ms': modifiedSequence,
                'md': changeDate,
                'n': itemCount,
                'i4n': imapItemCount,
                's': totalSize,
                'i4ms': imapModifiedSequence,
                'i4next': imapUidNext,
                'url': url,
                'activesyncdisabled': activeSyncDisabled,
                'webOfflineSyncDays': webOfflineSyncDays,
                'perm': perm,
                'recursive': recursive,
                'rest': restUrl,
                'deletable': deletable,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'acl': {
                  'internalGrantExpiry': internalGrantExpiry,
                  'guestGrantExpiry': guestGrantExpiry,
                  'grant': [
                    {
                      'perm': perm,
                      'gt': GrantGranteeType.all.name,
                      'zid': granteeId,
                      'expiry': expiry,
                      'd': granteeName,
                      'pw': guestPassword,
                      'key': accessKey,
                    }
                  ],
                },
                'folder': [
                  {
                    'id': id,
                    'uuid': uuid,
                    'name': name,
                  }
                ],
                'link': [
                  {
                    'id': id,
                    'name': name,
                    'owner': ownerEmail,
                    'zid': ownerAccountId,
                    'rid': remoteFolderId,
                    'ruuid': remoteUuid,
                    'oname': remoteFolderName,
                    'reminder': reminderEnabled,
                    'broken': broken,
                  }
                ],
                'search': [
                  {
                    'id': id,
                    'name': name,
                    'query': query,
                    'sortBy': SearchSortBy.none.name,
                    'types': types,
                  }
                ],
                'retentionPolicy': [
                  {
                    'keep': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                    'purge': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                  }
                ],
              }
            ],
            'tag': [
              {
                'id': id,
                'name': name,
                'color': color,
                'rgb': rgb,
                'u': unread,
                'n': count,
                'd': date,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'retentionPolicy': [
                  {
                    'keep': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                    'purge': [
                      {
                        'policy': [
                          {
                            'type': PolicyType.user.name,
                            'id': id,
                            'name': name,
                            'lifetime': lifetime,
                          }
                        ],
                      }
                    ],
                  }
                ],
              },
            ],
            'note': [
              {
                'id': id,
                'rev': revision,
                'l': folder,
                'd': date,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'pos': bounds,
                'color': color,
                'rgb': rgb,
                'md': changeDate,
                'ms': modifiedSequence,
                'content': content,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              },
            ],
            'cn': [
              {
                'sf': sortField,
                'exp': canExpand,
                'id': id,
                'i4uid': imapUid,
                'l': folder,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'md': changeDate,
                'ms': modifiedSequenceId,
                'd': date,
                'rev': revisionId,
                'fileAsStr': fileAs,
                'email': email,
                'email2': email2,
                'email3': email3,
                'type': type,
                'dlist': dlist,
                'ref': reference,
                'tooManyMembers': tooManyMembers,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                '_attrs': {
                  key: value,
                },
                'm': [
                  {
                    'type': MemberType.contact.name,
                    '_content': value,
                    'cn': {
                      'sf': sortField,
                      'exp': canExpand,
                      'id': id,
                      'i4uid': imapUid,
                      'l': folder,
                      'f': flags,
                      't': tags,
                      'tn': tagNames,
                      'md': changeDate,
                      'ms': modifiedSequenceId,
                      'd': date,
                      'rev': revisionId,
                      'fileAsStr': fileAs,
                      'email': email,
                      'email2': email2,
                      'email3': email3,
                      'type': type,
                      'dlist': dlist,
                      'ref': reference,
                      'tooManyMembers': tooManyMembers,
                      'memberOf': {'_content': memberOf},
                    },
                  }
                ],
                'memberOf': {'_content': memberOf},
              }
            ],
            'appt': [
              {
                'f': flags,
                't': tags,
                'tn': tagNames,
                'uid': uid,
                'id': id,
                'rev': revision,
                's': size,
                'd': date,
                'l': folder,
                'md': changeDate,
                'ms': modifiedSequence,
                'nextAlarm': nextAlarm,
                'orphan': orphan,
                'inv': [
                  {
                    'type': InviteType.appt.name,
                    'seq': sequence,
                    'id': id,
                    'compNum': componentNum,
                    'recurId': recurrenceId,
                    'tz': [
                      {
                        'id': id,
                        'stdoff': tzStdOffset,
                        'dayoff': tzDayOffset,
                        'standard': {
                          'mon': month,
                          'hour': hour,
                          'min': minute,
                          'sec': second,
                          'mday': dayOfMonth,
                          'week': week,
                          'wkday': dayOfWeek,
                        },
                        'daylight': {
                          'mon': month,
                          'hour': hour,
                          'min': minute,
                          'sec': second,
                          'mday': dayOfMonth,
                          'week': week,
                          'wkday': dayOfWeek,
                        },
                        'stdname': standardTZName,
                        'dayname': daylightTZName,
                      }
                    ],
                    'comp': {
                      'category': [
                        {'_content': category}
                      ],
                      'comment': [
                        {'_content': comment}
                      ],
                      'contact': [
                        {'_content': contact}
                      ],
                      'geo': {
                        'lat': latitude,
                        'lon': longitude,
                      },
                      'at': [
                        {
                          'a': address,
                          'url': url,
                          'd': displayName,
                          'sentBy': sentBy,
                          'dir': dir,
                          'lang': language,
                          'cutype': cuType,
                          'role': role,
                          'ptst': partStat.name,
                          'rsvp': rsvp,
                          'member': member,
                          'delegatedTo': delegatedTo,
                          'delegatedFrom': delegatedFrom,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'alarm': [
                        {
                          'action': AlarmAction.display.name,
                          'trigger': {
                            'abs': {
                              'd': dateTimeString,
                            },
                            'rel': {
                              'd': dateTimeString,
                            },
                          },
                          'repeat': {
                            'neg': durationNegative,
                            'w': weeks,
                            'd': days,
                            'h': hours,
                            'm': minutes,
                            's': seconds,
                            'related': AlarmRelated.start.name,
                            'count': repeatCount,
                          },
                          'desc': {'_content': description},
                          'attach': {
                            'uri': uri,
                            'ct': contentType,
                            '_content': binaryB64Data,
                          },
                          'summary': {'_content': summary},
                          'at': [
                            {
                              'a': address,
                              'url': url,
                              'd': displayName,
                              'sentBy': sentBy,
                              'dir': dir,
                              'lang': language,
                              'cutype': cuType,
                              'role': role,
                              'ptst': partStat.name,
                              'rsvp': rsvp,
                              'member': member,
                              'delegatedTo': delegatedTo,
                              'delegatedFrom': delegatedFrom,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                          'xprop': [
                            {
                              'name': name,
                              'value': value,
                              'xparam': [
                                {
                                  'name': name,
                                  'value': value,
                                }
                              ],
                            }
                          ],
                        }
                      ],
                      'xprop': [
                        {
                          'name': name,
                          'value': value,
                          'xparam': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                      'fr': fragment,
                      'desc': {'_content': description},
                      'descHtml': {'_content': htmlDescription},
                      'or': {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      },
                      'recur': {
                        'add': [
                          {'add': {}}
                        ],
                        'exclude': [
                          {'exclude': {}}
                        ],
                        'except': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                            'add': {'add': []},
                            'exclude': {'exclude': []},
                          }
                        ],
                        'cancel': [
                          {
                            'rangeType': recurrenceRangeType,
                            'recurId': recurrenceId,
                            'tz': timezone,
                            'ridZ': recurIdZ,
                          }
                        ],
                        'dates': [
                          {
                            'tz': timezone,
                            'dtval': [
                              {
                                's': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'e': {
                                  'd': dateTimeString,
                                  'tz': timezone,
                                  'u': utcTime,
                                },
                                'dur': {
                                  'neg': durationNegative,
                                  'w': weeks,
                                  'd': days,
                                  'h': hours,
                                  'm': minutes,
                                  's': seconds,
                                  'related': AlarmRelated.start.name,
                                  'count': repeatCount,
                                },
                              }
                            ],
                          }
                        ],
                        'rule': [
                          {
                            'freq': Frequency.second.name,
                            'until': {
                              'd': dateTimeString,
                            },
                            'count': {
                              'num': num,
                            },
                            'interval': {
                              'ival': ival,
                            },
                            'bysecond': {
                              'seclist': list,
                            },
                            'byminute': {
                              'minlist': list,
                            },
                            'byhour': {
                              'hrlist': list,
                            },
                            'byday': {
                              'wkday': [
                                {
                                  'day': WeekDay.sunday.name,
                                  'ordWk': ordWk,
                                }
                              ],
                            },
                            'bymonthday': {
                              'modaylist': list,
                            },
                            'byyearday': {
                              'yrdaylist': list,
                            },
                            'byweekno': {
                              'wklist': list,
                            },
                            'bymonth': {
                              'molist': list,
                            },
                            'bysetpos': {
                              'poslist': list,
                            },
                            'wkst': {
                              'day': WeekDay.sunday.name,
                            },
                            'rule-x-name': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      },
                      'exceptId': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'rangeType': recurrenceRangeType,
                      },
                      's': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'e': {
                        'd': dateTimeString,
                        'tz': timezone,
                        'u': utcTime,
                      },
                      'dur': {
                        'neg': durationNegative,
                        'w': weeks,
                        'd': days,
                        'h': hours,
                        'm': minutes,
                        's': seconds,
                        'related': AlarmRelated.start.name,
                        'count': repeatCount,
                      },
                      'method': method,
                      'compNum': componentNum,
                      'rsvp': rsvp,
                      'priority': priority,
                      'name': name,
                      'loc': location,
                      'percentComplete': percentComplete,
                      'completed': completed,
                      'noBlob': noBlob,
                      'fba': FreeBusyStatus.free.name,
                      'fb': FreeBusyStatus.free.name,
                      'transp': Transparency.opaque.name,
                      'isOrg': isOrganizer,
                      'x_uid': xUid,
                      'uid': uid,
                      'seq': sequence,
                      'd': dateTime,
                      'calItemId': calItemId,
                      'apptId': deprecatedApptId,
                      'ciFolder': calItemFolder,
                      'status': InviteStatus.completed.name,
                      'class': InviteClass.public.name,
                      'url': url,
                      'ex': isException,
                      'ridZ': recurIdZ,
                      'allDay': isAllDay,
                      'draft': isDraft,
                      'neverSent': neverSent,
                      'changes': changes,
                    },
                    'mp': [
                      {
                        'part': part,
                        'ct': contentType,
                        's': size,
                        'cd': contentDisposition,
                        'filename': contentFilename,
                        'ci': contentId,
                        'cl': location,
                        'body': body,
                        'truncated': truncatedContent,
                        'content': content,
                        'mp': [
                          {
                            'part': part,
                            'ct': contentType,
                            's': size,
                            'cd': contentDisposition,
                            'filename': contentFilename,
                            'ci': contentId,
                            'cl': location,
                            'body': body,
                            'truncated': truncatedContent,
                            'content': content,
                          }
                        ],
                      }
                    ],
                    'shr': [
                      {
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                    'dlSubs': [
                      {
                        'truncated': truncatedContent,
                        'content': content,
                      }
                    ],
                  }
                ],
                'replies': {
                  'reply': [
                    {
                      'rangeType': recurrenceRangeType,
                      'recurId': recurrenceId,
                      'seq': sequence,
                      'd': date,
                      'at': attendee,
                      'sentBy': sentBy,
                      'ptst': partStat.name,
                      'tz': timezone,
                      'ridZ': recurIdZ,
                    }
                  ]
                },
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              },
            ],
            'task': [
              {
                'f': flags,
                't': tags,
                'tn': tagNames,
                'uid': uid,
                'id': id,
                'rev': revision,
                's': size,
                'd': date,
                'l': folder,
                'md': changeDate,
                'ms': modifiedSequence,
                'nextAlarm': nextAlarm,
                'orphan': orphan,
              }
            ],
            'c': [
              {
                'id': id,
                'n': num,
                'u': numUnread,
                'total': totalSize,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'd': date,
                'elided': elided,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'su': subject,
                'fr': fragment,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
              }
            ],
            'w': [
              {
                'id': id,
                'uuid': uuid,
                'name': name,
                's': size,
                'd': date,
                'l': folderId,
                'luuid': folderUuid,
                'ms': modifiedSequence,
                'mdver': metadataVersion,
                'md': changeDate,
                'rev': revision,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'desc': description,
                'ct': contentType,
                'descEnabled': descEnabled,
                'ver': version,
                'leb': lastEditedBy,
                'cr': creator,
                'cd': createdDate,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'fr': fragment,
                'acl': {
                  'internalGrantExpiry': internalGrantExpiry,
                  'guestGrantExpiry': guestGrantExpiry,
                  'grant': [
                    {
                      'perm': perm,
                      'gt': GrantGranteeType.all.name,
                      'zid': granteeId,
                      'expiry': expiry,
                      'd': granteeName,
                      'pw': guestPassword,
                      'key': accessKey,
                    }
                  ],
                },
              }
            ],
            'doc': [
              {
                'loid': lockOwnerId,
                'loe': lockOwnerEmail,
                'lt': lockOwnerTimestamp,
                'id': id,
                'uuid': uuid,
                'name': name,
                's': size,
                'd': date,
                'l': folderId,
                'luuid': folderUuid,
                'ms': modifiedSequence,
                'mdver': metadataVersion,
                'md': changeDate,
                'rev': revision,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'desc': description,
                'ct': contentType,
                'descEnabled': descEnabled,
                'ver': version,
                'leb': lastEditedBy,
                'cr': creator,
                'cd': createdDate,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
                'fr': fragment,
                'acl': {
                  'internalGrantExpiry': internalGrantExpiry,
                  'guestGrantExpiry': guestGrantExpiry,
                  'grant': [
                    {
                      'perm': perm,
                      'gt': GrantGranteeType.all.name,
                      'zid': granteeId,
                      'expiry': expiry,
                      'd': granteeName,
                      'pw': guestPassword,
                      'key': accessKey,
                    }
                  ],
                },
              }
            ],
            'm': [
              {
                'id': id,
                'autoSendTime': autoSendTime,
                'e': [
                  {
                    'a': address,
                    'd': display,
                    'p': personal,
                    't': AddressType.from.name,
                    'isGroup': isGroup,
                    'exp': canExpandGroupMembers,
                  }
                ],
                'su': subject,
                'fr': fragment,
                'inv': {
                  'type': InviteType.appt.name,
                  'tz': [
                    {
                      'id': id,
                      'stdoff': tzStdOffset,
                      'dayoff': tzDayOffset,
                      'standard': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'daylight': {
                        'mon': month,
                        'hour': hour,
                        'min': minute,
                        'sec': second,
                        'mday': dayOfMonth,
                        'week': week,
                        'wkday': dayOfWeek,
                      },
                      'stdname': standardTZName,
                      'dayname': daylightTZName,
                    }
                  ],
                  'comp': {
                    'category': [
                      {'_content': category}
                    ],
                    'comment': [
                      {'_content': comment}
                    ],
                    'contact': [
                      {'_content': contact}
                    ],
                    'geo': {
                      'lat': latitude,
                      'lon': longitude,
                    },
                    'at': [
                      {
                        'a': address,
                        'url': url,
                        'd': displayName,
                        'sentBy': sentBy,
                        'dir': dir,
                        'lang': language,
                        'cutype': cuType,
                        'role': role,
                        'ptst': partStat.name,
                        'rsvp': rsvp,
                        'member': member,
                        'delegatedTo': delegatedTo,
                        'delegatedFrom': delegatedFrom,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'alarm': [
                      {
                        'action': AlarmAction.display.name,
                        'trigger': {
                          'abs': {
                            'd': dateTimeString,
                          },
                          'rel': {
                            'd': dateTimeString,
                          },
                        },
                        'repeat': {
                          'neg': durationNegative,
                          'w': weeks,
                          'd': days,
                          'h': hours,
                          'm': minutes,
                          's': seconds,
                          'related': AlarmRelated.start.name,
                          'count': repeatCount,
                        },
                        'desc': {'_content': description},
                        'attach': {
                          'uri': uri,
                          'ct': contentType,
                          '_content': binaryB64Data,
                        },
                        'summary': {'_content': summary},
                        'at': [
                          {
                            'a': address,
                            'url': url,
                            'd': displayName,
                            'sentBy': sentBy,
                            'dir': dir,
                            'lang': language,
                            'cutype': cuType,
                            'role': role,
                            'ptst': partStat.name,
                            'rsvp': rsvp,
                            'member': member,
                            'delegatedTo': delegatedTo,
                            'delegatedFrom': delegatedFrom,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                        'xprop': [
                          {
                            'name': name,
                            'value': value,
                            'xparam': [
                              {
                                'name': name,
                                'value': value,
                              }
                            ],
                          }
                        ],
                      }
                    ],
                    'xprop': [
                      {
                        'name': name,
                        'value': value,
                        'xparam': [
                          {
                            'name': name,
                            'value': value,
                          }
                        ],
                      }
                    ],
                    'fr': fragment,
                    'desc': {'_content': description},
                    'descHtml': {'_content': htmlDescription},
                    'or': {
                      'a': address,
                      'url': url,
                      'd': displayName,
                      'sentBy': sentBy,
                      'dir': dir,
                      'lang': language,
                      'xparam': [
                        {
                          'name': name,
                          'value': value,
                        }
                      ],
                    },
                    'recur': {
                      'add': [
                        {'add': []}
                      ],
                      'exclude': [
                        {'exclude': []}
                      ],
                      'except': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                          'add': {'add': []},
                          'exclude': {'exclude': []},
                        }
                      ],
                      'cancel': [
                        {
                          'rangeType': recurrenceRangeType,
                          'recurId': recurrenceId,
                          'tz': timezone,
                          'ridZ': recurIdZ,
                        }
                      ],
                      'dates': [
                        {
                          'tz': timezone,
                          'dtval': [
                            {
                              's': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'e': {
                                'd': dateTimeString,
                                'tz': timezone,
                                'u': utcTime,
                              },
                              'dur': {
                                'neg': durationNegative,
                                'w': weeks,
                                'd': days,
                                'h': hours,
                                'm': minutes,
                                's': seconds,
                                'related': AlarmRelated.start.name,
                                'count': repeatCount,
                              },
                            }
                          ],
                        }
                      ],
                      'rule': [
                        {
                          'freq': Frequency.second.name,
                          'until': {
                            'd': dateTimeString,
                          },
                          'count': {
                            'num': num,
                          },
                          'interval': {
                            'ival': ival,
                          },
                          'bysecond': {
                            'seclist': list,
                          },
                          'byminute': {
                            'minlist': list,
                          },
                          'byhour': {
                            'hrlist': list,
                          },
                          'byday': {
                            'wkday': [
                              {
                                'day': WeekDay.sunday.name,
                                'ordWk': ordWk,
                              }
                            ],
                          },
                          'bymonthday': {
                            'modaylist': list,
                          },
                          'byyearday': {
                            'yrdaylist': list,
                          },
                          'byweekno': {
                            'wklist': list,
                          },
                          'bymonth': {
                            'molist': list,
                          },
                          'bysetpos': {
                            'poslist': list,
                          },
                          'wkst': {
                            'day': WeekDay.sunday.name,
                          },
                          'rule-x-name': [
                            {
                              'name': name,
                              'value': value,
                            }
                          ],
                        }
                      ],
                    },
                    'exceptId': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'rangeType': recurrenceRangeType,
                    },
                    's': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'e': {
                      'd': dateTimeString,
                      'tz': timezone,
                      'u': utcTime,
                    },
                    'dur': {
                      'neg': durationNegative,
                      'w': weeks,
                      'd': days,
                      'h': hours,
                      'm': minutes,
                      's': seconds,
                      'related': AlarmRelated.start.name,
                      'count': repeatCount,
                    },
                    'method': method,
                    'compNum': componentNum,
                    'rsvp': rsvp,
                    'priority': priority,
                    'name': name,
                    'loc': location,
                    'percentComplete': percentComplete,
                    'completed': completed,
                    'noBlob': noBlob,
                    'fba': FreeBusyStatus.free.name,
                    'fb': FreeBusyStatus.free.name,
                    'transp': Transparency.opaque.name,
                    'isOrg': isOrganizer,
                    'x_uid': xUid,
                    'uid': uid,
                    'seq': sequence,
                    'd': dateTime,
                    'calItemId': calItemId,
                    'apptId': deprecatedApptId,
                    'ciFolder': calItemFolder,
                    'status': InviteStatus.completed.name,
                    'class': InviteClass.public.name,
                    'url': url,
                    'ex': isException,
                    'ridZ': recurIdZ,
                    'allDay': isAllDay,
                    'draft': isDraft,
                    'neverSent': neverSent,
                    'changes': changes,
                  },
                  'replies': {
                    'reply': [
                      {
                        'rangeType': recurrenceRangeType,
                        'recurId': recurrenceId,
                        'seq': seq,
                        'd': date,
                        'at': attendee,
                        'sentBy': sentBy,
                        'ptst': partStat.name,
                        'tz': timezone,
                        'ridZ': recurIdZ,
                      }
                    ]
                  },
                },
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
                'meta': [
                  {
                    'section': section,
                    '_attrs': {
                      key: value,
                    },
                  }
                ],
              }
            ],
            'chat': [
              {
                'id': id,
                'autoSendTime': autoSendTime,
                'su': subject,
                'fr': fragment,
                's': size,
                'd': date,
                'l': folder,
                'cid': conversationId,
                'f': flags,
                't': tags,
                'tn': tagNames,
                'rev': revision,
                'md': changeDate,
                'ms': modifiedSequence,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.sync();

      expect(response!.changeDate, changeDate);
      expect(response.token, token);
      expect(response.size, size);
      expect(response.more, more);

      final deleted = response.deleted!;
      expect(deleted.ids, ids);
      expect(deleted.folderTypes.first.ids, ids);
      expect(deleted.searchTypes.first.ids, ids);
      expect(deleted.linkTypes.first.ids, ids);
      expect(deleted.tagTypes.first.ids, ids);
      expect(deleted.convTypes.first.ids, ids);
      expect(deleted.chatTypes.first.ids, ids);
      expect(deleted.msgTypes.first.ids, ids);
      expect(deleted.contactTypes.first.ids, ids);
      expect(deleted.apptTypes.first.ids, ids);
      expect(deleted.taskTypes.first.ids, ids);
      expect(deleted.noteTypes.first.ids, ids);
      expect(deleted.wikiTypes.first.ids, ids);
      expect(deleted.docTypes.first.ids, ids);

      final folderItem = response.folderItems.first;
      expect(folderItem.tagItemIds.first.ids, ids);
      expect(folderItem.convItemIds.first.ids, ids);
      expect(folderItem.chatItemIds.first.ids, ids);
      expect(folderItem.msgItemIds.first.ids, ids);
      expect(folderItem.contactItemIds.first.ids, ids);
      expect(folderItem.apptItemIds.first.ids, ids);
      expect(folderItem.taskItemIds.first.ids, ids);
      expect(folderItem.noteItemIds.first.ids, ids);
      expect(folderItem.wikiItemIds.first.ids, ids);
      expect(folderItem.docItemIds.first.ids, ids);

      expect(folderItem.id, id);
      expect(folderItem.uuid, uuid);
      expect(folderItem.name, name);
      expect(folderItem.absoluteFolderPath, absoluteFolderPath);
      expect(folderItem.parentId, parentId);
      expect(folderItem.folderUuid, folderUuid);
      expect(folderItem.flags, flags);
      expect(folderItem.color, color);
      expect(folderItem.rgb, rgb);
      expect(folderItem.unreadCount, unreadCount);
      expect(folderItem.imapUnreadCount, imapUnreadCount);
      expect(folderItem.view, ViewType.conversation);
      expect(folderItem.revision, revision);
      expect(folderItem.modifiedSequence, modifiedSequence);
      expect(folderItem.changeDate, changeDate);
      expect(folderItem.itemCount, itemCount);
      expect(folderItem.imapItemCount, imapItemCount);
      expect(folderItem.totalSize, totalSize);
      expect(folderItem.imapModifiedSequence, imapModifiedSequence);
      expect(folderItem.imapUidNext, imapUidNext);
      expect(folderItem.url, url);
      expect(folderItem.activeSyncDisabled, activeSyncDisabled);
      expect(folderItem.webOfflineSyncDays, webOfflineSyncDays);
      expect(folderItem.perm, perm);
      expect(folderItem.recursive, recursive);
      expect(folderItem.restUrl, restUrl);
      expect(folderItem.deletable, deletable);

      final folderItemMeta = folderItem.metadatas.first;
      expect(folderItemMeta.section, section);
      expect(folderItemMeta.keyValuePairs.first.key, key);
      expect(folderItemMeta.keyValuePairs.first.value, value);

      final folderItemAcl = folderItem.acl!;
      expect(folderItemAcl.internalGrantExpiry, internalGrantExpiry);
      expect(folderItemAcl.guestGrantExpiry, guestGrantExpiry);

      final folderItemGrant = folderItemAcl.grants.first;
      expect(folderItemGrant.perm, perm);
      expect(folderItemGrant.granteeType, GrantGranteeType.all);
      expect(folderItemGrant.granteeId, granteeId);
      expect(folderItemGrant.expiry, expiry);
      expect(folderItemGrant.granteeName, granteeName);
      expect(folderItemGrant.guestPassword, guestPassword);
      expect(folderItemGrant.accessKey, accessKey);

      final subFolder = folderItem.subFolders.first;
      expect(subFolder.id, id);
      expect(subFolder.uuid, uuid);
      expect(subFolder.name, name);
      expect(subFolder, isA<Folder>());

      final folderItemLink = folderItem.mountpoints.first;
      expect(folderItemLink.id, id);
      expect(folderItemLink.name, name);
      expect(folderItemLink.ownerEmail, ownerEmail);
      expect(folderItemLink.ownerAccountId, ownerAccountId);
      expect(folderItemLink.remoteFolderId, remoteFolderId);
      expect(folderItemLink.remoteUuid, remoteUuid);
      expect(folderItemLink.remoteFolderName, remoteFolderName);
      expect(folderItemLink.reminderEnabled, reminderEnabled);
      expect(folderItemLink.broken, broken);
      expect(folderItemLink, isA<Folder>());

      final folderItemSearch = folderItem.searchFolders.first;
      expect(folderItemSearch.id, id);
      expect(folderItemSearch.name, name);
      expect(folderItemSearch.query, query);
      expect(folderItemSearch.sortBy, SearchSortBy.none);
      expect(folderItemSearch.types, types);
      expect(folderItemSearch, isA<Folder>());

      final folderItemPolicy = folderItem.retentionPolicy!;
      final folderItemKeep = folderItemPolicy.keep.first;
      final folderItemPurge = folderItemPolicy.purge.first;
      expect(folderItemKeep.type, PolicyType.user);
      expect(folderItemKeep.id, id);
      expect(folderItemKeep.name, name);
      expect(folderItemKeep.lifetime, lifetime);
      expect(folderItemPurge.type, PolicyType.user);
      expect(folderItemPurge.id, id);
      expect(folderItemPurge.name, name);
      expect(folderItemPurge.lifetime, lifetime);

      final tagItem = response.tagItems.first;
      expect(tagItem.id, id);
      expect(tagItem.name, name);
      expect(tagItem.color, color);
      expect(tagItem.rgb, rgb);
      expect(tagItem.unread, unread);
      expect(tagItem.count, count);
      expect(tagItem.date, date);
      expect(tagItem.revision, revision);
      expect(tagItem.changeDate, changeDate);
      expect(tagItem.modifiedSequence, modifiedSequence);

      final tagItemMeta = tagItem.metadatas.first;
      expect(tagItemMeta.section, section);
      expect(tagItemMeta.keyValuePairs.first.key, key);
      expect(tagItemMeta.keyValuePairs.first.value, value);

      final tagItemPolicy = tagItem.retentionPolicy!;
      final tagItemKeep = tagItemPolicy.keep.first;
      final tagItemPurge = tagItemPolicy.purge.first;
      expect(tagItemKeep.type, PolicyType.user);
      expect(tagItemKeep.id, id);
      expect(tagItemKeep.name, name);
      expect(tagItemKeep.lifetime, lifetime);
      expect(tagItemPurge.type, PolicyType.user);
      expect(tagItemPurge.id, id);
      expect(tagItemPurge.name, name);
      expect(tagItemPurge.lifetime, lifetime);

      final noteItem = response.noteItems.first;
      expect(noteItem.id, id);
      expect(noteItem.revision, revision);
      expect(noteItem.folder, folder);
      expect(noteItem.date, date);
      expect(noteItem.flags, flags);
      expect(noteItem.tags, tags);
      expect(noteItem.tagNames, tagNames);
      expect(noteItem.bounds, bounds);
      expect(noteItem.color, color);
      expect(noteItem.rgb, rgb);
      expect(noteItem.changeDate, changeDate);
      expect(noteItem.modifiedSequence, modifiedSequence);
      expect(noteItem.content, content);

      final noteItemMeta = noteItem.metadatas.first;
      expect(noteItemMeta.section, section);
      expect(noteItemMeta.keyValuePairs.first.key, key);
      expect(noteItemMeta.keyValuePairs.first.value, value);

      final contactItem = response.contactItems.first;
      expect(contactItem.sortField, sortField);
      expect(contactItem.canExpand, canExpand);
      expect(contactItem.id, id);
      expect(contactItem.imapUid, imapUid);
      expect(contactItem.folder, folder);
      expect(contactItem.flags, flags);
      expect(contactItem.tags, tags);
      expect(contactItem.tagNames, tagNames);
      expect(contactItem.changeDate, changeDate);
      expect(contactItem.modifiedSequenceId, modifiedSequenceId);
      expect(contactItem.date, date);
      expect(contactItem.revisionId, revisionId);
      expect(contactItem.fileAs, fileAs);
      expect(contactItem.email, email);
      expect(contactItem.email2, email2);
      expect(contactItem.email3, email3);
      expect(contactItem.type, type);
      expect(contactItem.dlist, dlist);
      expect(contactItem.reference, reference);
      expect(contactItem.tooManyMembers, tooManyMembers);
      expect(contactItem.memberOf, memberOf);

      final contactMeta = contactItem.metadatas.first;
      expect(contactMeta.section, section);
      expect(contactMeta.keyValuePairs.first.key, key);
      expect(contactMeta.keyValuePairs.first.value, value);

      final contactAttr = contactItem.attrs.first;
      expect(contactAttr.key, key);
      expect(contactAttr.value, value);
      // expect(contactAttr.part, part);
      // expect(contactAttr.contentType, contentType);
      // expect(contactAttr.size, size);
      // expect(contactAttr.contentFilename, contentFilename);

      final contactMember = contactItem.contactGroupMembers.first;
      expect(contactMember.type, MemberType.contact);
      expect(contactMember.value, value);

      final contactMemberCn = contactMember.contact!;
      expect(contactMemberCn.sortField, sortField);
      expect(contactMemberCn.canExpand, canExpand);
      expect(contactMemberCn.id, id);
      expect(contactMemberCn.imapUid, imapUid);
      expect(contactMemberCn.folder, folder);
      expect(contactMemberCn.flags, flags);
      expect(contactMemberCn.tags, tags);
      expect(contactMemberCn.tagNames, tagNames);
      expect(contactMemberCn.changeDate, changeDate);
      expect(contactMemberCn.modifiedSequenceId, modifiedSequenceId);
      expect(contactMemberCn.date, date);
      expect(contactMemberCn.revisionId, revisionId);
      expect(contactMemberCn.fileAs, fileAs);
      expect(contactMemberCn.email, email);
      expect(contactMemberCn.email2, email2);
      expect(contactMemberCn.email3, email3);
      expect(contactMemberCn.type, type);
      expect(contactMemberCn.dlist, dlist);
      expect(contactMemberCn.reference, reference);
      expect(contactMemberCn.tooManyMembers, tooManyMembers);
      expect(contactMemberCn.memberOf, memberOf);

      final apptItem = response.apptItems.first;
      expect(apptItem.flags, flags);
      expect(apptItem.tags, tags);
      expect(apptItem.tagNames, tagNames);
      expect(apptItem.uid, uid);
      expect(apptItem.id, id);
      expect(apptItem.revision, revision);
      expect(apptItem.size, size);
      expect(apptItem.date, date);
      expect(apptItem.folder, folder);
      expect(apptItem.changeDate, changeDate);
      expect(apptItem.modifiedSequence, modifiedSequence);
      expect(apptItem.nextAlarm, nextAlarm);
      expect(apptItem.orphan, orphan);

      final inv = apptItem.invites.first;
      expect(inv.calItemType, InviteType.appt);
      expect(inv.sequence, sequence);
      expect(inv.id, id);
      expect(inv.componentNum, componentNum);
      expect(inv.recurrenceId, recurrenceId);

      final invTz = inv.timezones.first;
      expect(invTz.id, id);
      expect(invTz.tzStdOffset, tzStdOffset);
      expect(invTz.tzDayOffset, tzDayOffset);
      expect(invTz.standardTZName, standardTZName);
      expect(invTz.daylightTZName, daylightTZName);

      final invTzStandard = invTz.standardTzOnset!;
      expect(invTzStandard.month, month);
      expect(invTzStandard.hour, hour);
      expect(invTzStandard.minute, minute);
      expect(invTzStandard.second, second);
      expect(invTzStandard.dayOfMonth, dayOfMonth);
      expect(invTzStandard.week, week);
      expect(invTzStandard.dayOfWeek, dayOfWeek);

      final invTzDaylight = invTz.daylightTzOnset!;
      expect(invTzDaylight.month, month);
      expect(invTzDaylight.hour, hour);
      expect(invTzDaylight.minute, minute);
      expect(invTzDaylight.second, second);
      expect(invTzDaylight.dayOfMonth, dayOfMonth);
      expect(invTzDaylight.week, week);
      expect(invTzDaylight.dayOfWeek, dayOfWeek);

      final partInfo = inv.partInfos.first;
      expect(partInfo.part, part);
      expect(partInfo.contentType, contentType);
      expect(partInfo.size, size);
      expect(partInfo.contentDisposition, contentDisposition);
      expect(partInfo.contentFilename, contentFilename);
      expect(partInfo.contentId, contentId);
      expect(partInfo.location, location);
      expect(partInfo.body, body);
      expect(partInfo.truncatedContent, truncatedContent);
      expect(partInfo.content, content);
      expect(partInfo.body, body);
      final mpPartInfo = partInfo.mimeParts.first;
      expect(mpPartInfo.part, part);
      expect(mpPartInfo.contentType, contentType);
      expect(mpPartInfo.size, size);
      expect(mpPartInfo.contentDisposition, contentDisposition);
      expect(mpPartInfo.contentFilename, contentFilename);
      expect(mpPartInfo.contentId, contentId);
      expect(mpPartInfo.location, location);
      expect(mpPartInfo.body, body);
      expect(mpPartInfo.truncatedContent, truncatedContent);
      expect(mpPartInfo.content, content);
      expect(mpPartInfo.body, body);

      final shr = inv.shareNotifications.first;
      expect(shr.truncatedContent, truncatedContent);
      expect(shr.content, content);

      final dlSubs = inv.dlSubsNotifications.first;
      expect(dlSubs.truncatedContent, truncatedContent);
      expect(dlSubs.content, content);

      final comp = inv.inviteComponent!;
      expect(comp.method, method);
      expect(comp.componentNum, componentNum);
      expect(comp.rsvp, rsvp);
      expect(comp.priority, priority);
      expect(comp.name, name);
      expect(comp.location, location);
      expect(comp.percentComplete, percentComplete);
      expect(comp.completed, completed);
      expect(comp.noBlob, noBlob);
      expect(comp.freeBusyActual, FreeBusyStatus.free);
      expect(comp.freeBusy, FreeBusyStatus.free);
      expect(comp.transparency, Transparency.opaque);
      expect(comp.isOrganizer, isOrganizer);
      expect(comp.xUid, xUid);
      expect(comp.uid, uid);
      expect(comp.sequence, sequence);
      expect(comp.dateTime, dateTime);
      expect(comp.calItemId, calItemId);
      expect(comp.deprecatedApptId, deprecatedApptId);
      expect(comp.calItemFolder, calItemFolder);
      expect(comp.status, InviteStatus.completed);
      expect(comp.calClass, InviteClass.public);
      expect(comp.url, url);
      expect(comp.isException, isException);
      expect(comp.recurIdZ, recurIdZ);
      expect(comp.isAllDay, isAllDay);
      expect(comp.isDraft, isDraft);
      expect(comp.neverSent, neverSent);
      expect(comp.changes, changes);

      expect(comp.fragment, fragment);
      expect(comp.description, description);
      expect(comp.htmlDescription, htmlDescription);

      expect(comp.categories.first, category);
      expect(comp.comments.first, comment);
      expect(comp.contacts.first, contact);

      final geo = comp.geo!;
      expect(geo.latitude, latitude);
      expect(geo.longitude, longitude);

      final compAt = comp.attendees.first;
      expect(compAt.address, address);
      expect(compAt.url, url);
      expect(compAt.displayName, displayName);
      expect(compAt.sentBy, sentBy);
      expect(compAt.dir, dir);
      expect(compAt.language, language);
      expect(compAt.cuType, cuType);
      expect(compAt.role, role);
      expect(compAt.partStat, partStat);
      expect(compAt.rsvp, rsvp);
      expect(compAt.member, member);
      expect(compAt.delegatedTo, delegatedTo);
      expect(compAt.delegatedFrom, delegatedFrom);
      expect(compAt.xParams.first.name, name);
      expect(compAt.xParams.first.value, value);

      final alarm = comp.alarms.first;
      expect(alarm.action, AlarmAction.display);
      expect(alarm.description, description);
      expect(alarm.summary, summary);
      expect(alarm.attach!.uri, uri);
      expect(alarm.attach!.contentType, contentType);
      expect(alarm.attach!.binaryB64Data, binaryB64Data);

      final alarmAt = alarm.attendees.first;
      expect(alarmAt.address, address);
      expect(alarmAt.url, url);
      expect(alarmAt.displayName, displayName);
      expect(alarmAt.sentBy, sentBy);
      expect(alarmAt.dir, dir);
      expect(alarmAt.language, language);
      expect(alarmAt.cuType, cuType);
      expect(alarmAt.role, role);
      expect(alarmAt.partStat, partStat);
      expect(alarmAt.rsvp, rsvp);
      expect(alarmAt.member, member);
      expect(alarmAt.delegatedTo, delegatedTo);
      expect(alarmAt.delegatedFrom, delegatedFrom);
      expect(alarmAt.xParams.first.name, name);
      expect(alarmAt.xParams.first.value, value);

      final alarmXProp = alarm.xProps.first;
      expect(alarmXProp.name, name);
      expect(alarmXProp.value, value);
      expect(alarmXProp.xParams.first.name, name);
      expect(alarmXProp.xParams.first.value, value);

      final compXProp = comp.xProps.first;
      expect(compXProp.name, name);
      expect(compXProp.value, value);
      expect(compXProp.xParams.first.name, name);
      expect(compXProp.xParams.first.value, value);

      final organizer = comp.organizer!;
      expect(organizer.address, address);
      expect(organizer.url, url);
      expect(organizer.displayName, displayName);
      expect(organizer.sentBy, sentBy);
      expect(organizer.dir, dir);
      expect(organizer.language, language);
      expect(organizer.xParams.first.name, name);
      expect(organizer.xParams.first.value, value);

      final recurrence = comp.recurrence!;
      expect(recurrence.add.first, isA<AddRecurrenceInfo>());
      expect(recurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final except = recurrence.except.first;
      expect(except.recurrenceRangeType, recurrenceRangeType);
      expect(except.recurrenceId, recurrenceId);
      expect(except.timezone, timezone);
      expect(except.recurIdZ, recurIdZ);
      expect(except.add, isA<RecurrenceInfo>());
      expect(except.exclude, isA<RecurrenceInfo>());

      final cancel = recurrence.cancel.first;
      expect(cancel.recurrenceRangeType, recurrenceRangeType);
      expect(cancel.recurrenceId, recurrenceId);
      expect(cancel.timezone, timezone);
      expect(cancel.recurIdZ, recurIdZ);

      final dates = recurrence.dates.first;
      expect(dates.timezone, timezone);

      final startTime = dates.dtVals.first.startTime!;
      expect(startTime.dateTime, dateTimeString);
      expect(startTime.timezone, timezone);
      expect(startTime.utcTime, utcTime);

      final endTime = dates.dtVals.first.endTime!;
      expect(endTime.dateTime, dateTimeString);
      expect(endTime.timezone, timezone);
      expect(endTime.utcTime, utcTime);

      final duration = dates.dtVals.first.duration!;
      expect(duration.durationNegative, durationNegative);
      expect(duration.weeks, weeks);
      expect(duration.days, days);
      expect(duration.hours, hours);
      expect(duration.minutes, minutes);
      expect(duration.seconds, seconds);
      expect(duration.related, AlarmRelated.start);
      expect(duration.repeatCount, repeatCount);

      final simple = recurrence.simple.first;
      expect(simple.until!.dateTime, dateTimeString);
      expect(simple.count!.num, num);
      expect(simple.interval!.ival, ival);
      expect(simple.bySecond!.list, list);
      expect(simple.byMinute!.list, list);
      expect(simple.byHour!.list, list);
      expect(simple.byDay!.days.first.day, WeekDay.sunday);
      expect(simple.byDay!.days.first.ordWk, ordWk);
      expect(simple.byMonthDay!.list, list);
      expect(simple.byYearDay!.list, list);
      expect(simple.byWeekNo!.list, list);
      expect(simple.byMonth!.list, list);
      expect(simple.bySetPose!.list, list);
      expect(simple.weekStart!.day, WeekDay.sunday);
      expect(simple.xNames.first.name, name);
      expect(simple.xNames.first.value, value);

      final exceptionId = comp.exceptionId!;
      expect(exceptionId.dateTime, dateTimeString);
      expect(exceptionId.timezone, timezone);
      expect(exceptionId.recurrenceRangeType, recurrenceRangeType);

      final dtStart = comp.dtStart!;
      expect(dtStart.dateTime, dateTimeString);
      expect(dtStart.timezone, timezone);
      expect(dtStart.utcTime, utcTime);

      final dtEnd = comp.dtEnd!;
      expect(dtEnd.dateTime, dateTimeString);
      expect(dtEnd.timezone, timezone);
      expect(dtEnd.utcTime, utcTime);

      final inviteDuration = comp.duration!;
      expect(inviteDuration.durationNegative, durationNegative);
      expect(inviteDuration.weeks, weeks);
      expect(inviteDuration.days, days);
      expect(inviteDuration.hours, hours);
      expect(inviteDuration.minutes, minutes);
      expect(inviteDuration.seconds, seconds);
      expect(inviteDuration.related, AlarmRelated.start);
      expect(inviteDuration.repeatCount, repeatCount);

      final apptReply = apptItem.calendarReplies.first;
      expect(apptReply.recurrenceRangeType, recurrenceRangeType);
      expect(apptReply.recurrenceId, recurrenceId);
      expect(apptReply.seq, sequence);
      expect(apptReply.date, date);
      expect(apptReply.attendee, attendee);
      expect(apptReply.sentBy, sentBy);
      expect(apptReply.partStat, partStat);
      expect(apptReply.timezone, timezone);
      expect(apptReply.recurIdZ, recurIdZ);

      final apptMeta = apptItem.metadatas.first;
      expect(apptMeta.section, section);
      expect(apptMeta.keyValuePairs.first.key, key);
      expect(apptMeta.keyValuePairs.first.value, value);

      final taskItem = response.taskItems.first;
      expect(taskItem, isA<TaskItemInfo>());
      expect(taskItem, isA<CalendarItemInfo>());
      expect(taskItem.flags, flags);
      expect(taskItem.tags, tags);
      expect(taskItem.tagNames, tagNames);
      expect(taskItem.uid, uid);
      expect(taskItem.id, id);
      expect(taskItem.revision, revision);
      expect(taskItem.size, size);
      expect(taskItem.date, date);
      expect(taskItem.folder, folder);
      expect(taskItem.changeDate, changeDate);
      expect(taskItem.modifiedSequence, modifiedSequence);
      expect(taskItem.nextAlarm, nextAlarm);
      expect(taskItem.orphan, orphan);

      final convItem = response.convItems.first;
      expect(convItem.id, id);
      expect(convItem.numMsg, num);
      expect(convItem.numUnread, numUnread);
      expect(convItem.totalSize, totalSize);
      expect(convItem.flags, flags);
      expect(convItem.tags, tags);
      expect(convItem.tagNames, tagNames);
      expect(convItem.date, date);
      expect(convItem.elided, elided);
      expect(convItem.changeDate, changeDate);
      expect(convItem.modifiedSequence, modifiedSequence);
      expect(convItem.subject, subject);
      expect(convItem.fragment, fragment);

      final convMeta = convItem.metadatas.first;
      expect(convMeta.section, section);
      expect(convMeta.keyValuePairs.first.key, key);
      expect(convMeta.keyValuePairs.first.value, value);

      final convEmail = convItem.emails.first;
      expect(convEmail.address, address);
      expect(convEmail.display, display);
      expect(convEmail.personal, personal);
      expect(convEmail.addressType, AddressType.from);
      expect(convEmail.isGroup, isGroup);
      expect(convEmail.canExpandGroupMembers, canExpandGroupMembers);

      final wikiItem = response.wikiItems.first;
      expect(wikiItem.id, id);
      expect(wikiItem.uuid, uuid);
      expect(wikiItem.name, name);
      expect(wikiItem.size, size);
      expect(wikiItem.date, date);
      expect(wikiItem.folderId, folderId);
      expect(wikiItem.folderUuid, folderUuid);
      expect(wikiItem.modifiedSequence, modifiedSequence);
      expect(wikiItem.metadataVersion, metadataVersion);
      expect(wikiItem.changeDate, changeDate);
      expect(wikiItem.revision, revision);
      expect(wikiItem.flags, flags);
      expect(wikiItem.tags, tags);
      expect(wikiItem.tagNames, tagNames);
      expect(wikiItem.description, description);
      expect(wikiItem.contentType, contentType);
      expect(wikiItem.descEnabled, descEnabled);
      expect(wikiItem.version, version);
      expect(wikiItem.lastEditedBy, lastEditedBy);
      expect(wikiItem.creator, creator);
      expect(wikiItem.createdDate, createdDate);
      expect(wikiItem.fragment, fragment);

      final wikiMeta = wikiItem.metadatas.first;
      expect(wikiMeta.section, section);
      expect(wikiMeta.keyValuePairs.first.key, key);
      expect(wikiMeta.keyValuePairs.first.value, value);

      final wikiAcl = wikiItem.acl!;
      expect(wikiAcl.internalGrantExpiry, internalGrantExpiry);
      expect(wikiAcl.guestGrantExpiry, guestGrantExpiry);

      final wikiGrant = wikiAcl.grants.first;
      expect(wikiGrant.perm, perm);
      expect(wikiGrant.granteeType, GrantGranteeType.all);
      expect(wikiGrant.granteeId, granteeId);
      expect(wikiGrant.expiry, expiry);
      expect(wikiGrant.granteeName, granteeName);
      expect(wikiGrant.guestPassword, guestPassword);
      expect(wikiGrant.accessKey, accessKey);

      final docItem = response.docItems.first;
      expect(docItem.lockOwnerId, lockOwnerId);
      expect(docItem.lockOwnerEmail, lockOwnerEmail);
      expect(docItem.lockOwnerTimestamp, lockOwnerTimestamp);
      expect(docItem.id, id);
      expect(docItem.uuid, uuid);
      expect(docItem.name, name);
      expect(docItem.size, size);
      expect(docItem.date, date);
      expect(docItem.folderId, folderId);
      expect(docItem.folderUuid, folderUuid);
      expect(docItem.modifiedSequence, modifiedSequence);
      expect(docItem.metadataVersion, metadataVersion);
      expect(docItem.changeDate, changeDate);
      expect(docItem.revision, revision);
      expect(docItem.flags, flags);
      expect(docItem.tags, tags);
      expect(docItem.tagNames, tagNames);
      expect(docItem.description, description);
      expect(docItem.contentType, contentType);
      expect(docItem.descEnabled, descEnabled);
      expect(docItem.version, version);
      expect(docItem.lastEditedBy, lastEditedBy);
      expect(docItem.creator, creator);
      expect(docItem.createdDate, createdDate);
      expect(docItem.fragment, fragment);

      final docMeta = docItem.metadatas.first;
      expect(docMeta.section, section);
      expect(docMeta.keyValuePairs.first.key, key);
      expect(docMeta.keyValuePairs.first.value, value);

      final docAcl = docItem.acl!;
      expect(docAcl.internalGrantExpiry, internalGrantExpiry);
      expect(docAcl.guestGrantExpiry, guestGrantExpiry);

      final docGrant = docAcl.grants.first;
      expect(docGrant.perm, perm);
      expect(docGrant.granteeType, GrantGranteeType.all);
      expect(docGrant.granteeId, granteeId);
      expect(docGrant.expiry, expiry);
      expect(docGrant.granteeName, granteeName);
      expect(docGrant.guestPassword, guestPassword);
      expect(docGrant.accessKey, accessKey);

      final msgItem = response.msgItems.first;
      expect(msgItem.id, id);
      expect(msgItem.autoSendTime, autoSendTime);
      expect(msgItem.subject, subject);
      expect(msgItem.fragment, fragment);
      expect(msgItem.size, size);
      expect(msgItem.date, date);
      expect(msgItem.folder, folder);
      expect(msgItem.conversationId, conversationId);
      expect(msgItem.flags, flags);
      expect(msgItem.tags, tags);
      expect(msgItem.tagNames, tagNames);
      expect(msgItem.revision, revision);
      expect(msgItem.changeDate, changeDate);
      expect(msgItem.modifiedSequence, modifiedSequence);

      final msgEmail = msgItem.emails.first;
      expect(msgEmail.address, address);
      expect(msgEmail.display, display);
      expect(msgEmail.personal, personal);
      expect(msgEmail.addressType, AddressType.from);
      expect(msgEmail.isGroup, isGroup);
      expect(msgEmail.canExpandGroupMembers, canExpandGroupMembers);

      final msgMeta = msgItem.metadatas.first;
      expect(msgMeta.section, section);
      expect(msgMeta.keyValuePairs.first.key, key);
      expect(msgMeta.keyValuePairs.first.value, value);

      final msgInvite = msgItem.invite!;
      expect(msgInvite.calItemType, InviteType.appt);

      final msgTz = msgInvite.timezones.first;
      expect(msgTz.id, id);
      expect(msgTz.tzStdOffset, tzStdOffset);
      expect(msgTz.tzDayOffset, tzDayOffset);
      expect(msgTz.standardTZName, standardTZName);
      expect(msgTz.daylightTZName, daylightTZName);

      final msgStandardTzOnset = msgTz.standardTzOnset!;
      expect(msgStandardTzOnset.month, month);
      expect(msgStandardTzOnset.hour, hour);
      expect(msgStandardTzOnset.minute, minute);
      expect(msgStandardTzOnset.second, second);
      expect(msgStandardTzOnset.dayOfMonth, dayOfMonth);
      expect(msgStandardTzOnset.week, week);
      expect(msgStandardTzOnset.dayOfWeek, dayOfWeek);

      final msgDaylightTzOnset = msgTz.daylightTzOnset!;
      expect(msgDaylightTzOnset.month, month);
      expect(msgDaylightTzOnset.hour, hour);
      expect(msgDaylightTzOnset.minute, minute);
      expect(msgDaylightTzOnset.second, second);
      expect(msgDaylightTzOnset.dayOfMonth, dayOfMonth);
      expect(msgDaylightTzOnset.week, week);
      expect(msgDaylightTzOnset.dayOfWeek, dayOfWeek);

      final msgReply = msgInvite.calendarReplies.first;
      expect(msgReply.recurrenceRangeType, recurrenceRangeType);
      expect(msgReply.recurrenceId, recurrenceId);
      expect(msgReply.seq, seq);
      expect(msgReply.date, date);
      expect(msgReply.attendee, attendee);
      expect(msgReply.sentBy, sentBy);
      expect(msgReply.partStat, partStat);
      expect(msgReply.timezone, timezone);
      expect(msgReply.recurIdZ, recurIdZ);

      final msgInviteComponent = msgInvite.inviteComponent!;

      expect(msgInviteComponent.method, method);
      expect(msgInviteComponent.componentNum, componentNum);
      expect(msgInviteComponent.rsvp, rsvp);
      expect(msgInviteComponent.priority, priority);
      expect(msgInviteComponent.name, name);
      expect(msgInviteComponent.location, location);
      expect(msgInviteComponent.percentComplete, percentComplete);
      expect(msgInviteComponent.completed, completed);
      expect(msgInviteComponent.noBlob, noBlob);
      expect(msgInviteComponent.freeBusyActual, FreeBusyStatus.free);
      expect(msgInviteComponent.freeBusy, FreeBusyStatus.free);
      expect(msgInviteComponent.transparency, Transparency.opaque);
      expect(msgInviteComponent.isOrganizer, isOrganizer);
      expect(msgInviteComponent.xUid, xUid);
      expect(msgInviteComponent.uid, uid);
      expect(msgInviteComponent.sequence, sequence);
      expect(msgInviteComponent.dateTime, dateTime);
      expect(msgInviteComponent.calItemId, calItemId);
      expect(msgInviteComponent.deprecatedApptId, deprecatedApptId);
      expect(msgInviteComponent.calItemFolder, calItemFolder);
      expect(msgInviteComponent.status, InviteStatus.completed);
      expect(msgInviteComponent.calClass, InviteClass.public);
      expect(msgInviteComponent.url, url);
      expect(msgInviteComponent.isException, isException);
      expect(msgInviteComponent.recurIdZ, recurIdZ);
      expect(msgInviteComponent.isAllDay, isAllDay);
      expect(msgInviteComponent.isDraft, isDraft);
      expect(msgInviteComponent.neverSent, neverSent);
      expect(msgInviteComponent.changes, changes);

      expect(msgInviteComponent.fragment, fragment);
      expect(msgInviteComponent.description, description);
      expect(msgInviteComponent.htmlDescription, htmlDescription);

      expect(msgInviteComponent.categories.first, category);
      expect(msgInviteComponent.comments.first, comment);
      expect(msgInviteComponent.contacts.first, contact);

      final msgGeo = msgInviteComponent.geo!;
      expect(msgGeo.latitude, latitude);
      expect(msgGeo.longitude, longitude);

      final inviteAt = msgInviteComponent.attendees.first;
      expect(inviteAt.address, address);
      expect(inviteAt.url, url);
      expect(inviteAt.displayName, displayName);
      expect(inviteAt.sentBy, sentBy);
      expect(inviteAt.dir, dir);
      expect(inviteAt.language, language);
      expect(inviteAt.cuType, cuType);
      expect(inviteAt.role, role);
      expect(inviteAt.partStat, partStat);
      expect(inviteAt.rsvp, rsvp);
      expect(inviteAt.member, member);
      expect(inviteAt.delegatedTo, delegatedTo);
      expect(inviteAt.delegatedFrom, delegatedFrom);
      expect(inviteAt.xParams.first.name, name);
      expect(inviteAt.xParams.first.value, value);

      final msgAlarm = msgInviteComponent.alarms.first;
      expect(msgAlarm.action, AlarmAction.display);
      expect(msgAlarm.description, description);
      expect(msgAlarm.summary, summary);
      expect(msgAlarm.attach!.uri, uri);
      expect(msgAlarm.attach!.contentType, contentType);
      expect(msgAlarm.attach!.binaryB64Data, binaryB64Data);

      final msgAlarmAt = msgAlarm.attendees.first;
      expect(msgAlarmAt.address, address);
      expect(msgAlarmAt.url, url);
      expect(msgAlarmAt.displayName, displayName);
      expect(msgAlarmAt.sentBy, sentBy);
      expect(msgAlarmAt.dir, dir);
      expect(msgAlarmAt.language, language);
      expect(msgAlarmAt.cuType, cuType);
      expect(msgAlarmAt.role, role);
      expect(msgAlarmAt.partStat, partStat);
      expect(msgAlarmAt.rsvp, rsvp);
      expect(msgAlarmAt.member, member);
      expect(msgAlarmAt.delegatedTo, delegatedTo);
      expect(msgAlarmAt.delegatedFrom, delegatedFrom);
      expect(msgAlarmAt.xParams.first.name, name);
      expect(msgAlarmAt.xParams.first.value, value);

      final msgAlarmXProp = msgAlarm.xProps.first;
      expect(msgAlarmXProp.name, name);
      expect(msgAlarmXProp.value, value);
      expect(msgAlarmXProp.xParams.first.name, name);
      expect(msgAlarmXProp.xParams.first.value, value);

      final msgInviteXProp = msgInviteComponent.xProps.first;
      expect(msgInviteXProp.name, name);
      expect(msgInviteXProp.value, value);
      expect(msgInviteXProp.xParams.first.name, name);
      expect(msgInviteXProp.xParams.first.value, value);

      final msgOrganizer = msgInviteComponent.organizer!;
      expect(msgOrganizer.address, address);
      expect(msgOrganizer.url, url);
      expect(msgOrganizer.displayName, displayName);
      expect(msgOrganizer.sentBy, sentBy);
      expect(msgOrganizer.dir, dir);
      expect(msgOrganizer.language, language);
      expect(msgOrganizer.xParams.first.name, name);
      expect(msgOrganizer.xParams.first.value, value);

      final msgRecurrence = msgInviteComponent.recurrence!;
      expect(msgRecurrence.add.first, isA<AddRecurrenceInfo>());
      expect(msgRecurrence.exclude.first, isA<ExcludeRecurrenceInfo>());

      final msgExcept = msgRecurrence.except.first;
      expect(msgExcept.recurrenceRangeType, recurrenceRangeType);
      expect(msgExcept.recurrenceId, recurrenceId);
      expect(msgExcept.timezone, timezone);
      expect(msgExcept.recurIdZ, recurIdZ);
      expect(msgExcept.add, isA<RecurrenceInfo>());
      expect(msgExcept.exclude, isA<RecurrenceInfo>());

      final msgCancel = msgRecurrence.cancel.first;
      expect(msgCancel.recurrenceRangeType, recurrenceRangeType);
      expect(msgCancel.recurrenceId, recurrenceId);
      expect(msgCancel.timezone, timezone);
      expect(msgCancel.recurIdZ, recurIdZ);

      final msgDates = msgRecurrence.dates.first;
      expect(dates.timezone, timezone);

      final msgStartTime = msgDates.dtVals.first.startTime!;
      expect(msgStartTime.dateTime, dateTimeString);
      expect(msgStartTime.timezone, timezone);
      expect(msgStartTime.utcTime, utcTime);

      final msgEndTime = msgDates.dtVals.first.endTime!;
      expect(msgEndTime.dateTime, dateTimeString);
      expect(msgEndTime.timezone, timezone);
      expect(msgEndTime.utcTime, utcTime);

      final msgDuration = msgDates.dtVals.first.duration!;
      expect(msgDuration.durationNegative, durationNegative);
      expect(msgDuration.weeks, weeks);
      expect(msgDuration.days, days);
      expect(msgDuration.hours, hours);
      expect(msgDuration.minutes, minutes);
      expect(msgDuration.seconds, seconds);
      expect(msgDuration.related, AlarmRelated.start);
      expect(msgDuration.repeatCount, repeatCount);

      final msgSimple = msgRecurrence.simple.first;
      expect(msgSimple.until!.dateTime, dateTimeString);
      expect(msgSimple.count!.num, num);
      expect(msgSimple.interval!.ival, ival);
      expect(msgSimple.bySecond!.list, list);
      expect(msgSimple.byMinute!.list, list);
      expect(msgSimple.byHour!.list, list);
      expect(msgSimple.byDay!.days.first.day, WeekDay.sunday);
      expect(msgSimple.byDay!.days.first.ordWk, ordWk);
      expect(msgSimple.byMonthDay!.list, list);
      expect(msgSimple.byYearDay!.list, list);
      expect(msgSimple.byWeekNo!.list, list);
      expect(msgSimple.byMonth!.list, list);
      expect(msgSimple.bySetPose!.list, list);
      expect(msgSimple.weekStart!.day, WeekDay.sunday);
      expect(msgSimple.xNames.first.name, name);
      expect(msgSimple.xNames.first.value, value);

      final msgExceptionId = msgInviteComponent.exceptionId!;
      expect(msgExceptionId.dateTime, dateTimeString);
      expect(msgExceptionId.timezone, timezone);
      expect(msgExceptionId.recurrenceRangeType, recurrenceRangeType);

      final msgDtStart = msgInviteComponent.dtStart!;
      expect(msgDtStart.dateTime, dateTimeString);
      expect(msgDtStart.timezone, timezone);
      expect(msgDtStart.utcTime, utcTime);

      final msgDtEnd = msgInviteComponent.dtEnd!;
      expect(msgDtEnd.dateTime, dateTimeString);
      expect(msgDtEnd.timezone, timezone);
      expect(msgDtEnd.utcTime, utcTime);

      final msgInviteDuration = msgInviteComponent.duration!;
      expect(msgInviteDuration.durationNegative, durationNegative);
      expect(msgInviteDuration.weeks, weeks);
      expect(msgInviteDuration.days, days);
      expect(msgInviteDuration.hours, hours);
      expect(msgInviteDuration.minutes, minutes);
      expect(msgInviteDuration.seconds, seconds);
      expect(msgInviteDuration.related, AlarmRelated.start);
      expect(msgInviteDuration.repeatCount, repeatCount);

      final chatItem = response.chatItems.first;
      expect(chatItem, isA<MessageSummary>());
      expect(chatItem, isA<ChatSummary>());
      expect(chatItem.id, id);
      expect(chatItem.autoSendTime, autoSendTime);
      expect(chatItem.subject, subject);
      expect(chatItem.fragment, fragment);
      expect(chatItem.size, size);
      expect(chatItem.date, date);
      expect(chatItem.folder, folder);
      expect(chatItem.conversationId, conversationId);
      expect(chatItem.flags, flags);
      expect(chatItem.tags, tags);
      expect(chatItem.tagNames, tagNames);
      expect(chatItem.revision, revision);
      expect(chatItem.changeDate, changeDate);
      expect(chatItem.modifiedSequence, modifiedSequence);
    }));

    test('Tag action test', (() async {
      final successes = [faker.guid.guid(), faker.guid.guid(), faker.guid.guid()].join(',');
      final successNames = faker.lorem.word();
      final operation = faker.randomGenerator.element(TagAction.values).name;
      final data = {
        'Body': {
          'TagActionResponse': {
            '_jsns': 'urn:zimbraMail',
            'action': {
              'id': successes,
              'tn': successNames,
              'op': operation,
            },
          }
        }
      };
      final api = mockApi(data);
      final response = await api.tagAction(TagActionSelector(successes, operation));
      final action = response!.action!;
      expect(action.successes, successes);
      expect(action.successNames, successNames);
      expect(action.operation, operation);
    }));

    test('Test data source test', (() async {
      final success = faker.randomGenerator.integer(100);
      final error = faker.lorem.word();
      final data = {
        'Body': {
          'TestDataSourceResponse': {
            '_jsns': 'urn:zimbraMail',
            'imap': [
              {
                'success': success,
                'error': error,
              }
            ],
            'pop3': [
              {
                'success': success,
                'error': error,
              }
            ],
            'caldav': [
              {
                'success': success,
                'error': error,
              }
            ],
            'yab': [
              {
                'success': success,
                'error': error,
              }
            ],
            'rss': [
              {
                'success': success,
                'error': error,
              }
            ],
            'gal': [
              {
                'success': success,
                'error': error,
              }
            ],
            'cal': [
              {
                'success': success,
                'error': error,
              }
            ],
            'unknown': [
              {
                'success': success,
                'error': error,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.testDataSource();

      final imap = response!.imapDataSources.first;
      expect(imap.success, success);
      expect(imap.error, error);

      final pop3 = response.pop3DataSources.first;
      expect(pop3.success, success);
      expect(pop3.error, error);

      final caldav = response.caldavDataSources.first;
      expect(caldav.success, success);
      expect(caldav.error, error);

      final yab = response.yabDataSources.first;
      expect(yab.success, success);
      expect(yab.error, error);

      final rss = response.rssDataSources.first;
      expect(rss.success, success);
      expect(rss.error, error);

      final gal = response.galDataSources.first;
      expect(gal.success, success);
      expect(gal.error, error);

      final cal = response.calDataSources.first;
      expect(cal.success, success);
      expect(cal.error, error);

      final unknown = response.unknownDataSources.first;
      expect(unknown.success, success);
      expect(unknown.error, error);
    }));

    test('Verify code test', (() async {
      final success = faker.randomGenerator.boolean();
      final data = {
        'Body': {
          'VerifyCodeResponse': {
            '_jsns': 'urn:zimbraMail',
            'success': success,
          }
        }
      };
      final api = mockApi(data);
      final response = await api.verifyCode(faker.internet.email(), faker.lorem.word());
      expect(response!.success, success);
    }));

    test('WaitSet test', (() async {
      final id = faker.randomGenerator.integer(100);
      final name = faker.lorem.word();
      final waitSetId = faker.guid.guid();
      final canceled = faker.randomGenerator.boolean();
      final seqNo = faker.randomGenerator.integer(100);
      final lastChangeId = faker.randomGenerator.integer(100);

      final folderId = faker.randomGenerator.integer(100);
      final imapUid = faker.randomGenerator.integer(100);
      final type = faker.lorem.word();
      final flags = faker.lorem.word();
      final tags = faker.lorem.word();
      final path = faker.lorem.word();
      final changeBitmask = faker.randomGenerator.integer(100);

      final data = {
        'Body': {
          'WaitSetResponse': {
            '_jsns': 'urn:zimbraMail',
            'waitSet': waitSetId,
            'canceled': canceled,
            'seq': seqNo,
            'a': [
              {
                'id': id,
                'mods': [
                  {
                    'id': folderId,
                    'created': [
                      {
                        'm': {
                          'id': id,
                          'i4uid': imapUid,
                          't': type,
                          'f': flags,
                          'tn': tags,
                        }
                      }
                    ],
                    'deleted': [
                      {
                        'id': id,
                        't': type,
                      }
                    ],
                    'modMsgs': [
                      {
                        'change': changeBitmask,
                        'm': {
                          'id': id,
                          'i4uid': imapUid,
                          't': type,
                          'f': flags,
                          'tn': tags,
                        },
                      }
                    ],
                    'modTags': [
                      {
                        'id': {'_content': id},
                        'name': {'_content': name},
                        'change': changeBitmask,
                      }
                    ],
                    'modFolders': [
                      {
                        'id': folderId,
                        'path': path,
                        'change': changeBitmask,
                      }
                    ],
                  }
                ],
                'changeid': lastChangeId,
              }
            ],
            'error': [
              {
                'id': id.toString(),
                'type': type,
              }
            ],
          }
        }
      };
      final api = mockApi(data);
      final response = await api.waitSet(waitSetId);

      expect(response!.waitSetId, waitSetId);
      expect(response.canceled, canceled);
      expect(response.seqNo, seqNo);

      final account = response.signalledAccounts.first;
      expect(account.id, id);
      expect(account.lastChangeId, lastChangeId);

      final modification = account.modifications.first;
      expect(modification.folderId, folderId);

      final created = modification.created.first;
      final createdMsgInfo = created.messageInfo!;
      expect(createdMsgInfo.id, id);
      expect(createdMsgInfo.imapUid, imapUid);
      expect(createdMsgInfo.type, type);
      expect(createdMsgInfo.flags, flags);
      expect(createdMsgInfo.tags, tags);

      final modMsg = modification.modifiedMsgs.first;
      expect(modMsg.changeBitmask, changeBitmask);

      final modMsgInfo = modMsg.messageInfo!;
      expect(modMsgInfo.id, id);
      expect(modMsgInfo.imapUid, imapUid);
      expect(modMsgInfo.type, type);
      expect(modMsgInfo.flags, flags);
      expect(modMsgInfo.tags, tags);

      final modTag = modification.modifiedTags.first;
      expect(modTag.id, id);
      expect(modTag.name, name);
      expect(modTag.changeBitmask, changeBitmask);

      final modFolder = modification.modifiedFolders.first;
      expect(modFolder.folderId, folderId);
      expect(modFolder.path, path);
      expect(modFolder.changeBitmask, changeBitmask);

      final error = response.errors.first;
      expect(error.id, id.toString());
      expect(error.type, type);
    }));
  }));
}

MailApi mockApi(Map<String, dynamic> responseData) {
  return MailApi(
    Faker().internet.domainName(),
    httpClientFactory: () => MockClient((request) async {
      return http.Response(
        jsonEncode(responseData),
        200,
        headers: {'content-type': 'text/javascript; charset=utf-8'},
      );
    }),
  );
}
